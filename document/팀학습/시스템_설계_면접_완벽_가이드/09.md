# 09 알림/경보 서비스 설계

공통 관심사를 중앙 집중화한다.


## 9.1 기능 요구사항

MVP 설계 연습으로 좋다.  
가능ㅇ한 기능을 예상하고 새로운 기능과 서비스를 추가하기 쉽고 느슨하게 결합된 구성 요소로 시스템을 설계해 사용자 피드백과 변화하는 비즈니스 요구사항에 대응해 발전할 수 있다.  

### 9.1.1 가동 시간 모니터링용이 아님

알림 서비스는 이메일, SMS와 같은 다양한 메시징 서비스 위에 구축된 계층일 가능성이 높다.  

가동 시간 모니터링 서비스는 모니터링하는 서비스와 독립된 인프라에서 실행돼야 한다.  


### 9.1.2 사용자와 데이터

- 발신자
- 수신자
- 관리자


### 9.1.3 수신자 채널

- 브라우저
- 이메일
- SMS
- 자동 전화 통화
- 모바일 푸시 알림
- 앱 내 맞춤형 알림


### 9.1.4 템플릿

`${first_name}님 환영합니다. 첫 구매 시 ${discount}% 할인을 즐기세요.`


### 9.1.5 트리거 조건

알림은 수동이나 프로그래밍 방식으로 트리거될 수 있다.  


### 9.1.6 구독자, 발신자 그룹, 수신자 그룹 관리

역할 기반 접근 제어(RBAC)도 고려할 수 있다.  


### 9.1.7 사용자 기능

- 중복알림 금지
- 과거 알림 요청 확인
- 많은 알림 구성과 템플릿
- 알림 상태 조회
- 우선순위 알림을 위한 가중치


### 9.1.8 분석


## 9.2 비기능적 요구사항

- 스케일
  - 매일 수십억 개의 알림
- 성능
  - 수천 명의 발신자와 10억 명의 수신자
  - 몇 초 내에 알림 전달
- 고가용성
  - 99.999% 가동 시간
- 내결함성
  - 수신자가 알림을 못 받으면 다음에 알림을 받아야 함
- 보안
  - 인증된 사용자만 알림을 보내야함
- 프라이버시
  - 수신자는 알림 수신을 거부할 수 있어야 함


## 9.3 초기 고수준 아키텍처

알림을 전적으로 동기 메커니즘을 통해 보내는 방식에는 확장성이 없다.  
수천 명의 발신자와 수십억 명의 수신자를 지원하려면 이벤트 스트리밍과 같은 비동기 기술을 사용해야 한다.  

알림 서비스에서 채널 서비스와 다른 서비스 간에 연결이 없으므로 시스템의 내결함성이 높아지고 다음과 같은 작업이 가능하다.  

프런트엔드 서비스는 다음과 같은 공통 작업을 제공한다.  
- 속도 제한(Rate limiting)
- 프라이버시
- 보안
- 모니터링, 분석, 경보
- 캐싱

각 채널에 대해 카프카 토픽을 프로비저닝한다.  
우선순위 수준에 대한 카프카 토픽도 가질 수 있어 5개의 채널과 3개의 우선순위 수준이 있다면 15개의 토픽을 갖게 된다.  

> 채널이 많아질 수록 토픽은 x3개씩 생길탠데, 감당이 가능한건지


## 9.4 객체 스토리지: 알림 구성과 전송

알림에는 큰 파일이나 객체가 포함될 수 있다.  
백엔드는 먼저 이러한 큰 객체를 객체 저장소에 POST하고, 객체 ID를 반환받을 수 있다.  
그런 다음 백엔드는 원본 객체 대신 이러한 객체 ID를 포함하는 알림 이벤트를 생성하고 이 이벤트를 적절한 카프카 토픽에 생성할 수 있다.  
채널 서비스는 이 이벤트를 소비하고, 객체 저장소에서 객체를 GET하고, 알림을 조립한 다음 수신자에게 전달한다.  


## 9.5 알림 템플릿

### 9.5.1 알림 템플릿 서비스

개인화를 관리하는 데 템플릿이 유용하다.  
템플릿은 알림 서비스의 확장성을 개선하는 데도 유용하다.  

### 9.5.2 추가 기능

#### 저작, 접근 제어, 변경 관리

사용자 역할에는 관리자, 쓰기, 읽기, 없음이 있다.  

템플릿의 변경 이력을 기록하고자 할 수 있으며, 정확한 변경 내용, 변경을 수행한 사용자, 타임스탬프와 같은 데이터가 포함된다.  
더 나아가 변경 승인 프로세스를 개발하고자 할 수 있다.  

#### 재사용 가능하고 확장 가능한 템플릿 클래스와 함수

템플릿은 재사용 가능한 하위 템플릿으로 구성될 수 있으며, 각각 별도로 소유되고 관리된다.  

템플릿의 매개변수는 변수 또는 함수일 수 있다.  

#### 검색

#### 기타 사항

템플릿에서 CSS와 자바스크립트를 어떻게 관리할 수 있을까?


## 9.6 예약된 알림

주기적인 알림은 임시 알림과 경쟁할 수 있다.  
둘 다 속도 제한기에 제한될 수 있기 때문이다.  
속도 제한 이벤트가 빈번할 때 트리거되는 경보를 추가해야 한다.  
이 정보를 바탕으로 클러스터 크기를 확장하거나, 외부 알림 서비스에 더 많은 예산을 할당하거나, 특정 사용자의 과도한 알림을 요청하거나 제한할 수 있다.  


## 9.7 알림 수신자 그룹

알림 수신자 그룹을 처리하기 위해 주소 그룹 서비스를 설계할 수 있다.  

코레오그래피 사가 패턴을 사용해 이러한 주소를 GET하고 알림 이벤트를 생성할 수 있다.  

주소 그룹 가져오기가 주소를 가져오는 동안 새 사용자가 새 주소 그룹에 추가되면 어떻게 되는가?
알림이 트리거된 시점에서 주소 그룹 내에 있던 수신자에게만 알림을 전달해야 한다.  


## 9.8 구독 취소 요청

구독 취소는 서버 사이드에서 구현하거나 양쪽 모두에서 구현해야 한다.  
클라이언트 사이드에서만 구현하면 안 된다.  


## 9.9 실패한 전달 처리

- 네트워크 문제
- 수신자의 기기 OFF
- 타사 전달 서비스 이용 불가
- 앱을 제거하거나 계정 삭제
- 수신자의 알림 차단

알림 이벤트에 재시도 횟수를 추가하거나, 데드 레터 큐 역할을 하는 카프카 토픽에 이 알림을 생성한다.  

타사 전달 서비스를 사용할 수 없는 경우 채널 서비스는 높은 긴급도의 경보를 트리거하고, 지수 백오프를 적용하며, 동일한 이벤트에 대해 재시도해야 한다.  


## 9.10 중복 알림에 관한 클라이언트 사이드 고려사항

수신자 기기로 직접 알림을 보내는 채널 서비스는 푸시와 풀 요청을 모두 허용해야 한다.  
알림이 생성되면 채널 서비스는 즉시 수신자에게 푸시해야 한다.  
기기가 온라인 상태가 되면 알림 서비스에서 알림을 풀 해야 한다.  

클라이언트가 요청을 반복해야 할 정당한 이유가 있을 수 있으므로 속도 제한 외에는 동일한 알림에 대한 요청을 거부해서는 안 된다.  
클라이언트는 사용자에게 이미 표시된 알림을 기록해야 하며, 브라우저 로컬스토리지나 모바일 기기의 SQLite 데이터베이스에 저장할 수 있다.  


## 9.11 우선순위

알림은 다른 우선순위 수준을 가질 수 있다.  

- 높은 우선순위 처리 후 낮은 우선 순위 처리
- 가중치 무작위 선택을 사용해 처리


## 9.12 검색

match-sorter와 같은 프런트엔드 검색 라이브러리


## 9.13 모니터링과 경보

사용자는 알림 상태를 추적할 수 있어야 한다.  
다양한 통계 모니터링 대시보드를 만들 수 있다.  
주기적인 감사를 통해 감지되지 않는 오류를 탐지할 수 있다.  


## 9.14 알림/경보 서비스의 가용성 모니터링과 경보

알림 서비스가 모니터링하는 서비스와 동일한 인프라와 서비스를 공유하므로 가동 시간 모니터링에 사용해서는 안 된다.  

이러한 외부 기기에 설치할 수 있는 클라이언트 데몬을 제공할 수 있다.  
서비스는 이러한 외부 기기에 주기적으로 하트비트를 보내며, 기기는 이러한 하트비트를 예상하게 구성된다.  


## 9.15 기타 논의 가능한 주제

- 카프카 클러스터의 메모리 양을 조정할 수 있다.
- 공유 서비스의 자동 확장을 고려할 수 있지만, 자동 확장 솔루션을 사용하는 것은 까다롭다.  
- 이미 많은 사용자에게 보낸 알림을 수정해야 하는 상황을 어떻게 해결할 수 있을까?


## 9.16 최종 참고사항







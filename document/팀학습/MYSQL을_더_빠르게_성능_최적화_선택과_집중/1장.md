# 1장 쿼리 응답 시간

성능은 곧 쿼리 응답 시간입니다.  
쿼리 응답 시간은 MySQL이 쿼리를 실행하는 데 소요되는 시간입니다.


## 1-1 거짓 성능에 관한 실화

당시에는 MySQL에 관한 책이나 블로그, 도구가 거의 없었습니다.  
결과적으로 MySQL 성능 문제를 해결하기 위한 최신 기술은 고객에게 더 많은 램을 판매하는 것뿐이었습니다.  

저는 중요한 인덱스가 없는 단일 쿼리를 발견했고 쿼리를 제대로 인덱싱하자 성능이 획기적으로 향상되며 웹 사이트가 살아났습니다.  

> 비슷한 경험이 있음  
> 배치에서 성능이 안나와서 전체 프로세스를 다시 구성했는데, 이후에 알고보니 인덱스가 안걸려 있어서 성능이 안나왔다는 점  


## 1-2 핵심 지표(North Star)

### 의미있는 것

쿼리 응답 시간은 누구나 진정으로 관심을 가지는 유일한 메트릭입니다.  

### 실행 가능한 것

결국 여러분은 MySQL 성능에서 핵심 지표인 쿼리 응답 시간 향상에 집중해야 합니다.  
하드웨어 문제로 돌리면 안 됩니다.  
MySQL이 시작되면 먼저 쿼리 메트릭으로 MySQL이 수행하는 작업을 확인한 다음 느린 쿼리를 분석하고 최적화하여 응답 시간을 단축해야 합니다.  

> DBA가 슬로우 쿼리를 체크하고, 개발자에게 개선하도록 요구하는 중  
> 담당하고 있는 정산, 대사 시스템이 10초내에 처리하는 것을 목표로 하는 중 (피트니스 함수)  
> 대량 데이터 인서트 / 조회를 Jpa에서 Exposed로 구현  


## 1-3 쿼리 보고

쿼리 메트릭은 응답 시간, 잠금 시간, 조회된 행 등 쿼리 실행에 관하여 중요한 통찰력을 제공합니다.  

### 소스

쿼리 메트릭은 **슬로 쿼리 로그**나 **성능 스키마**에서 비롯됩니다.  
슬로 쿼리 로그는 디스크에 있는 로그 파일이고, 성능 스키마는 performance_schema와 같은 이름의 데이터베이스입니다.  
둘 다 쿼리 메트릭을 제공합니다.  
주요 차이점은 얼마나 많은 메트릭을 제공하는지입니다.  
둘 다 쿼리 응답 시간을 제외하고 3~20개 이상의 메트릭을 제공합니다.  

- 슬로 쿼리
  - 로그 파일
  - 기본으로 비활성화
  - MySQL 재부팅 없이 활성화 가능
- 성능 스키마
  - performance_schema와 같은 이름의 데이터베이스
  - 기본으로 활성화지만, 일부 클라우드에서는 비활성화
  - MySQL을 재부팅해야 활성화 가능

### 집계

몇몇 쿼리 메트릭 도구는 사용자 이름, 호스트 이름, 데이터베이스 등으로 그룹화할 수 있습니다.  

```
쿼리를 SHA-256 해시로 변환하여 고유하게 식별 가능
SQL문: SELECT col FROM tbl WHERE id = 1
다이제스트 텍스트: SELECT `col` FROM `tbl` WHERE `id` = ?
다이제스트 해시 (SHA-256): f49d50dfab1.....
```
`EXPLAIN` 명령어를 사용하면 쿼리 실행을 이해하는데 필요한 메타데이터를 생성할 수 있으므로 쿼리 분석에 샘플이 필요합니다.  
일부 쿼리 메트릭 도구는 샘플을 EXPLAIN한 다음 폐기하고 EXPLAIN 계획(결과)를 보고합니다.  

```  
SELECT name FROM captains WHERE last_name = 'Picard'
SELECT name FROM captains WHERE last_name = 'Picard' AND first_name = 'Jean-Luc'
```
두 쿼리는 결과가 같을 수 있으나, 서로 다른 다이제스트로 정규화되므로 보고 측면에서는 서로 다른 쿼리입니다.  
특히 `WHERE`절은 쿼리 실행과 최적화에 영향을 미치므로 별도로 이 쿼리들을 보고하는 것이 기술적으로 옳습니다.  

```  
SELECT name FROM star_ships WHERE class IN ('galaxy')
SELECT name FROM star_ships WHERE class IN ('galaxy', 'intrepid)

SELECT name FROM star_ships WHERE class IN (...)
```
쿼리 정규화에서 한 가지 알아야 할 점은 값이 제거되므로 다음 두 쿼리는 같은 다이제스트로 정규화된다는 사실입니다.  

> 어플리케이션 로그에 찍히는 쿼리문이 다이제스트 텍스트인 듯

### 보고

또한 각 쿼리에는 샘플, EXPLAIN 계획, 테이블 구조 등의 메타데이터가 있습니다.  
거의 모든 쿼리 메트릭 도구는 쿼리 프로파일과 쿼리 보고서라는 2가지 수준의 계층 구조로 데이터를 제공합니다.  

#### 쿼리 프로파일

쿼리 프로파일에 느린 쿼리가 표시됩니다.  
쿼리 시간을 기준으로 쿼리를 정렬하면 가장 느리고 시간이 오래 걸리는 쿼리부터 확인할 수 있습니다.  

#### 쿼리 총시간

쿼리 총시간은 실행 시간의 총합입니다.  
응답시간 1초에 10번 실행되는 쿼리 A와 응답시간 0.1초에 1,000번 실행되는 쿼리 B가 있을 경우 쿼리 총시간은 B가 더 크기 때문에 B를 최적화시켜야 한다.  

#### 실행 시간 비율

실행 시간 비율은 쿼리 총시간을 실행 총시간으로 나눈 값이다.  
321ms 쿼리 C와 100ms 쿼리 D가 있을 때 쿼리 C의 비중은 76.2%이므로 가장 느린 쿼리는 C이다.  

#### 쿼리 부하

쿼리 부하는 쿼리 총시간을 클럭 타임으로 나눈 것으로, 클럭 타임은 시간 범위에 대한 전체 초 수입니다.  
부하는 시간과 관련이 있지만 동시에 실행되는 쿼리의 다중 인스턴스와 같은 동시성을 미묘하게 나타내기도 합니다.  
쿼리 부하가 평균적으로 1.0보다 작으면 쿼리가 동시에 실행되지 않습니다.  
쿼리 부하가 1.0보다 크면 쿼리 동시성을 나타냅니다.  
예를 들어, 쿼리 부하가 3.5라는 것은 "언제든지 조회하면 실행 중인 쿼리의 인스턴스가 3.5개 정도 있다"라는 의미입니다.  
쿼리 부하가 높을수록 쿼리가 동일하거나 가까운 행에 접근할 때 경합할 가능성이 커집니다.  


### 쿼리 보고서

쿼리 보고서는 하나의 쿼리에 대해 알아야 할 모든 것을 보여줍니다.  
일반적으로 쿼리 프로파일에서의 느린 쿼리를 선택하는 것으로 시작합니다.  
쿼리 보고서는 쿼리 분석에 사용되는 많은 정보로 구성되어 있습니다.  

만약 사용하는 쿼리 메트릭 도구가 쿼리 메트릭만 보고한다면 최소한 EXPLAIN 계획과 테이블 구조를 수동으로 수집하는 것부터 시작해야 합니다.  


## 1-4 쿼리 분석

쿼리 분석의 목표는 느린 응답 시간을 해결하려는 것이 아니라 '쿼리 실행'을 이해하려는 것입니다.  
느린 응답 시간을 해결하는 행위는 쿼리 분석 후 쿼리 최적화 과정에서 이루어집니다.  

모든 메트릭과 메타데이터를 주의 깊게 검토하여 전체 상황을 파악한 다음, 응답 시간을 개선하기 위한 목표로 쿼리 최적화에 집중해야 합니다.  

### 쿼리 메트릭

쿼리 메트릭은 소스와 MySQL 배포 및 버전에 따라 다릅니다.  
여기서 설명하는 9가지 메트릭은 어떤 쿼리 분석에서든 상당히 중요합니다.  

#### 쿼리 시간

쿼리 시간은 알고 있듯이 가장 중요한 메트릭입니다.  
쿼리 시간에는 또 다른 메트릭인 잠금 시간(lock time)이 포함된다는 사실입니다.  

성능 스키마를 사용하면 전부는 아니지만 쿼리 실행의 많은 부분을 알 수 있습니다.  
성능 스키마로 수집되는 이벤트를 "시간이 소요되는 측정 정보를 수집할 수 있도록 구비된, 서버가 수행하는 모든 작업"으로 정의하며, 방대한 수의 이벤트를 계측하며 다음과 같은 계층 구조로 구성됩니다.  

```
트랜잭션  
  ㄴ 명령문
      ㄴ 단계
          ㄴ 대기 
```

모든 쿼리가 트랜잭션 안에서 수행되므로 '트랜잭션'은 최상위 이벤트입니다.  
'명령문'은 쿼리 메트릭이 적용되는 쿼리입니다.  
'단계'는 명령문 실행 과정 내의 단계로 명령문 구문 분석, 테이블 열기, 파일 정렬 수행과 같은 과정을 포함합니다.  
'대기'는 시간이 걸리는 이벤트입니다.  

`UPDATE`문은 15단계로 실행됩니다.  
실제 `UPDATE`문은 8단계(`stage/sql/updating`)에서 실행됩니다.  

그러나 우리는 이 책에서 효율성을 추구하므로 성능 스키마에 너무 집착할 필요는 없습니다.  
쿼리 시간이면 충분합니다.  

#### 잠금 시간

잠금 시간은 쿼리를 실행하는 동안 잠금을 획득하여 사용한 시간입니다.  
이상적으로 잠금 시간은 쿼리 시간의 극히 일부이어야 하지만, 값은 상대적입니다.  

MySQL은 대기가 아니라 작업에 대부분의 시간을 사용해야 하므로 잠금 시간이 쿼리 시간의 50% 이상이면 문제라고 할 수 있습니다.  
이론적으로 완벽한 쿼리 실행은 대기 시간이 0이지만, 시스템에 내재된 공유 리소스, 동시성, 지연 시간으로 인해 불가능합니다.  

MySQL 기본 스토리 엔진은 InnoDB입니다.  
InnoDB 스토리지 엔진에서 잠금에는 테이블 락과 로우 락이 있습니다.  
MyISAM은 로우 레벨 락을 지원하지 않으므로 테이블 락으로 데이터 접근을 관리합니다.  
InnoDB는 로우 레벨 락을 지원하므로 로우 락으로 데이터 접근을 관리합니다.  

서버에서 관리하는 메타데이터 락이 있는데 스키마, 테이블, 저장 프로그램 등의 접근을 제어합니다.  
테이블 락과 로우 락은 테이블 데이터에 대한 접근을 제어하지만, 메타데이터 락은 테이블 구조에 대한 접근을 제어하여 쿼리가 테이블에 접근하는 동안 변경되는 것을 방지합니다.  
모든 쿼리는 접근하는 모든 테이블을 대상으로 메타데이터 락을 획득합니다.  
메타 데이터 락은 쿼리가 아니라 트랜잭션이 끝날 때 해제됩니다.  

테이블의 데이터를 변경하거나 작성하기 전에 행을 잠가야 하므로 잠근은 주로 쓰기에 사용됩니다.  
로우 락을 획득하는 데 필요한 시간은 동시성에 따라 다릅니다.  
즉, 얼마나 많은 쿼리가 같은 행에 동시에 접근하는지에 따라 다릅니다.  
매우 자주 접근하는 행이라면 잠금 시간이 응답 시간에서 상당 부분을 차지할 수 있습니다.  

읽기에는 비잠금 읽기와 잠금 읽기가 있습니다.  
- 비잠금 읽기: SELECT
- 잠금 읽기: SELECT FOR UPDATE / SELECT FOR SHARE

다음 SQL 문에서 SELECT는 테이블 S의 공유 로우 락을 획득합니다.  
```
- INSERT ... SELECT FROM s
- REPLACE ... SELECT FROM s
- UPDATE ... SELECT FROM s
```
엄밀히 말해서 이러한 SQL 문은 읽기가 아니라 쓰기지만, 선택적 SELECT는 테이블 S의 공유 로우 락을 획득합니다.  

잠금 읽기, 특히 SELECT FOR UPDATE는 확장이 어렵고 문제를 일으키는 경향이 있으며, 일반적으로 같은 결과를 얻을 수 있는 비잠금 해결책이 있기 때문에 피해야 합니다.  
SELECT FOR SHARE는 동일한(또는 근처) 행에 대한 쓰기를 차단합니다.  

비잠금 읽기는 로우 락을 획득하지 못하더라도 메타데이터 락과 테이블 락을 획득하므로 잠금 시간은 0이 아닙니다.  
비잠금 읽기는 비차단을 의미하지 않습니다.  
SELECT 쿼리는 접근하는 모든 테이블에서 공유 메타데이터 락을 획득해야 합니다.  
공유 메타데이터 락은 다른 공유 메타데이터 락과 호환되지만 하나의 베타 메타데이터 락은 다른 모든 메타데이터 락을 차단합니다.  




# CHAPTER 5 진화하는 아키텍처 토폴로지

진화적 아키텍처는 커플링의 적정 수준에 주목한다.  
커플링을 맺을 아키텍처를 식별하고 최소한의 오버헤드와 비용을 들여 최대한의 이득을 볼 수 있어야 한다.  


## 5.1 진화 가능한 아키텍처 구조


### 5.1.1 동조성

한 컴포넌트를 변경했을 때 시스템의 전반적인 정확성을 유지하기 위해 다른 컴포넌트를 수정해야 한다면 두 컴포넌트는 동조적이다.  

본질적으로 동조성은 커플링을 세련되게 묘사한 언어일 뿐이지만 기술 리더와 개발자에게 커플링의 개념을 설명하기에는 더 좋은 언어다.  


#### 정적 동조성

정적 동조성은 소스 코드 수준에서 발생  
정적 동조성은 구조 설계에 정의된 구심 및 원심 커플링을 세분화한 개념이다.  
아키텍트는 구심 또는 원심 커플링의 결합 정도에 따라 다음과 같이 정적 동조성을 구분한다.  

- 명칭 동조성: 복수의 컴포넌트가 특정 엔티티명에 동의한다.  
- 타입 동조성: 복수의 컴포넌트가 특정 엔티티 타입에 동의한다.  
- 의미 동조성, 관례 동조성: 복수의 컴포넌트가 특정 값의 의미에 동의한다. int TRUE = 1, FALSE = 0
- 위치 동조성: 복수의 컴포넌트가 특정 값의 순서에 동의한다. 메소드나 함수를 호출하는 파라미터 값과 관련이 있다.  
- 알고리즘 동조성: 복수의 컴포넌트가 특정 알고리즘에 동의한다. 서버와 클라이언트 양쪽에 정의하는 해싱 알고리즘이다.


#### 동적 동조성

동적 동조성은 런타임 시점에 호출을 분석해서 확인한다.  

- 실행 동조성: 실행 순서가 복수의 컴포넌트에 영향을 미친다.
- 시점 동조성: 실행 시점이 복수의 컴포넌트에 영향을 미친다. 동시에 실행되는 두 개의 스레드가 유발하는 경합 조건이다.  
- 값 동조성: 서로 관련된 여러 값이 함께 변경되어야 하는 경우 발생하는 동조성이다. DB가 분리된 상황에서 모든 DB에 값을 동일하게 유지해야한다.  
- 식별 동조성: 복수의 컴포넌트가 동일한 엔티티를 참조한다. 분산 대기열처럼 공용으로 쓰이는 데이터 구조를 변경하면 대기열을 공유하는 컴포넌트가 모두 영향을 받는다.


#### 동조성 속성

동조성은 아키텍트와 개발자에게 유용한 분석 도구이며 동조성의 일부 속성은 개발자의 현명한 조언자 역할을 한다.  


##### 강도

아키텍트와 개발자는 더 나은 동조성 유형을 향해 리팩터링을 반복하며 코드베이스의 커플링 특성을 개선해야 한다.  
개발자는 소스 코드를 분석해 간단히 정적 동조성을 검사할 수 있으며 최신 개발 도구로 손쉽게 개선할 수 있기 때문이다.  
개발자는 소스 코드에서 의미만 있고 이름이 없는 마법의 값을 찾아 명명된 상수 타입으로 고칠 수 있다.  
의미 동조성을 명칭 동조성으로 리팩터링하는 사례다.  


##### 지역성

동조성의 지역성은 코드베이스 내부 모듈의 인접도를 나타낸다.  
하나의 모듈 안에서 서로 인접한 코드는 별도 모듈 또는 코드베이스로 떨어져 있는 코드보다 더 높은 동조성을 형성한다.  
동조성의 강도가 같다 해도 하나의 모듈에서 형성되는 것이 서로 다른 모듈에 나뉘어 있는 것보다 낫다.  

> 지난 카뱅 면접에서 AOP를 주제로 얘기했었음  
> 도메인 이벤트를 서비스 클래스에서 직접 발행할 것인가?  
> AOP를 사용해서 서비스 클래스에서 숨길 것인가?  
> 
> 서비스 클래스와 도메인 이벤트는 강한 커플링을 갖고 있음  
> 서비스 클래스에서 도메인 이벤트를 발행하게 되면 도메인 로직에 집중하기 어려울 것이고, AOP로 풀어야한다는 관점이 있음 https://supawer0728.github.io/2018/03/24/spring-event/  
> AOP로 풀게되면 서비스 클래스에 들어나지 않기 때문에 알 수가 없음  
> 
> 커플링에 대해 어떤 입장을 취할 것인가?  
> 책에서 소개한 지역성을 고려하면 서비스 클래스에서 직접 발행하는게 맞는 듯  


##### 정도

동조성의 정도는 파급력과 관련이 있다.  
동조성의 정도가 낮을수록 동조성이 코드베이스에 가하는 손상의 정도도 낮다.  
코드베이스는 점점 덩치가 커지곤 한다.  
처음에는 사소했던 문제도 그에 따라 심각해지기 마련이다.  

페이지 존스의 3가지 지침  
- 시스템을 세부 요소로 쪼개고 각각을 캡슐화시켜 전체적인 동조성을 최소화한다.
- 캡슐화의 경계를 벗어나는 나머지 모든 동조성을 최소화한다.
- 캡슐화 경계 내부에서 동조성을 최대화한다.

짐 웨이리치의 2가지 조언
- 정도의 원칙: 강도 높은 동조성을 약한 동조성으로 변환하라
- 지역성의 원칙: 소프트웨어 요소 사이의 거리가 멀수록 약한 동조성을 사용하라


### 5.1.2 경계 콘텍스트와 동조성 교차

DDD에서 정의하는 경계 콘텍스트는 도메인 내부의 모든 요소에 투명하게 열려 있지만 다른 경계 콘텍스트에는 불투명하게 닫혀 있는 존대다.  
따라서 Customer 클래스를 공용으로 생성하고 전체 조직에서 동시에 사용하는 방식은 DDD에 맞지 않는다.  

DDD를 기반으로 시스템을 설계하는 아키텍트는 시스템의 세부 구현 정보가 경계 콘텍스트 외부로 유출되지 않도록 차단해야 한다.  

연약한 아키텍처는 한 지점의 사소한 변화가 국지적인 경계를 넘어 예측할 수 없는 파손을 일으킨다.  

이 정보를 다른 애플리케이션에 노출한다는 것은 단일 애플리케이션의 데이터베이스 변경 사항이 의도치 않게 다른 애플리케이션을 중단시킬지도 모른다는 의미다.  

> 도메인 객체와 DB 테이블 구조와 다른 개념, 각자 클래스로 관리하는 것에 동의  
> 테이블의 변경이 애플리케이션 코드에 영향이 크게 미치는 경험을 했었음  
> 하지만 도메인 객체와 DB 테이블 구조는 거의 동일하게 따라가는 듯  


## 5.2 아키텍처 퀀텀 및 세분성

시스템의 각 부분을 의미적으로 결합해 기능적 응집도로 형성하는 비즈니스 개념도 많다.  

> 개별 함수지만 의미적으로 결합하기 위해 코틀린의 .also를 사용하는 편  
>
> approve() // 결제 승인  
> publishEvent() // 결제 승인 이벤트 발행  
> ---
> // 결제 승인 처리 후 이벤트를 발행하도록 묶어줌  
> approve()  
>   .also { publishEvent() }  

아키텍처 퀌텀이란 높은 기능 응집도를 갖추었으며 독립적으로 배포 가능한 컴포넌트를 가리킨다.  
시스템이 제대로 작동하기 위해 필요한 모든 구조적 요소가 아키텍처 퀀텀에 속한다.  

#### 정적 커플링

OS, 프레임워크 라이브러리, DB


#### 동적 커플링

API, Kafka를 통해 통신을 주고 받는 방식  

정적 커플링은 서비스가 서로 엮이는 방식을 묘사하며, 동적 커플링은 서비스가 런타임에 서로를 호출하는 방식을 묘사한다.  


#### 아키텍처 퀀텀

독립적으로 배포 가능한 아티팩트이며 고기능적 응집도, 강한 정적 크플링, 동적 커플링 동기화 등의 특성을 지닌다.  
워크플로 내부에 잘 배치된 마이크로서비스는 그 자체로 아키텍처 퀀텀이라 할 수 있다.  


### 5.2.1 독립 배포

퀀텀은 특정 아키텍처 내부의 독립 배포 단위이다.  
모놀리틱 아키텍처: 단일 아키텍처 퀀텀
분산 아키텍처(마이크로서비스): 커플링의 종류에 따라 차이는 있지만, 아키텍처 퀀텀이다.  

배포 자산 각각을 아키텍처 퀀텀으로 표현하면 몇 가지 유용한 효과가 생긴다.
1. 각 주체가 취급하는 문제들이 공통 언어로 표현되므로 아키텍트는 커플링 특성을, 개발자는 작동의 영역을, 운영은 배포 특성을 이해할 수 있다.  
2. 분산 아키텍처에서 서비스의 세분성을 결정할 때 아키텍트가 고려해야 할 힘이 드러난다.  
3. 독립 배포 가능성을 갖추려면 데이터베이스처럼 공통적인 커플링 지점이 아키텍처 퀀텀 내부에 포함되어야 한다.  

> 멀티모듈로 구성된 단일(모놀리틱) API 애플리케이션인 경우, 아키텍트와 개발자는 개별 모듈이 아닌 배포 단위(API 애플리케이션)으로 소통해야한다는 것으로 이해함  
> 반대로, 단일 모듈이지만 API 애플리케이션과 컨슈머 애플리케이션이 존재하는 경우, 모듈명보다 API, 컨슈머 애플리케이션으로 각각 소통해야한다는 것으로 이해함  


### 5.2.2 고기능 응집도

고기능 응집도는 클래스, 컴포넌트, 서비스 등의 구조적 근접도를 나타낸다.  

거의 대부분의 모놀리식 아키텍처는 단순히 전체 시스템의 기능을 포함하고 있을 뿐 기능의 응집도가 높지는 않다.  

이상적인 마이크로서비스 아키텍처에서 각 서비스는 단일 도메인 또는 워크플로를 모델링하므로 기능 응집도가 높다.  

> 모놀리식 아키텍처에서는 모든 작업자가 모든 데이터(DB, 테이블)에 접근할 수 있고, 작업자 별로 책임이 불분명하여 기능의 응집도가 낮은 것 같음  
> 내가 개발한 내용을 다른 분이 동일하게 작업하는 경우가 있었음  
> 
> 그러나 Gray Zone은 언제나 존재할 수 있으므로 마이크로서비스에서도 아름답게 분류되진 않고, 응집도를 떨어트리는 요소는 존재하는 듯    


### 5.2.3 강한 정적 커플링

강한 정적 커플링은 아키텍처 퀀텀의 내부 요소가 서로 긴밀하게 엮여 있음을 의미한다.  
서비스 간 계약(IP 주소, URL 등)은 강한 정적 커플링을 생성한다.  

단일 단위로 배포하고 단일 데이터베이스를 사용하는 모든 아키텍처는 항상 단일 퀀텀을 갖게 된다.  

> 애플리케이션 특성(API, 컨슈머)에 따라 항상 단일 퀀텀일 수는 없다고 생각 함  
> ex) 단일 정산 DB에 정산 API와 정산 컨슈머 애플리케이션이 각각 존재하는 경우, 단일 DB이지만 배포 단위(퀀텀)는 2개 이상일 수 있음  

중재자 이벤트 기반 아키텍처 스타일은 단일 아키텍처 퀀텀으로 평가 된다.  

> 5.2.1 절에는 퀀텀은 특정 아키텍처 내부의 독립 배포 단위라고 했는데? 반대되는 얘기가 아닌지?  
> 그림 5-3의 각 서비스들은 독립 배포 단위가 아닌건지?  

이벤트 기반 아키텍처의 서비스가 데이터베이스를 쓰지 않는다 해도 그 서비스가 데이터베이스를 쓰는 다른 서비스에 의존한다면, 이들은 모두 아키텍처 퀀텀을 이루는 정적 커플링의 일부가 된다.  

마이크로서비스 아키텍처를 설계할 때는 가능한 한 높은 수준으로 서비스를 분리하고 가급적 커플링 지점을 만들지 않도록 주의해야 한다.  

사용자 인터페이스와 밀접하게 결합된 마이크로서비스 아키텍처는 단일 아키텍처 퀀텀을 형성하기도 한다.  
사용자 인터페이스는 프론트엔드와 백엔드 사이에 커플링 지점을 만든다.  

아키텍트는 프런트엔드와 백엔드 사이의 커플링을 생성하지 않는 비동기 방식으로 사용자 인터페이스를 설계한다.  
마이크로프런트엔드 프레임워크를 적용하는 것이 최근 추세다.  

> 과거에는 페이지별 API가 있었고 해당 API가 죽으면 페이지 로딩에 실패함  
> 최근에는 페이지 섹션별로 API를 호출하고, 특정 API가 죽어도 전체 페이지 로딩에는 실패하지 않는 방식으로 이해함  

아키텍처의 모든 커플링 지점은 퀀텀적 관점에서 정적 커플링 지점이 될 가능성이 있다.  

> 특정 요소의 변경에 직접적인 영향을 받으면 정적 퀀텀으로 봐야 하는건지?  


### 5.2.4 동적 퀀텀 커플링

서비스가 서로를 호출하는 방식이 다양할수록 트레이드오프를 판단하는 어려움이 가중된다.  

#### 통신

동기 통신: Http, gRPC  
비동기 통신: Kafka, MQ  

통신 방식은 동기화, 에러 처리, 트랜잭션, 확장성, 성능 등에 영향을 미친다.  


#### 일관성

통신 호출을 주고받으며 준수해야 할 트랜잭션 무결성의 엄격함을 의미한다.  
원자 트랜잭션(all or nothing)과 최종 일관성이 있다.  

> Saga 패턴  
> Spring-boot apache camel https://camel.apache.org/camel-spring-boot/4.0.x/spring-boot.html  
> 보상 트랜잭션을 카프카, MQ로 발행  
 

#### 조정

조정은 통신을 따라 모델링된 워크플로에 얼마나 많은 조정이 필요한지를 나타낸다.  

##### 오케스트레이션
오케스트레이터 역할의 애플리케이션이 여러 서비스를 호출하면서 트랜잭션을 관리  
트랜잭션성을 달성하기 쉬움  

##### 코레오그래피
각 서비스끼리 이벤트로 통신하여 트랜잭션을 관리  
확장성이 높음  

> https://devyonghee.github.io/theory/2022/09/24/orchestration-vs-choreography/


## 5.3 계약

계약이란 아키텍처를 이루는 각 부분이 서로 연결되는 방식을 포괄적으로 의미한다.  

> SOAP, REST, gRPC, XML-RPC, Kafka, MQ

아키텍처의 일부에서 정보 또는 의존성을 전달하는 용도로 쓰이는 일정한 양식  
프레임워크 및 라이브러리의 전이 의존성, 내부 및 외부 통합 지점, 캐시, 통신 등  

RPC (Remote Procedure Call) 원격 프로시저 호출  

많은 아키텍트가 엄격한 계약을 선호하는 이유는 이러한 계약이 내부 메서드 호출 동작을 의미론적으로 모델링하기 때문이다.  
그러나 엄격한 계약은 통합 아키텍처의 취약점으로 발전할 위험이 있으므로 가급적 피하는 것이 좋다.  

계약이 자주 변경될 수록 더 많은 문제가 다른 서비스로 전파된다.  

REST의 경우 아키텍트는 메서드 또는 프로시저의 엔드포인트가 아닌 리소스를 모델링하는 방식으로 계약의 취약성을 낮춘다.  
나중에 엔진의 세부 정보가 리소스에 추가된다 해도 조회 쿼리는 여전히 잘 작동할 것이다.  

Wishlist 계약에 처음부터 모든 정보를 포함시킨다면, 스탬프 커플링이라는 흔한 안티패턴의 함정에 빠지는 길이다.  

느슨한 계약을 활용하면 극도로 분리된 마이크로서비스 아키텍처 시스템을 구축할 수 있다.  
그러나 느슨한 계약은 확신과 검증의 부재, 애플리케이션 로직 증가 등의 트레이드오프를 동반한다.  

> 카프카 메세지 컨슈머에 @JsonIgnoreProperties(ignoreUnknown = true)를 선언하는 편  
> 메세지 퍼블리셔와 컨슈머의 계약을 느슨하게 하기 위함  


### 5.3.1 진화적 마이크로서비스 아키텍처

마이크로서비스 아키텍처에서 경계 콘텍스트는 퀀텀 경계 역할을 겸하며 데이터베이스 서버, 검색 엔진, 보고서 기능 등의 의존 컴포넌트를 포함한다.  

개발자들은 자신들의 컴포넌트가 실제 세계에서 어떻게 서로 맞물리는지 주의 깊게 지켜봐야 한다.  
아키텍트는 명시적으로 퀀텀의 크기를 정의해야 한다.  

계층 아키텍처는 애플리케이션의 기술적 차원과 작동 원리에 초점을 맞춘다.  
기술 계층으로 나뉘어진 아키텍처에서 결제 같은 도메인 개념은 아키텍처의 여러 계층에 걸쳐 존재하게 된다.  

> 그림 5-15는 전체 시스템의 아키텍처를 의미하는 것인가?  
> 아니면 애플리케이션의 코드(패키지)를 의미하는 것인가?  

> 그림 5-16은 이론적인 그림이고, 현실 세계와 괴리가 있다고 생각 함  

마이크로서비스 아키텍처는 일반적으로 다음과 같은 7가지 원칙을 따른다.  

1. 비즈니스 도메인 중심 모델링  
마이크로서비스의 목표는 단순히 작은 서비스를 만드는 것이 아니라 쓸모 있는 경계 콘텍스트를 만드는 것이다.  

> 도메인과 경계 콘텍스트는 정답이 없기 때문에 팀원들과 계속 얘기가 필요함  
> 그렇지 않으면 애플리케이션의 목적이 엉뚱한 곳으로 갈 수 있음  

2. 세부 구현 은닉  
서비스는 데이터베이스 스키마 등의 상세한 내부 정보를 노출할 필요 없이 메시지 또는 리소스를 주고받으며 서로 통합한다.  

3. 자동화 문화  
테스트 자동화는 환경의 변화가 급격할수록 유용하다.  

4. 고도의 분산성  
일반적으로 결합보다 중복을 선호한다.  
이름이 같고 속성이 비슷한 개념이 두 곳에 있으므로 개발자는 이를 하나로 만들어 두 서비스에서 재사용하고 시간과 노력을 절약하려 한다.  
그러나 이렇게 하면 공유 컴포넌트를 사용하는 모든 팀에 변경 사항이 전파되어야 하므로 오히려 노력이 더 들게 된다.  

> 중복을 선호하는 것에 동의함  
> 주문의 '금액'과 결제, 환불의 '금액'은 숫자 타입의 동일한 값(성격)으로 보이지만, 성질은 다르기 때문에 분리해야 한다고 생각 함  
> 전통적인 DB 관점의 개발과 상반되는 내용  

5. 배포 독립성  

> 마이크로서비스의 최고 장점이라고 생각함  

6. 장애 격리
서킷 브레이커 패턴, 벌크헤드 패턴 등 데브옵스의 우수한 많은 관행이 이러한 아키텍처 환경에서 등장한다.  

7. 높은 관찰 가능성  
운영팀이 모니터링하지 못하는 서비스가 있다면 그 서비스는 사실상 존재하지 않는 것이나 마찬가지다.  

서비스를 변경하는 개발자는 서비스 통합 지점을 통해 이전과 동일한 정보를 전달해야 한다.  
이를 소비자 주도 계약 등의 피트니스 함수로 보호하면 더욱 좋다.  

##### 점진적 변화  

각 서비스는 도메인 개념에 맞추어 경계 콘텍스트를 형성하므로 변경 사항의 영향 범위가 해당 콘텍스트로 한정된다.  
마이크로서비스 아키텍처는 자동화된 지속적 전달 기술에 크게 의존하므로 배포 파이프라인과 현대적인 데브옵스 관행이 뒷받침되어야 한다.  

##### 피트니스 함수를 이용한 변화 유도

마이크로서비스 개발 기술이 발전함에 따라 정교한 테스트 기술들이 함께 성장했다.

지속적 전달과 데브옵스 기술, 다중 테스트 환경, 오픈 소스 확대 등이 마이크로서비스를 성장 시킴  
도메인에 더욱 집중된 아키텍처 스타일을 구축할 수 있게 됨  


## 5.4 재사용 패턴

개발자는 재사용 가능한 모듈을 만들기 위해 많은 시간을 들이지만 결과물의 실질적인 재사용성은 그리 높지 않은 경우가 많다.  

일반적으로 서비스 지향 아키텍처 (SOA)는 공통점을 찾아 최대한 재사용하는 것을 권장한다.  
하지만, 커플링이 발생함  

개발자들이 코드의 재사용성을 높이기 위해 노력할수록 사용성은 낮아진다.  
재사용 가능한 코드를 작성하는 개발자는 최종적으로 그 코드를 사용하게 될 다른 개발자들을 고려해야 한다.  

> 작은 헬퍼급 함수아니면 재사용은 고려하지 않는 편  
> 언제든지 서비스는 확장되거나 변경될 수 있음  

마이크로서비스는 코드 재사용을 자제하며 커플링보다 중복을 선호하는 철학을 따른다.  
마이크로서비스의 진정한 목표는 중복 코드를 늘리는 것이 아니라 도메인 내부의 엔티티들을 서로 격리하는 것이다.  
아키텍트는 중복도가 높아지는 단점을 이해하면서도 지나친 커플링을 유발하는 아키텍처 손상과 그로 인한 국지적 피해를 계산한 다음 양쪽을 상쇄시킨다.  

> 중복 코드를 일정 허용하면 소나큐브 지옥에 빠짐  


### 5.4.1 효과적인 재사용 = 추상화 + 낮은 변동성

오늘날 많은 아키텍트가 직면한 공통의 과제는 완전한 재사용과 경계 콘텍스트 분리라는 두 기업 목표를 조율하는 것이다.  


### 5.4.2 사이드카 및 서비스 메시: 직교 운영 커플링

마이크로서비스 아키텍처의 설계 목표 중 하나는 높은 수준의 분리도다.  
이 목표는 종종 '중복이 결합보다 낫다'는 금언으로 표현되곤 한다.  

모니터링, 로깅, 인증, 권한 관리, 서킷 브레이커 등은 커플링을 이용하는 편이 이득인 운영 기능들이다.  

> 변경 빈도를 고려하면 좋을 듯  

사이드카 패턴은 이러한 문제를 우아하게 해결할 수 있는 대응책이다.  

DDD의 통찰에 의하면 데이터 스키마와 트랜잭션 또한 여타 마이크로서비스처럼 서비스 내부에 두어야 한다.  

> 위에서 언급한 데이터 스키마가 DB 테이블 스키마인지? 아니면 도메인 엔티티 스키마인지?  
> DB 테이블 스키마인 경우, 스키마 변경으로 도메인 로직 수정이 필요할 수 있어서 좋지 않다고 생각함  

사이드카 패턴은 도메인 로직과 기술적 로직을 분리한다는 점에서 육각형 아키텍처와 비슷하다.  

모든 서비스가 사이드카를 포함할 수 있다는 전제하에 아키텍트는 서비스 플레인을 통해 일관적인 운영 인터페이스를 구성할 수 있다.  
아키텍트와 운영자는 피트니스 함수를 통해 모든 서비스가 사이드 컴포넌트를 포함하도록 강제할 수 있다.  

엔터프라이즈 아키텍트 그룹처럼 거버넌스를 담당하는 조직은 사이드카 패턴을 활용해 무분별한 폴리글랏 환경의 난립을 합리적으로 제한할 수 있다.  
마이크로서비스의 장점 중 하나는 공통 플랫폼이 아닌 통합에 의존한다는 것이다.  

사이드카 패턴은 직교 커플링을 교정하는 직교 재사용 패턴이기도 하다.  
사이드카를 사용하면 아키텍처 전체를 관통하는 관심사를 하나의 일관성 있는 계층으로 고립시킬 수 있다.  


### 5.4.3 데이터 메시: 직교 데이터 커플링

데이터 메세는 분산 처리 개념을 적용해 분석 데이터를 공유, 접근, 관리하는 기법이다.  

데이터 메시는 다음과 같은 원칙을 기반으로 성립된다.  

##### 데이터의 도메인 소유권

데이터의 소유권은 데이터와 가장 친숙한 도메인이 가진다.  

##### 제품으로서의 데이터

데이터의 고립을 방지하고 공유를 장려하기 위해 데이터 메시는 데이터에 제품의 개념을 도입한다.  

##### 자가 서비스 데이터 플랫폼

데이터 제품 개발자와 소비자의 경험을 개선하는 데 중점을 둔다.  

##### 전산 연합 거버넌스

#### 데이터 제품 퀀텀

데이터 제품 퀀텀(DPQ)은 서비스에 인접한 거리에서 서비스와 커플링을 이룬다.  

> 1차 고객향 서비스에서 발생한 데이터를 기반으로 내부 요건을 처리하는 2차 서비스로 이해함  
> logstash, kibana?

##### 원천 DPQ

##### 집계 DPQ

##### 목적 DPQ


하나의 도메인은 다양한 분석 유형과 아키텍처 특성에 따라 여러 DPQ를 포함할 수 있다.  

각 데이터 제품 퀀텀은 서비스의 협력 퀀텀이기도 하다.  

분석 퀀텀은 개별 데이터 제품 퀀텀과 정적 퀀텀 결합을 생성해 정보를 수집하며, 요청 형식에 따라 동기 또는 비동기 방식으로 DPQ를 호출한다.  




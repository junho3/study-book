# 16 뉴스 피드 설계

시간 역순으로 정렬된 뉴스 항목 목록을 사용자에게 제공하는 뉴스 피드를 설계한다.  

## 16.1 요구사항

- 뉴스 항목은 시간의 역순으로 정렬돼야 하지만 이는 근사치일 수 있다.
- 뉴스 항목의 구성 요소
  - 150자 제한의 제목과 10,000자 제한의 본문
  - 생성된 시간으 나타내는 유닉스 타임스탬프
  - 오디오, 이미지, 동영상 고려하지 않음
- 기사는 여러 버전을 가질 수 있지만, 버전 관리는 고려하지 않는다.
- 일일 활성 사용자 10만 명이 하루 평균 10회씩 요청을 하고, 100만 개의 뉴스 항목을 처리할 수 있어야 한다.
  - 10만 x 10 / 24 / 60 / 60 = 11.6tps
- 읽기 작업의 P99 1초 이내
- 최대 몇 시간의 최종 일관성 허용
- 쓰기 작업의 고가용성 필요
- 읽기 작업의 고가용성은 필수는 아니다. 사용자가 오래된 뉴스를 자신의 기기에 캐시할 수 있기 때문이다.


## 16.2 상위 수준 아키텍처

뉴스 항목의 출처에서 백엔드의 수집 서비스로 뉴스 항목을 제출하면 이것이 데이터베이스에 기록된다.  
사용자는 뉴스 피드 서비스에 쿼리하고, 이 서비스는 데이터베이스에서 뉴스 항목을 가져와 사용자에게 반환한다.  

- 수집 서비스는 고가용성을 갖추고 무겁고 예측 불가능한 트래픽을 처리해야 한다. 
  - 카프카 같은 이벤트 스트리밍 플랫폼 사용을 고려해야 한다.
- 데이터베이스는 모든 항목을 보관해야 하지만 사용자에게는 최대 1,000개의 항목만 제공해야 한다.
  - 모든 항목을 보관하는 데이터베이스와 필요한 항목을 제공하는 다른 데이터베이스를 사용할 수 있음을 시시한다.
  - 1000개의 항목과 100개 태그에 해당하는 전체 뉴스 콘텐츠의 크기는 약 1GB로, 레디스 캐시에 쉽게 들어갈 수 있다.
  - 보관용으로는 HDFS 같은 분산 샤딩 파일 시스템을 사용할 수 있다.

수집기는 뉴스 항목만으로 수행할 수 있는 유효성 검사 작업을 수행한다.  

- SQL 인젝션
- 부적절한 언어 / 콘텐츠

소비자는 큐에서 폴링행 HDFS에 기록한다.  
최소한 두 개의 HDFS 테이블이 필요하다.  
하나는 소비자가 제출한 원시 뉴스 항목용이고, 기타 하나는 사용자에게 제공할 준비가 된 뉴스 항목용이다.  
이러한 HDFS 테이블은 태그와 시간으로 분할된다.  

사용자는 API 게이트웨이에 요청을 보내고, 이는 메타데이터 서비스에서 사용자의 태그를 쿼리한 다음 백엔드 서비스를 통해 레디스 캐시에서 적절한 뉴스 항목을 쿼리한다.  
레디스 캐시 키는 (tag, hour) 튜플이 될 수 있고, 값은 해당하는 뉴스 항목 목록이 될 수 있다.  

사용자가 이전 요청 후 한 시간 이내에 업데이트를 요청하면 다음 두 가지 접근 방식 중 하나 이상을 통해 서비스 부하를 줄일 수 있다.  

- 기기에서 요청을 무시한다.
- 기기에서 요청을 하지만 응답이 504 시간 초과이면 재시도 하지 않는다.


## 16.3 사전에 피드 준비하기

사용자의 피드를 사전에 준비함으로써 더 많은 저장 공간을 사용하는 대신 낮은 지연 시간 및 트래픽을 얻을 수 있다.  
{user ID, post ID}와 {post ID, post}의 두 해시맵을 준비할 수 있다.  
각각 1K, 10K 문자 항목을 가진 100개의 태그를 가정하면, 후자의 해시맵은 1GB를 약간 넘는 공간을 차지한다.  
전자의 해시맵에서는, 10억 개의 사용자 ID와 최대 100 * 1000개의 게시물 ID를 저장해야 한다.  
총 저장 공간 요구사항은 최대 800TB로, 레디스 클러스터의 용량을 초과할 수 있다.  

> 사용자 ID 10억 개는 갑자기 어떻게 등장한건지?

한 가지 해결책은 사용자를 지역별로 분할하고 데이터 센터당 두 세개의 지역만 저장하는 것이다.  

다른 해결책은 몇 십 개의 게시물 ID로 제한해 저장 공간 요구사항을 제한하는 것이지만, 이는 1,000개 항목 요구사항을 충족하지 못 한다.  

또 다른 해결책은 {user ID, post ID} 쌍에 샤딩된 SQL 구현을 사용하는 것이다.  
이 테이블을 해싱된 사용자 ID로 샤딩할 수 있어 사용자 ID가 노드 간에 무작위로 분산되고 핫 샤드 문제를 방지할 것이다.  

클러스터 간 트래픽이 불균등할 것이므로 분할의 수와 크기를 조정해 트래픽의 균형을 맞출 수 있다.  

유일한 클라이너트가 모바일 앱이라면 클라이언트에 게시물을 저장해 저장 공간을 절약할 수 있다.  

또 다른 방법은 타임스탬프 열을 추가하고 24시간보다 오래된 행을 주기적으로 삭제하는 ETL 작업을 하는 것이다.  

사용자가 모바일 앱을 열면 준비된 피드를 사용해 게시물에 첫 번째 요청만 처리하고 단일 노드에 맞는 수의 게시물 ID만 저장할 수 있다.  
사용자가 아래로 스크롤하면 앱이 더 많은 게시물을 요청할 수 있고, 이러한 요청은 레디스에서 처리될 수 있다.  

이 접근 방식은 더 낮은 지연 시간과 비용을 위해 더 높은 복잡성과 유지보수 부담을 트레이드오프한다.  


## 16.4 검증과 콘텐츠 조정

검증으로 모든 문제를 잡아내지 못할 수 있으며, 게시물이 사용자에게 잘못 전달될 수 있다.  

특정 ETL 작업은 일부 게시물에 수동 검토 플래그를 지정할 수 있다.  


### 16.4.1 사용자 기기의 게시물 변경

특정 유효성 검사는 자동화하기 어렵다.  

모든 시스템 설계에서 모든 오류와 실패를 방지하려고 해서는 안 된다.  
실수와 실패는 불가피하다고 가정하고, 이를 쉽게 감지하고 문제를 해결하며 수정할 수 있는 메커니즘을 개발해야 한다.  
사용자의 기기가 게시물을 캐시하면, 이를 삭제하거나 수정된 버전으로 덮어써야 한다.  

게시물 객체는 교체일 때 `REPLACE` 값을, 삭제일 때 `DELETE` 값을 가진 이벤트를 포함해야 한다.  

뉴스 피드 서비스가 클라이언트 측 게시물을 수정하려면, 클라이언트가 어떤 게시물을 보유하고 있는지 파악할 수 있어야 한다.  
클라이언트에 보존 기간을 설정해 오래된 게시물을 자동으로 삭제하면 이러한 오래된 로그도 삭제할 수 있지만, 저장 비용이 여전히 높을 수 있다.  

다른 해결책은 클라이언트가 GET / POST 요청에 현재 게시물 ID를 포함시키는 것이다.  
백엔드는 이러한 게시물 ID를 처리해 어떤 새 게시물을 보낼지 결정하고 어떤 게시물을 변경하거나 삭제해야 하는지도 결정할 수 있다.  

> 피드 제공 API가 무거워 지는게 아닌지?  


### 16.4.2 게시물 태깅

특정 규칙은 현지의 문화적 민감성이나 정부 법규로 인해 특정 국가에만 적용될 수 있다.  

각 사용자에게 특정 게시물을 필터링하기 위해서 사용할 특정 메타데이터로 게시물에 태그를 지정해야 한다.  

태그별로 게시물 ID를 필터링하는 로직은 애플리케이션 수준에서 수행해야 한다는 점을 명심한다.  

지역별 뉴스 피드에서는 지역별로 레디스 캐시를 분할하거나 레디스 키에 추가 '지역' 열을 도입해야 할 수 있다.  


### 16.4.3 조정 서비스

시스템은 네 곳에서 검증을 수행한다.  
클라이언트, 수집기, ETL 작업, GET / POST 요청 중 백엔드에서다.  
개발과 유지보수가 중복되고 버그 위험이 높아지지만, 다양한 브라우저와 모바일 앱, 수집기에서 동일한 검증을 구현한다.  
검증은 CPU 처리 오버헤드를 추가히지만 뉴스 피드 서비스로의 트래픽을 줄여 더 작은 클러스터 크기와 낮은 비용을 의미한다.  

> 무슨 의미인지?  
> 클라이언트에서 검증을 하기 때문에 서버 요청이 덜 간다는것인지?  
> 클라이언트에서 검증은 무엇을 기준으로 하는건지?  

해커가 뉴스 피드 서비스에 직접 API 요청을 해 클라이언트 사이드 검증을 우회하더라도 서버 사이드 검증이 이러한 유효하지 않은 요청을 잡아낸다.  


## 16.5 로깅, 모니터링, 경보


### 16.5.1 텍스트와 이미지 함께 제공

이미지 파일은 여러 게시물에서 재사용될 수 있다.  


### 16.5.2 고수준 아키텍처

미디어 업로드는 동기식이어야 한다.  
출처에서 업로드 성공 여부를 알아야 하기 때문이다.  

> 비동기로 성공 / 실패 여부를 출처에게 전달할 순 없는지?

사용자가 지리적으로 널리 분산돼 있거나 사용자 트래픽이 미디어 서비스에 너무 많은 부하를 줄 때 CDN을 사용할 수 있다.  

텍스트와 미디어를 별도의 서비스에서 처리하고 저장하는 것과 단일 서비스에서 처리하고 저장하는 것의 트레이드오프에 대해 논의할 수도 있다.  

한 걸음 더 나아가 텍스트와 미디어를 포함한 전체 기사를 CDN에 호스팅할 수도 있다.  


## 16.6 기타 논의 가능한 주제



# 8장 트랜잭션

MySQL에는 MyISAM과 같은 비트랜잭션 스토리지 엔진이 있지만 InnoDB가 기본값이고, 사실상 모든 MySQL 쿼리는 단일 SELECT 문이라도 트랜잭션에서 실행됩니다.  
애플리케이션 워크로드가 잘 최적화되면 트랜잭션은 성능과 관련된 문제가 없습니다.  

## 8-1 로우 락

읽기는 행을 잠그지 않지만, 쓰기는 항상 행을 잠급니다.  
`REPEATBALE READ` 트랜잭션에서 InnoDB는 쓰기 행 말고도 훨씬 더 많은 행을 잠글 수 있습니다.  

테이블은 인덱스이므로, 행은 인덱스 레코드입니다.  
InnoDB 로우 락은 인덱스 레코드 갭 때문에 로우 락이 아니라 레코드 락 관점에서 논의됩니다.  

> MySQL 인덱스는 B-tree로 관리  
>        1    ...    10  
>    1  ..  5   |   6  ..  10   
>  1 . 2 | 3 . 5 |  6 . 7 | 8 . 10  
> 3번 데이터를 업데이트 할 경우, 3, 4, 5번 데이터가 잠김  

간단히 말해, 애플리케이션은 행 단위로 처리하고 InnoDB 로우 락은 레코드 단위로 처리합니다.  
이 절의 예는 갭 락이 상당히 광범위하고 개별 레코드 락보다 더 중요하다는 것을 보여 줍니다.  

### 레코드와 넥스트-키 락

```
UPDATE elem SET c = '' WHERE id BETWEEN 2 AND 5;  
하한 ... 2 (레코드 락) ... 5 (넥스트-키 락) ... 상한 (넥스트-키 락)  
```

> 2와 5 사이에는 갭 락이 존재  

흥미로운 질문은 "테이블 조건에서 5보다 큰 프라이머리 키값을 제외할 때, 5보다 큰 모든 프라이머리 키값을 포함하는 상한.의사 레코드를 잠그는 이유는 무엇일까요?" 입니다.  

새로운 값(3)을 삽입할 2와 5 사이의 갭에서 **삽입 의도 잠금**을 획득하려고 시도하는 첫번째 INSERT는 시간 초과가 발생합니다.  
lock_data 열에 값 5가 나열되지만 레코드나 넥스트-키 락이 아니므로 이 레코드는 잠기지 않습니다.  
이것은 특별한 유형의 갭 락인 삽입 의도 잠금이므로 값 5 이전의 갭을 잠급니다.  

두 번째 INSERT는 새 값 6이 현재 최댓값 5보다 크기 때문에 상한-의사 레코드에서 넥스트-키 락을 획득하려고 시도할 때 시간이 초과되어 최대 레코드와 상한 의사 레코드 사이에 삽입됩니다.  

영향을 받는 레코드 앞의 갭을 잠그면 넥스트-키 락은 쿼리가 접근하는 레코드의 전체 범위를 격리합니다.  
이는 ACID 속성 가운데 I(격리성)을 나타냅니다.  
이는 트랜잭션이 이전에 읽지 않은 행을 나중에 읽을 때 **팬텀 행**이라는 현상을 방지합니다.  

`REPEATABLE READ`는 MySQL의 기본값이며 InnoDB는 넥스트-키 락을 사용하여 REPEATABLE READ에서 팬텀 행을 방지합니다.  

트랜잭션 격리 수준인 `READ COMMITTED`는 넥스트-키 락을 포함하는 갭 락을 비활성화합니다.  
`READ COMMITTED` 트랜잭션의 동일한 UPDATE 문은 일치하는 행(2, 5)에서만 레코드 락을 획득합니다.  

`READ COMMITTED`에는 2가지 중요한 부작용이 있습니다.  
- 동일한 읽기 문을 다시 실행하면 다른 행을 반환할 수 있습니다.
- 동일한 쓰기 문을 다시 실행하면 다른 행에 영향을 미칠 수 있습니다.

> A1 트랜잭션 시작  
> A1 트랜잭션에서 SELECT 실행: 값이 5  
> B1 트랜잭션 시작  
> B1 트랜잭션에서 UPDATE 실행: 값이 5에서 1로 변경  
> A1 트랜잭션에서 SELECT 실행: 값이 5가 아닌 1로 조회 됨 << 이 부분이 문제인 듯  
> A1 트랜잭션 종료  
> B1 트랜잭션 종료  


### 갭 락

갭 락은 순수하게 다른 트랜잭션이 갭에 행을 삽입하는 것을 금지하고 방지합니다.  
모든 갭 락은 다른 갭 락과 호환되므로 다중 트랜잭션이 같은 갭을 잠글 수 있습니다.  
그러나 갭 락은 다른 트랜잭션이 갭에 행을 삽입하는 것을 방지하므로, 갭을 잠그는 유일한 트랜잭션일 때는 하나의 트랜잭션만 갭에 행을 삽입할 수 있습니다.  

`SELECT * FROM elem WHERE id = 3 FOR SHARE;`
`READ REPEATABLE`과 `SELECT FOR SHARE`로 갭에 접근하면 단독 갭 락(2 ~ 5 사이)을 호출합니다.  

공유(SHARE) 또는 배타적인(EXCLUSIVE) 모든 갭 락은 다른 트랜잭션이 갭에 행을 삽입하는 것을 방지합니다.  
무해한 SELECT 문은 실제로는 교활한 INSERT 차단기입니다.  

```
UPDATE elem SET c = '' id BETWEEN 2 AND 5; >> 넥스트-키 락으로 갭을 잠금
UPDATE elem SET c = '' id IN (2, 5); >> 갭에 접근하지 않으므로 레코드 락을 사용
UPDATE elem SET c = '' id IN (2, 3, 5); >> 2~5 사이의 공백에 접근하고 갭 락 사용
```
똑같은 EXPLAIN 계획이 있고 행이 일치하더라도 쿼리는 행에 다르게 접근 합니다.

갭 락은 `READ COMMITTED`를 사용하여 쉽게 비활성화할 수 있습니다.  


### 세컨더리 인덱스

세컨더리 인덱스는 로우 락, 특히 고유하지 않은 인덱스와 관련하여 잠재적으로 광범위한 결과를 초래합니다.  

```
UPDATE elem SET c = '' WHERE a BETWEN 'Ar' AND 'Au';
```
UPDATE는 두 행만 일치하지만 전체 세컨더리 인덱스를 잠가 값을 삽입하지 못하게 합니다.  

`READ COMMITTED`는 일치하는 행만 레코드 락으로 잠기므로 고유하지 않은 세컨더리 인덱스에 대해서도 갭 락을 방지합니다.  

```
UPDATE elem SET c = '' WHERE a IN ('Ar', 'Au');
```
BETWEEN 절을 IN 절로 변경하여 갭 락을 방지했지만, 고유하지 않은 인덱스에서는 작동하지 않습니다.  

> IN 절로 갭락을 방지하는건 PK와 유니크키만 가능하다는 것인지?

```
UPDATE elem SET c = 'GO' WHERE a = 'Au';
```
'Au' 값은 사라졌지만 InnoDB는 여전히 튜플에 넥스트-키 락('Au', 2)을 유지합니다.  
새로운 'Go'에는 레코드 락이나 넥스트-키 락이 없으며 ('Go', 2) 앞에 갭 락만 있습니다.  


### 삽입 의도 잠금

삽입 의도 잠금은 갭이 다른 트랜잭션에 의해 잠기지 않을 때 트랜잭션이 갭에 행을 삽입함을 의미하는 특별한 유형의 갭 락입니다.  
삽입 의도 잠금은 다른 삽입 의도 잠금과 호환됩니다(차단하지 않음).  
이는 다중 트랜잭션이 동시에 같은 갭에 서로 다른 행을 삽입할 수 있어서 INSERT 성능에 중요합니다.  

갭 락은 INSERT를 방지합니다. 삽입 의도 잠금은 INSERT를 허용합니다.  

```
UPDATE elem SET c = '' WHERE id BETWEEN 2 AND 5; // id < 5 조건의 갭을 잠금  

INSERT INTO elem VALUES (3, ...); // 먼저 삽입의도 잠금을 생성하고, UPDATE 문이 COMMIT(갭이 잠금 해제) 되면 데이터 추가

INSERT INTO elem VALUES (9, ...); // 갭 락을 차단하지 않음
```

명시적 잠금은 메모리에 잠금 구조로 존재하므로 InnoDB는 이를 보고할 수 있습니다.  
암시적 잠금은 잠금 구조가 없으므로 InnoDB는 보고할 것이 없습니다.  


## 8-2 MVVC와 언두 로그

InnoDB는 다중 버전 동시성 제어(MVCC)와 언두 로그를 사용하여 A, C, I 속성을 수행합니다.  
MVCC는 행에 대한 변경 사항이 행의 새 버전을 생성함을 의미합니다.  
행이 처음 생성될 때는 버전이 1입니다.  
처음 업데이트될 때 버전은 2가 됩니다.  

언두 로그는 변경 사항을 이전 행 버전으로 롤백하는 방법을 기록합니다.  

`REPEATBALE READ` 트랜잭션에서 첫 번째 읽기는 SELECT가 실행되는 순간 데이터베이스의 가상 보기인 스냅샷을 설정합니다.  
이때 설정된 스냅샷은 해당 트랜잭션이 끝날 때까지 유지되며, 이후 모든 읽기는 데이터베이스의 변경 내역에서 오직이 시점의 행 접근에만 사용됩니다.  
이 시점 이후에 다른 트랜잭션에 의해 변경된 사항은 원본 트랜잭션 내에서 볼 수 없습니다.  
다른 트랜잭션이 데이터베이스를 수정한다고 가정하면, 원본 트랜잭션의 스냅샷은 트랜잭션이 활성 상태를 유지하는 동안 점점 더 오래된 데이터베이스 보기가 됩니다.  

> 이래서 Jpa가 영속성 컨텍스트 (1차 캐시)가 존재하는 것인지?  
> REPEATABLE READ의 @Transactional 범위 내에서는 결국 DB의 스냅샷 결과만 조회할태니깐?  

해당 트랜잭션이 SELECT 를 다시 실행하면 버전 5를 읽지만, 해당 버전이 스냅샷으로 인해 설정된 데이터베이스 변경 내역의 지점보다 더 최신임을 알 수 있습니다.  
결과적으로 MySQL은 언두 로그를 사용하여 행을 롤백하고 버전 1을 재구성합니다.  
이는 첫 번째 SELECT 문에 의해 설정된 스냅샷과 일치합니다.  

> REPETABLE READ에서 트랜잭션이 유지 된다면, SELECT의 결과는 모두 똑같다는 의미로 이해함

`READ COMMITTED`트랜잭션에서 각 읽기는 새 스냅샷을 설정합니다.  
스냅샷이 사용되기 때문에 언두 로그가 계속 생성되지만, 각 스냅샷은 읽기 기간 동안만 유지 됩니다.  
읽기에 매우 오랜 시간이 걸리고 데이터베이스의 쓰기 처리량이 많을 때는 변경 내역 목록 길이가 증가함에 따라 리두(redo) 로그가 발생할 수 있습니다.  

스냅샷은 읽기에만 영향을 미치며 쓰기에는 사용되지 않습니다.  
쓰기는 트랜잭션이 SELECT로 현재 행을 볼 수 없더라도 항상 비밀리에 현재 행을 읽습니다.  
원본 트랜잭션이 프라이머리 키 값이 같은 행을 삽입하려고 하면 트랜잭션이 SELECT로 다른 트랜잭션이 입력한 프라이머리 키값을 볼 수 없어도 존재는 하므로 MySQL은 중복 키값을 반환합니다.

> 비록 트랜잭션 A가 트랜잭션 B의 값을 조회할 수는 없지만, MySQL은 내부적으로 해당 프라이머리 키 값의 잠금(lock)을 알고 있기 때문에, 중복 키 값 충돌을 감지할 수 있습니다.  
> 트랜잭션이 다른 경우, SELECT를 하지 않더라도 삽입 의도 잠금으로 알 수 있는 듯  

언두 로그는 쓰기로 인해 변경된 내용을 되돌리기 위해 `ROLLBACK`에서도 사용됩니다.  
언두 로그는 버퍼 풀 페이지에 있으므로 메모리를 사용하고 주기적으로 디스크로 플러시 됩니다.  


## 8-3 변경 내역 목록 길이




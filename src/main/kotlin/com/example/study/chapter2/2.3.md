# 2.3 코드의 계층

- 함수
- 클래스
- 인터페이스
- 페키지, 네임스페이스, 모듈

## 2.3.1 API 및 구현 세부 사항

API는 호출하는 쪽에 공개할 개념만 정의하면 되고, 그 이외의 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다.
API 수정 사항에 대한 세부 정보가 노출된다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아니다.

> MSA 아키텍처에서 BFF가 동일한 개념이라고 생각함  
> API Gateway 또한 단순 라우팅 역할인가? https://youtu.be/P2nM0_YptOA  

## 2.3.2 함수

하나의 메소드 내에서 너무 많은 개념을 동시에 다루면 코드를 이해하기 어렵다.
중첩된 if 문과 같이 코드를 이해하기 어렵게 만든다.

> 유스케이스를 분석하여, if문을 활용한 유스케이스 처리보다 유스케이스별 클래스를 정의해야 함  
> early return 등으로 단순화 시켜야 함  

함수의 행위를 표현한 문장에 너무 많은 단어들이 들어가면, 좋은 문장이라고 할 수 없고, 함수의 내부 구현도 복잡해진다.
문장을 쪼깨 듯이 함수의 내부 구현도 성격에 맞게 분리해야한다.

## 2.3.3 클래스

- 응집력
- 관심사 분리

응집력과 관심사 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야한다.  
**이것은 매우 주관적일 수 있기 때문에 종종 보기보다 까다로울 수 있다.**  
단일 클래스 내에 얼마나 많은 다른 개념이 들어가 있는지, 그리고 어떤 로직이 재사용이나 재구성에 적합한지에 대해 개발자가 신중하게 생각하지 않으면 클래스는 너무 커진다.  

```
회계 전표 적재 코드 아키텍처
결제 / 취소가 발생했을 경우, 회계 정보를 증빙하기 위해 전표 데이터를 생성해야함
1. 수납 데이터 조회
2-3. 결제수단이 카카오페이 머니인 경우, 추가 작업 없음
2-2. 결제수단이 카카오페이 카드인 경우, 카드 전표 생성
2-3. 결제수단이 가상계좌인 경우, 가상계좌 입금 데이터 생성 
3. 전표 데이터 생성
4. 원장이력 데이터 생성

결제 카프카 메세지를 구독 > 생성해야할 회계 전표 종류를 결정 > 적합한 클래스의 메소드 호출

CreateSlipUseCase (Interface)
  ㄴ CreateApprovedKakaoPayMoneySlipService
  ㄴ CreateApprovedKakaoPayCardSlipService
  ㄴ CreateApprovedVirtualAccountSlipService
  ㄴ CreateCanceledKakaoPaySlipService
```

많은 개발자들이 '한 클래스는 오직 한 가지 일에만 괌심을 가져야한다. 클래스는 응집력이 있어야 한다.'는 동의하지만,  
하위 문제를 해결하는 것이 원래 문제와는 다른 관심사인지 아니면 원래 문제의 일부분으로 간주해야 하는지는 의견이 다르다.  

4 가지 핵심 요소에 반하여 작성되어 있는지 살펴보는 것이 도움이 된다.  

1. 코드를 읽을 수 없다.
2. 코드가 특별히 모듈화되어 있지 않다.
3. 코드를 재사용할 수 없다.
4. 코드를 일반화할 수 없다.
5. 코드를 제대로 테스트하기 어렵다.  

## 2.3.4 인터페이스

하나의 추상화 계층에 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는게 좋다.  
인터페이스 구현체가 여러개인 경우, 팩토리 클래스로 DI할 대상 클래스 선정을 위임하는 방법  
> 참고 https://refactoring.guru/ko/design-patterns/factory-method

주어진 추상화 계층에 대해 한 가지 구현만 있고, 향후에 다른 구현을 추가할 계획이 없더라도 매번 인터페이스를 선언해야하는가?
여러분과 여러분의 팀이 결정할 사안이지만, 몇몇 소프트웨어 공학 철학은 이 상황에서도 인터페이스를 사용하는 것을 권고한다.
> 각자의 선택이지만, 처음부터 인터페이스를 꼭 선언할 필요는 없다고 생각함  
> 구현체가 여러개가 생겨야한다면 그 때 인터페이스를 선언하는 방식 선호  

인터페이스를 사용했을 때의 장점
1. 퍼블릭 API를 매우 명확하게 보여준다.
   - 구현 클래스에 새로운 퍼블릭 메소드를 선언하여도, 상위 계층에서 접근 불가
2. 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다
3. Mock이나 페이크 객체로 테스트를 쉽게 할 수 있다.
4. 같은 클래스로 두 가지 하위 문제를 해결할 수 있다.

단점  
1. 더 많은 작업이 필요하다.
2. 코드가 복잡해질 수 있다.

> 4번 관련
> 개발환경에서 결제 우회와 같이 전체 로직 자체를 목킹이 필요하다면 인터페이스로 선언하는게 유용할 것 같음  
> 6번 관련  
> 처음 헥사고날로 구현된 프로젝트 코드를 봤을 때 너무 많은 인터페이스(Port & Adapter) 때문에 이해하기 어려웠음

## 2.3.5 층이 너무 얇아질 때

- 보일러플레이트 코드 증가
- 로직의 이해를 위해 코드 추적이 어려움
- 인터페이스 뒤에 숨기게 되면, 조건실제 구현을 알 수 없고, 디버깅 비용 증가

계층이 얇은 것과 많은 것 어떤 것이 더 나을지 확실하지 않다면, 너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다는 낫다.

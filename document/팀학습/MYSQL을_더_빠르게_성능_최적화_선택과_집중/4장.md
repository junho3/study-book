# 4장 접근 패턴

**접근 패턴**은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.  
접근 패턴을 변경하면 MySQL 성능에 큰 영향을 미치지만, 일반적으로 다른 최적화보다 더 많은 노력이 필요합니다.  
QPS와 CPU 사용량과 같은 메트릭은 MySQL에 대해 거의 아무것도 알려주지 않습니다.  

의심의 여지 없이 MySQL은 애플리케이션에 대해 충분히 빠릅니다.  
진짜 질문은 애플리케이션이 MySQL을 효율적으로 사용하느냐는 것입니다.  


## 4-1 MySQL은 아무것도 하지 않는다

애플리케이션이 바쁘게 쿼리를 실행 중이면 MySQL도 바쁘게 해당 쿼리를 실행 중입니다.  
실제로 백그라운드 작업(페이지 플러싱)은 쿼리를 실행하는 포그라운드 작업을 허용하여 느린 작업을 지연하거나 방지함으로써 성능을 향상시킵니다.  
따라서 MySQL이 느리게 실행되는데 외부 문제가 없다면 원인은 MySQL을 구동하는 애플리케이션뿐입니다.  
MySQL은 애플리케이션이 사용자가 모르는 쿼리를 실행하지 않는 한 시스템에 고스트가 없습니다.  

쿼리는 다른 쿼리에 영향을 줍니다.  
이에 대한 일반적인 용어는 **쿼리 경합**입니다.
로우 락 경합, CPU 경합 등 특정 유형의 경합이 있습니다.  

MySQL은 로우 락 경합이라는 한 가지 유형의 경합만 보고하므로 쿼리 경합을 보거나 증명하는 것은 거의 불가능합니다.  
쿼리 경합은 교통 체증과 같습니다.  
쿼리 경합은 성능이 한계에 도달할 때 중요한 역할을 합니다.  


## 4-2 한계에 도달하면 성능이 불안정해진다

**선형 스케일링**  
부하가 증가함에 따라 데이터베이스 성능은 시스템 용량을 100% 사용할 때까지 증가한 다음, 성능이 일정하게 유지됩니다.  
선형 스케일링은 모든 DBA와 엔지니어의 이상이지만 실현될 수 없습니다.  

현실적으로 데이터베이스 성능의 한계는 시스템 용량의 80~95%입니다.  
부하가 한도를 초과하여 증가하면 데이터베이스 성능이 불안정해집니다.  

```
범용 확장성 법칙
X(N) = yN / 1 + a(N - 1) + BN(N - 1)
```

동시성(y)는 부하(N)이 증가함에 따라 처리량이 증가하는 데 도움이 됩니다.  
그러나 경합(a)와 일관성(B)은 부하가 증가함에 따라 처리량을 감소시킵니다.  
이는 선형 확장성을 불가능하게 하고 데이터베이스 성능을 제한합니다.  

성능을 제한하는 것보다 더 나쁜 일관성은 **역행 성능**을 유발합니다.  
즉, 높은 부하에서 성능이 감소합니다.  

운영 중단에는 3가지 기간이 있습니다.  

### 상승기(오전 6시~9시)

애플리케이션 개발자는 증가하는 수요에 대처하기 위해 트랜잭션 처리량을 늘렸습니다.  
MySQL이 한계에 다다를 때까지 상승과 응답이 반복되었고 결국 더이상 작동하지 않았습니다.  

### 한계점(오전 9시~정오)

실행 중인 스레드의 톱날 패턴은 MySQL이 불안정해졌음을 나타내는 신호였습니다.  
하나의 쿼리를 실행하는 데 하나의 스레드가 필요하므로 실행 중인 스레드의 큰 변동은 쿼리가 시스템을 통해 원활하게 흐르지 못한다는 것을 나타냅니다.  

높은 상태로 변함없는 CPU 사용량과 QPS는 오해의 소지가 있습니다.  
평평한 선을 그리는 메트릭은 하나의 연속적인 음을 매우 강하게 계속 연주하는 클라리넷 연주자에 비유됩니다.  
안정되지만 음악은 아닙니다.  

### 수정(정오~오후3시)

트랜잭션 처리량 증가는 그 자체로 소멸되었기 때문에 수정 사항은 트랜잭션 처리량을 줄이는 것이었습니다.  

더 일반적으로 높은 부하는 애플리케이션을 불안정하게 하여 MySQL에서 부하가 증가하는 것을 방지합니다.  
다시 말해, MySQL을 한계까지 밀어붙이기 전에 애플리케이션이 실패합니다.  

애플리케이션에 관심을 돌리기 전에 한계에 도달한 MySQL 성능에 대한 2가지 추가 사항은 다음과 같습니다.  

첫째, 일부러 부족한 하드웨어를 사용하지 않는 한 한계에 도달하기 어렵습니다.  
애플리케이션은 모든 하드웨어를 동시에 완전히 활용하기 훨씬 전에 하드웨어 한 부분에서 병목 현상을 일으킬 가능성이 가장 큽니다.  
이때 애플리케이션은 데이터베이스 성능의 한계에 도달한 것이 아니라 오직 해당 하드웨어의 한계에 도달한 것입니다.  

둘째, 높은 부하로 인해 MySQL이 느리게 응답한다고 해서 한계에 도달했다는 의미는 아닙니다.  
동시성(y)이 증가하면 한계가 증가하므로 느린 데이터베이스 성능이 한계에 도달했음을 의미하지는 않습니다.  
경합(a)을 줄이면 한계도 높아집니다.  


## 4-3 도요타와 페라리

일부 애플리케이션은 놀라운 MySQL 성능을 달성하지만 다른 애플리케이션은 낮은 처리량으로 어려움을 겪습니다.  

페라리는 도요타보다 110km/h 더 빠르게 만드는 특별한 부품이 없습니다.  
페라리의 독특한 외부 디자인은 화려하면서도 기능적입니다.  

고속과 마찬가지로 고성능은 억지 기법이나 무차별적으로 달성되는 것이 아닙니다.  
고성능을 목표로한 치밀한 설계의 산물입니다.  


## 4-4 데이터 접근 패턴

**데이터 접근 패턴**은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.  
접근 패턴에 대한 3가지 세부 정보를 명확히 하며 상황을 바꿔 보겠습니다.  

첫째, 접근 패턴을 복수형으로 논의하는 것이 너무 일반적이어서 서로 모호해지기 시작합니다.  
애플리케이션에는 많은 접근 패턴이 있습니다.  
편의상 복수형으로 논의되지만 실제로는 접근 패턴을 개별적으로 수정합니다.  

둘째, 접근 패턴은 궁극적으로 쿼리를 참조하며 여러분은 접근 패턴을 변경하기 위해 쿼리와 애플리케이션을 변경하지만 쿼리가 초점이 아닙니다.  
Go 프로그래밍 언어의 용어에서 접근 패턴은 '인터페이스'이고 쿼리는 '구현'입니다.  
구현이 아닌 인터페이스에 집중하세요.  
이 책에서는 접근 패턴 수정에 대해 설명하지만 실제로는 쿼리(그리고 애플리케이션)을 수정합니다.  

셋째, 접근 패턴은 이름과 기술적인 특성 목록으로 구성됩니다.  
이름은 접근 패턴을 식별하고 다른 엔지니어와 소통하는 데 사용됩니다.  
기술적인 특성 목록은 데이터 스토리지에 따라 다릅니다.  

> 쿼리 힌트(?) 쿼리가 로그에 기록될 때 id 같은걸 부여해달라는 DBA 요청이 있었음  

- 팀내 논의를 통해 가장 명백하고 일바적인 접근 패턴 식별
- 쿼리 보고를 사용하여 가장 느린 상위 접근 패턴 식별
- 덜 알려진(또는 잊혀진) 접근 패턴에 대한 코드 파악


### 읽기/쓰기

`SELECT`라는 읽기 접근은 명확합니다.  
`INSERT`, `UPDATE`, `DELETE`는 항상 쓰기 접근으로 간주합니다.  
`INSERT`와 `DELETE`는 내부적으로 다른 쓰기입니다.  

읽기 확장은 일반적으로 읽기를 오프로드하여 수행되며, 쓰기 확장은 더 어렵지만 쓰기를 대기열에 추가하는 것이 하나의 기술이며, 궁극적인 솔루션인 샤딩을 다룹니다.  
이 특성은 매우 간단하지만 애플리케이션이 읽기 중심인지 쓰기 중심인지 알면 신속하게 관련 애플리케이션 변경에 집중할 수 있어서 중요합니다.  
다른 데이터 스토리지는 읽기나 쓰기에 최적하되었으며, MySQL에는 쓰기에 최적화된 스토리지 엔진인 MyRocks가 있습니다.  

> Jpa 연관관계 맺을 때도 읽기 중심인지, 쓰기 중심인지에 따라 단방향 / 양방향 관계를 결정하곤 함  
> 개인적으로 쓰기 중심인 경우, 양방향으로 하여 Root 엔티티를 통해 영속성 전파하는 것을 선호  


### 처리량

처리량은 성능이 아닙니다.  
1QPS에 불과한 낮은 처리량의 접근만으로도 큰 피해를 줄 수 있습니다.  

> 수백 줄의 한 방 쿼리

테이블 스캔을 수행하고 모든 행을 잠그는 `SELECT ... FOR UPDATE` 문입니다.  

변동(QPS가 증가하고 감소하는 방식)도 똑같이 중요합니다.  
문제는 업무 시간에 QPS가 높아지면 개발자가 스키마 변경을 수행하거나 데이터를 재처리할 수 없다는 것입니다.  


### 데이터 수명

수명은 시간이 아니라 접근 순서에 상대적입니다.  
첫 번째 행은 10분이 지나서가 아니라 접근한 마지막 행이라서 가장 오래된 행입니다.  
첫 번째 행을 갱신하면 가장 최근에 접근한 행이므로 가장 최신 행이 됩니다.  

이 특성은 작업 세트에 영향을 미치기 때문에 중요합니다.  
MySQL은 될 수 있는 한 많은 데이터를 메모리에 보관하고, 데이터 수명은 메모리의 데이터가 작업 세트의 일부인지 아닌지에 대해 영향을 미칩니다.  
데이터에 접근하면 데이터가 메모리에 최신 상태로 바뀌어 유지되고, 이 데이터는 자주 접근되기 때문에 이 데이터를 포함하는 작업 세트는 메모리에 남게 됩니다.  

오래된 데이터에 자주 접근하는 것은 여러 면에서 문제가 됩니다.  
데이터는 **여유 페이지**(메모리 내)에 적재됩니다.  
사용할 수 있는 여유 페이지가 있을 때는 정상인데, 문제는 스토리지에서 데이터를 읽는 것은 속도가 느리다는 것뿐입니다.  
비정상으로 여유 페이지가 하나도 없다면 문제가 3배로 약화됩니다.  

1. MySQL은 가장 최근에 사용한 LRU 목록에서 추적하여 오래된 페이지를 제거해야 합니다.
2. 오래된 페이지가 더티일 때 MySQL은 이를 제거하기 전에 플러시해야 하는데, 플러시는 속도가 느립니다.
3. 스토리지에서 데이터를 읽는 속도가 느리다는 원래 문제가 남아 있습니다.

그림 4-4의 프로세스를 구동하는 알고리즘은 오래된 데이터에 가끔 접근하는 것이 새로운 데이터를 읽어오는 데 간섭하는 것을 방지합니다.  
따라서 데이터 수명과 처리량을 함께 고려해야 합니다.  
오래되고 느린 접근은 아마도 무해하지만 오래되고 빠른 접근은 문제를 일으킬 수 있습니다.  

데이터 수명을 측정하기가 거의 불가능합니다.  
오래된 데이터는 시간이 아니라 접근과 관련이 있다는 것을 기억하세요.  


### 데이터 모델

MySQL은 관계형 데이터 스토리지지만 일반적으로 키-값, 문서, 복잡한 분석, 그래프 등과 같은 다른 데이터 모델과 함께 사용됩니다.  
비관계형 접근은 MySQL에 상당히 부적합하므로 잘 알고 있어야 합니다.  
접근 방식에 이상적인 데이터 모델을 결정한 다음, 해당 데이터 모델로 구축된 데이터 스토리지를 사용하세요.  


### 트랜잭션 격리

**격리성**(고립성)은 원자성, 일관성, 격리성, 지속성 등 4가지 ACID 속성 중 하나입니다.  
InnoDB는 트랜잭션 속성을 가지며, 모든 쿼리는 기본적으로 단일 `SELECT`문을 포함하여 트랜잭션에서 실행됩니다.  
따라서 접근이 필요하든 필요하지 않든 격리됩니다.  

#### 없음(None)

비트랜잭션 스토리지 엔진에서 올바르게 실행됩니다.  
쓸모없는 오버헤드일 뿐이지만, 문제를 일으키거ㅏ 성능에 눈에 띄게 영향을 미치지는 않습니다.  


#### 기본(Default)

데이터 접근에는 격리가 필요하지만 어떤 수준이 필요한지 알 수 없거나 불분명합니다.  
애플리케이션은 MySQL의 기본 트랜잭션 격리 수준인 `REPEATABLE READ`로 올바르게 작동합니다.  
다른 격리 수준이 제대로 작동하는지 확인하려면 신중하게 검통해야 합니다.  


#### 특정(Specific)

특정 격리 수준이 없으면 데이터에 접근할 때마다 잘못된 버전의 데이터를 볼 수도 있으며 이는 애플리케이션에 심각한 문제가 됩니다.  

`REPEATABLE READ`가 대부분의 경우에 정확하기 때문에 중요합니다.  


### 읽기 일관성

**강력한 일관성**은 읽기가 가장 최신 값을 반환함을 의미합니다.  
장시간 실행되는 트랜잭션은 오래된 값을 읽을 수 있지만 트랜잭션 격리 수준과 관련하여 기술적으로는 현재 값입니다.  

**최종 일관성**은 읽기가 이전 값을 반환할 수 있지만 결국에는 현재 값을 반환함을 의미합니다.  
MySQL 복제본에 대한 읽기는 복제 지연으로 인해 차이가 발생하지만 최종적으로 일관성이 있게 됩니다.  


### 동시성

높은 동시성은 같은 데이터를 동시에 자주 읽거나 쓰기로 접근하는 것을 의미합니다.  
같은 데이터에 대한 쓰기 동시성이 높을수록 로우 락 경합이 커집니다.  

락 대기 시간 초과가 발생하면 동시성을 낮추거나 쓰기 확장을 위한 샤드로 해결해야 한다.  

같은 데이터를 높은 동시성으로 읽지만 자주 변경되지 않을 때는 캐시에 적합합니다.  


### 행 접근

행 접근에는 3가지 유형이 있습니다.  
1. 포인트 접근: 단일 행
2. 범위 접근: 두 값 사이의 정렬된 행
3. 임의 접근: 임의의 순서로 된 여러 행

비고유 인덱스를 사용하는 범위와 임의 접근 쓰기는 **갭 락**으로 인해 로우 락 경합을 악화시킵니다.  
임의 접근 쓰기는 데드락에 대한 설정이며, 데드락은 두 트랜잭션이 다른 트랜잭션에 필요한 로우 락을 보유하는 경우입니다.  

효과적으로 샤딩하려면 접근 패턴이 단일 샤드를 사용해야 합니다.  


### 결과 세트

접근 방법에 `GROUP BY`나 `ORDER BY` 또는 `LIMIT`절이 있습니까?
이러한 각 절은 다른 데이터 스토리지에서 접근 방법이 어떻게 변경이 될지, 어떻게 실행이 될지에 대한 영향을 미칩니다.  
최소한 행을 그룹화하거나 정렬하는 접근 방법을 최적화하세요.  


## 4-5 애플리케이션 변경

데이터 접근 패턴을 변경하려면 애플리케이션을 변경해야 합니다.  

코드 변경과 더불어 인프라 변경도 필요하다는 사실에 마음의 준비를 해야 합니다.  

애플리케이션 재설계에 바로 뛰어들 수 있는 시간과 에너지가 있다면 여러분은 이 책의 지원을 받을 수 있습니다.  

### 코드 검사

"문제를 일으키지 않는다"는 것이 반드시 코드가 효율적이거나 필수적이다는 것을 의미하지는 않습니다.  
다음과 같은 쿼리를 찾아보세요.  
- 더 이상 필요하지 않은 쿼리
- 너무 자주 실행되는 쿼리
- 너무 빠르게나 자주 재실행되는 쿼리
- 크거나 복잡한 쿼리 -- 단순화할 수 있는지 여부

코드가 ORM을 사용하거나 모든 종류의 데이터베이스 추상화를 사용하는 경우 기본값과 구성을 다시 확인해 보세요.  
한 가지 고려 사항은 일부 데이터베이스 라이브러리가 모든 쿼리 실행 후 경고를 확인하기 위해 `SHOW WARNING`을 실행한다는 것입니다.  
보통은 문제가 되지 않지만 상당한 낭비이기도 합니다.  
또한 드라이버 기본값, 구성과 릴리스 정보를 다시 확인해 보세요.  

애플리케이션이 실행하는 쿼리를 확인하기 위해 쿼리 프로파일을 사용하여 코드를 간접적으로 감사합니다.  
알 수 없는 쿼리는 애플리케이션 코드나 ORM과 같은 모든 종류의 데이터베이스 추상화에서 비롯될 수 있지만, Ops라는 또다른 가능성이 있습니다.  
Ops는 DBA, 클라우드 공급자 등 데이터 스토리지를 실행하고 유지 관리하는 사람을 말합니다.  

쿼리 감사를 더 쉽게 하려면 쿼리의 `/* SQL comments */`에 애플리케이션 메타데이터를 추가합니다.  

마지막으로 가장 간과하는 사항은 MySQL 오류 로그를 검토하는 것입니다.  
이러한 유형의 문제는 거의 없어야 하므로 무시해서는 안 됩니다.  


### 오프로드 읽기

기본적으로 소스라고 하는 단일 MySQL 인스턴스는 모든 읽기와 쓰기를 제공합니다.  
프로덕션 환경에서 소스에는 모든 쓰기를 복제하는 또 다른 MySQL 인스턴스인 복제본이 최소한 하나 이상 있어야 합니다.  

소스에서 읽기를 오프로드하여 성능을 향상시킬 수 있습니다.  

> 소스가 마스터를 의미하는 듯

이 기술은 MySQL 복제본이나 캐시 서버를 제공하여 읽기 작업을 처리합니다.  
첫째, 소스의 부하를 줄이고 나머지 쿼리를 더 빠르게 실행시켜 여유 시간과 시스템 리소스를 확보합니다.  
둘째, 읽기를 제공하는 복제본이나 캐시가 쓰기에 사용되지 않으므로 오프로드된 읽기에 대한 응답 시간이 향상됩니다.  

MySQL 복제와 캐시 쓰기에는 고유하고 피할 수 없는 지연이 있으므로 복제본이나 캐시에서 읽은 데이터는 현재 값으로 보장되지 않습니다.  
소스의 데이터만 최신 상태입니다.  

복제본이나 캐시가 오프라인 상태일 때 성능이 저하된 상태로 실행되도록 애플리케이션을 설계, 구현, 테스트하는 것이 필수입니다.  

따라서 느린 읽기를 오프로드하는 것부터 시작하세요.  




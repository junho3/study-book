# 4장 접근 패턴

**접근 패턴**은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.  
접근 패턴을 변경하면 MySQL 성능에 큰 영향을 미치지만, 일반적으로 다른 최적화보다 더 많은 노력이 필요합니다.  
QPS와 CPU 사용량과 같은 메트릭은 MySQL에 대해 거의 아무것도 알려주지 않습니다.  

의심의 여지 없이 MySQL은 애플리케이션에 대해 충분히 빠릅니다.  
진짜 질문은 애플리케이션이 MySQL을 효율적으로 사용하느냐는 것입니다.  


## 4-1 MySQL은 아무것도 하지 않는다

애플리케이션이 바쁘게 쿼리를 실행 중이면 MySQL도 바쁘게 해당 쿼리를 실행 중입니다.  
실제로 백그라운드 작업(페이지 플러싱)은 쿼리를 실행하는 포그라운드 작업을 허용하여 느린 작업을 지연하거나 방지함으로써 성능을 향상시킵니다.  
따라서 MySQL이 느리게 실행되는데 외부 문제가 없다면 원인은 MySQL을 구동하는 애플리케이션뿐입니다.  
MySQL은 애플리케이션이 사용자가 모르는 쿼리를 실행하지 않는 한 시스템에 고스트가 없습니다.  

쿼리는 다른 쿼리에 영향을 줍니다.  
이에 대한 일반적인 용어는 **쿼리 경합**입니다.
로우 락 경합, CPU 경합 등 특정 유형의 경합이 있습니다.  

MySQL은 로우 락 경합이라는 한 가지 유형의 경합만 보고하므로 쿼리 경합을 보거나 증명하는 것은 거의 불가능합니다.  
쿼리 경합은 교통 체증과 같습니다.  
쿼리 경합은 성능이 한계에 도달할 때 중요한 역할을 합니다.  


## 4-2 한계에 도달하면 성능이 불안정해진다

**선형 스케일링**  
부하가 증가함에 따라 데이터베이스 성능은 시스템 용량을 100% 사용할 때까지 증가한 다음, 성능이 일정하게 유지됩니다.  
선형 스케일링은 모든 DBA와 엔지니어의 이상이지만 실현될 수 없습니다.  

현실적으로 데이터베이스 성능의 한계는 시스템 용량의 80~95%입니다.  
부하가 한도를 초과하여 증가하면 데이터베이스 성능이 불안정해집니다.  

```
범용 확장성 법칙
X(N) = yN / 1 + a(N - 1) + BN(N - 1)
```

동시성(y)는 부하(N)이 증가함에 따라 처리량이 증가하는 데 도움이 됩니다.  
그러나 경합(a)와 일관성(B)은 부하가 증가함에 따라 처리량을 감소시킵니다.  
이는 선형 확장성을 불가능하게 하고 데이터베이스 성능을 제한합니다.  

성능을 제한하는 것보다 더 나쁜 일관성은 **역행 성능**을 유발합니다.  
즉, 높은 부하에서 성능이 감소합니다.  

운영 중단에는 3가지 기간이 있습니다.  

### 상승기(오전 6시~9시)

애플리케이션 개발자는 증가하는 수요에 대처하기 위해 트랜잭션 처리량을 늘렸습니다.  
MySQL이 한계에 다다를 때까지 상승과 응답이 반복되었고 결국 더이상 작동하지 않았습니다.  

### 한계점(오전 9시~정오)

실행 중인 스레드의 톱날 패턴은 MySQL이 불안정해졌음을 나타내는 신호였습니다.  
하나의 쿼리를 실행하는 데 하나의 스레드가 필요하므로 실행 중인 스레드의 큰 변동은 쿼리가 시스템을 통해 원활하게 흐르지 못한다는 것을 나타냅니다.  

높은 상태로 변함없는 CPU 사용량과 QPS는 오해의 소지가 있습니다.  
평평한 선을 그리는 메트릭은 하나의 연속적인 음을 매우 강하게 계속 연주하는 클라리넷 연주자에 비유됩니다.  
안정되지만 음악은 아닙니다.  

### 수정(정오~오후3시)

트랜잭션 처리량 증가는 그 자체로 소멸되었기 때문에 수정 사항은 트랜잭션 처리량을 줄이는 것이었습니다.  

더 일반적으로 높은 부하는 애플리케이션을 불안정하게 하여 MySQL에서 부하가 증가하는 것을 방지합니다.  
다시 말해, MySQL을 한계까지 밀어붙이기 전에 애플리케이션이 실패합니다.  

애플리케이션에 관심을 돌리기 전에 한계에 도달한 MySQL 성능에 대한 2가지 추가 사항은 다음과 같습니다.  

첫째, 일부러 부족한 하드웨어를 사용하지 않는 한 한계에 도달하기 어렵습니다.  
애플리케이션은 모든 하드웨어를 동시에 완전히 활용하기 훨씬 전에 하드웨어 한 부분에서 병목 현상을 일으킬 가능성이 가장 큽니다.  
이때 애플리케이션은 데이터베이스 성능의 한계에 도달한 것이 아니라 오직 해당 하드웨어의 한계에 도달한 것입니다.  

둘째, 높은 부하로 인해 MySQL이 느리게 응답한다고 해서 한계에 도달했다는 의미는 아닙니다.  
동시성(y)이 증가하면 한계가 증가하므로 느린 데이터베이스 성능이 한계에 도달했음을 의미하지는 않습니다.  
경합(a)을 줄이면 한계도 높아집니다.  


## 4-3 도요타와 페라리

일부 애플리케이션은 놀라운 MySQL 성능을 달성하지만 다른 애플리케이션은 낮은 처리량으로 어려움을 겪습니다.  

페라리는 도요타보다 110km/h 더 빠르게 만드는 특별한 부품이 없습니다.  
페라리의 독특한 외부 디자인은 화려하면서도 기능적입니다.  

고속과 마찬가지로 고성능은 억지 기법이나 무차별적으로 달성되는 것이 아닙니다.  
고성능을 목표로한 치밀한 설계의 산물입니다.  


## 4-4 데이터 접근 패턴

**데이터 접근 패턴**은 애플리케이션이 MySQL을 사용하여 데이터에 접근하는 방법입니다.  
접근 패턴에 대한 3가지 세부 정보를 명확히 하며 상황을 바꿔 보겠습니다.  

첫째, 접근 패턴을 복수형으로 논의하는 것이 너무 일반적이어서 서로 모호해지기 시작합니다.  
애플리케이션에는 많은 접근 패턴이 있습니다.  
편의상 복수형으로 논의되지만 실제로는 접근 패턴을 개별적으로 수정합니다.  

둘째, 접근 패턴은 궁극적으로 쿼리를 참조하며 여러분은 접근 패턴을 변경하기 위해 쿼리와 애플리케이션을 변경하지만 쿼리가 초점이 아닙니다.  
Go 프로그래밍 언어의 용어에서 접근 패턴은 '인터페이스'이고 쿼리는 '구현'입니다.  
구현이 아닌 인터페이스에 집중하세요.  
이 책에서는 접근 패턴 수정에 대해 설명하지만 실제로는 쿼리(그리고 애플리케이션)을 수정합니다.  

셋째, 접근 패턴은 이름과 기술적인 특성 목록으로 구성됩니다.  
이름은 접근 패턴을 식별하고 다른 엔지니어와 소통하는 데 사용됩니다.  
기술적인 특성 목록은 데이터 스토리지에 따라 다릅니다.  

> 쿼리 힌트(?) 쿼리가 로그에 기록될 때 id 같은걸 부여해달라는 DBA 요청이 있었음  

- 팀내 논의를 통해 가장 명백하고 일바적인 접근 패턴 식별
- 쿼리 보고를 사용하여 가장 느린 상위 접근 패턴 식별
- 덜 알려진(또는 잊혀진) 접근 패턴에 대한 코드 파악


### 읽기/쓰기

`SELECT`라는 읽기 접근은 명확합니다.  
`INSERT`, `UPDATE`, `DELETE`는 항상 쓰기 접근으로 간주합니다.  
`INSERT`와 `DELETE`는 내부적으로 다른 쓰기입니다.  

읽기 확장은 일반적으로 읽기를 오프로드하여 수행되며, 쓰기 확장은 더 어렵지만 쓰기를 대기열에 추가하는 것이 하나의 기술이며, 궁극적인 솔루션인 샤딩을 다룹니다.  
이 특성은 매우 간단하지만 애플리케이션이 읽기 중심인지 쓰기 중심인지 알면 신속하게 관련 애플리케이션 변경에 집중할 수 있어서 중요합니다.  
다른 데이터 스토리지는 읽기나 쓰기에 최적하되었으며, MySQL에는 쓰기에 최적화된 스토리지 엔진인 MyRocks가 있습니다.  

> Jpa 연관관계 맺을 때도 읽기 중심인지, 쓰기 중심인지에 따라 단방향 / 양방향 관계를 결정하곤 함  
> 개인적으로 쓰기 중심인 경우, 양방향으로 하여 Root 엔티티를 통해 영속성 전파하는 것을 선호  


### 처리량

처리량은 성능이 아닙니다.  
1QPS에 불과한 낮은 처리량의 접근만으로도 큰 피해를 줄 수 있습니다.  

> 수백 줄의 한 방 쿼리

테이블 스캔을 수행하고 모든 행을 잠그는 `SELECT ... FOR UPDATE` 문입니다.  

변동(QPS가 증가하고 감소하는 방식)도 똑같이 중요합니다.  
문제는 업무 시간에 QPS가 높아지면 개발자가 스키마 변경을 수행하거나 데이터를 재처리할 수 없다는 것입니다.  


### 데이터 수명

수명은 시간이 아니라 접근 순서에 상대적입니다.  
첫 번째 행은 10분이 지나서가 아니라 접근한 마지막 행이라서 가장 오래된 행입니다.  
첫 번째 행을 갱신하면 가장 최근에 접근한 행이므로 가장 최신 행이 됩니다.  

이 특성은 작업 세트에 영향을 미치기 때문에 중요합니다.  
MySQL은 될 수 있는 한 많은 데이터를 메모리에 보관하고, 데이터 수명은 메모리의 데이터가 작업 세트의 일부인지 아닌지에 대해 영향을 미칩니다.  
데이터에 접근하면 데이터가 메모리에 최신 상태로 바뀌어 유지되고, 이 데이터는 자주 접근되기 때문에 이 데이터를 포함하는 작업 세트는 메모리에 남게 됩니다.  

오래된 데이터에 자주 접근하는 것은 여러 면에서 문제가 됩니다.  
데이터는 **여유 페이지**(메모리 내)에 적재됩니다.  
사용할 수 있는 여유 페이지가 있을 때는 정상인데, 문제는 스토리지에서 데이터를 읽는 것은 속도가 느리다는 것뿐입니다.  
비정상으로 여유 페이지가 하나도 없다면 문제가 3배로 약화됩니다.  

1. MySQL은 가장 최근에 사용한 LRU 목록에서 추적하여 오래된 페이지를 제거해야 합니다.
2. 오래된 페이지가 더티일 때 MySQL은 이를 제거하기 전에 플러시해야 하는데, 플러시는 속도가 느립니다.
3. 스토리지에서 데이터를 읽는 속도가 느리다는 원래 문제가 남아 있습니다.

그림 4-4의 프로세스를 구동하는 알고리즘은 오래된 데이터에 가끔 접근하는 것이 새로운 데이터를 읽어오는 데 간섭하는 것을 방지합니다.  
따라서 데이터 수명과 처리량을 함께 고려해야 합니다.  
오래되고 느린 접근은 아마도 무해하지만 오래되고 빠른 접근은 문제를 일으킬 수 있습니다.  

데이터 수명을 측정하기가 거의 불가능합니다.  
오래된 데이터는 시간이 아니라 접근과 관련이 있다는 것을 기억하세요.  







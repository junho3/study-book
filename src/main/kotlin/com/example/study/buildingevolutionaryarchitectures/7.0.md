# CHAPTER 7 진화 가능한 아키텍처 구축

앞서 논의한 많은 개념은 새로운 아이디어라기보다 새로운 시각으로 바라본 오래된 아이디어라 할 수 있다.  
테스트는 오래전부터 존재했지만 아키텍처 검증과 피트니스 함수에 주목한 것은 근래의 일이다.  

> 최신 기술의 원리는 옛 개념의 바탕이라고 생각 함  
> 최근에 개념을 부여하고, 실체화한 것일 뿐  


## 7.1 진화적 아키텍처의 원리

### 7.1.1 책임이 따르는 마지막 순간

중요한 결정은 가능한 미루되, 더 이상 미룰 수 없는 시점을 넘기면 안 된다.  
성급하게 내린 결정은 과도한 엔지니어링을 낳고, 적시를 놓친 결정은 아키텍처가 지향하는 목표를 가로 막는다.  


### 7.1.2 진화성을 높이는 설계 및 개발

아키텍트는 진화성을 아키텍처의 최우선 목표로 여겨야 한다.  
이는 아키텍처 특성을 분석하는 객관적인 척도가 필요하다는 뜻이다.  

데이터 등의 외부 통합 지점, 즉 아키텍처 퀀텀의 정적 커플링 지점은 아키텍트가 가장 중요하게 여기는 설계 요소다.  
아키텍트는 데이트 의존성을 코드 의존성과 동일선상에 두고 취급해야 한다.  


### 7.1.3 포스텔의 법칙

자신의 것은 보수적으로 행하고, 다른 이의 것은 관대하게 받아들이도록 하라.  

#### 자신의 것은 보수적으로 하달하라

불필요하게 많은 정보를 전송하지 않도록 주의해야 한다.  

#### 다른 이의 것은 관대하게 수용하라

소비하는 것보다 많은 정보를 받아들여도 좋다.  
추가 데이터가 있다 해도 꼭 필요한 정보만 사용하면 된다.  

#### 계약을 해제할 때는 버전을 관리하라

자동화된 소비자 주도 계약은 통합 아키텍처에서 중요한 역할을 한다.  


### 7.1.4 테스트성과 아키텍트

테스트하기 용이한 아키텍처의 대표적인 특성은 단일 책임 원칙 준수다.  
우수한 시스템은 각 부분이 저마다 하나의 책임을 가진다.  

> SRP는 코드에만 적용되는 개념인줄 알았으나, 컬리 때 시니어 개발자분이 SRP는 시스템에도 적용해야한다는 얘기를 듣고 띠용했던 기억이 있음  


### 7.1.5 콘웨이의 법칙

진화적 아키텍처를 구축하려면 팀 구조 또한 주의 깊게 살펴야 한다.  


## 7.2 역학

### 7.2.1 진화의 영향을 받는 차원 식별

아키텍트는 아키텍처가 진화하는 동안 보호해야 할 아키텍처 차원을 식별해야 한다.  
- 아키텍처의 기술적 특성
- 데이터 설계
- 보안
- 확장성


### 7.2.2 각 차원의 피트니스 함수 정의

코드베이스와 관련된 이러한 아키텍처 특성을 관리하기 위해, 아키텍트는 다양한 코드 메트릭을 배포 파이프라인에서 활용한다.  
아키텍트는 지속적으로 관리할 차원을 선별하고 위키 등의 간단한 양식을 이용해 문서화한다.  
각 차원의 진화 과정에 드러나는 불필요한 행동을 식별한 다음 최종적으로 피트니스 함수를 정의한다.  


### 7.2.3 배포 파이프라인을 이용한 피트니스 함수 자동화

아키텍트는 프로젝트의 변화가 증분 변경으로 진행되도록 장려해야 한다.  
증분 변경은 배포 파이프라인에서 피트니스 함수를 통해 선제적으로 검증할 수 있으며, 배포 등의 일상 작업이 시야에서 사라질 만큼 높은 수준의 자동화를 가능하게 한다.  
진화적 아키텍처 프로젝트에 참여한 개발자는 적절한 순환 주기를 유지해야 할 의무가 있다.  
순환 주기가 길어지면 프로젝트가 새로운 세대를 등장시키는 속도가 둔화되며 진화성을 저해하는 요인이 된다.  

소프트웨어는 항상 알려지지 않은 미지의 문제에 시달린다.  
아키텍트는 비기능적 요구 사항이 처리되는 현황과 장애를 주시하고 피트니스 함수로 아키텍처를 개선하며 미래의 문제를 방지해야 한다.  


## 7.3 그린필드 프로젝트

신규 프로젝트에 진화성을 구축하는 것은 기존 프로젝트를 개조하는 것보다 훨씬 쉽다.  


## 7.4 기존 아키텍처 개조

기존 아키텍처에 진화성을 더하는 세 가지 조건
- 컴포넌트 커플링
- 엔지니어링 실무 성숙도
- 개발자의 피트니스 함수 제작 용이성


### 7.4.1 커플링과 응집도

아키텍트는 기술적 커플링뿐만 아니라 시스템 컴포넌트의 기능적 응집도를 방어해야 한다.  
응집도를 방어한다는 것은 컴포넌트를 분해하면 안 된다는 뜻이 아니라, 컴포넌트의 크기를 문제 콘텍스트에 적합하게 유지한다는 뜻이다.  

많은 기업은 과거와 현재의 관행이 혼재하는 과도기에 머물러 있다.  
지속적 통합처럼 비교적 가까이 있는 목표는 손쉽게 달성했으나 여전히 모든 테스트를 수동으로 실행하는 기업도 많다.  
애플리케이션 빌드 단계를 파이프라인 진행 단계와 일치시키고, 배포 과정을 점진적으로 자동화시킨다.  

> 대부분 CI, CD는 잘 구축되있을거라 생각 함  
> 배포 신청서를 작성하고, 물리적인 승인을 받는 프로세스는 여전히 수동적이며, 이로인해 외주에서 개발한 것을 배포 대행하는건 힘든 경험이 있었음  

#### 리팩토링 vs 재구성

리팩토링은 외부로 드러나는 행동을 그대로 둔 채 기존 컴퓨터 코드를 재구성하는 프로세스다.  
아키텍처는 재구성을 통해 구조와 행동 모두에 실질적인 변화를 일으키는 경우가 많다.  

> 리팩토링 과정에서 테스트 코드가 수정되면 안됨


### 7.4.2 상용 소프트웨어(COTS)

#### 증분 변경

대부분의 상용 소프트웨어는 자동화 및 테스트 수준이 업계 표준에 크게 못 미친다.  


#### 적정 커플링

커플링 측면에서 바라본 패키지 소프트웨어는 만악의 근원이다.  
패키지 시스템은 일반적으로 내부를 확인할 수 없으며 개발자는 사전에 정의된 API를 이용해 시스템을 통합한다.  


#### 피트니스 함수

피트니스 함수를 추가하기 어렵다는 점은 패키지 소프트웨어의 진화성을 가로막는 큰 장애물일 것이다.  

> 카카오페이손해보험도 녹취, 알림톡 발송 등을 솔루션으로 사용하고 있음  
> 빠르게 도입할 수 있는 장점이 있지만, 문제가 발생하면 대응이 어려움  


## 7.5 아키텍처 마이그레이션

아키텍처를 바라보는 관점과 사고는 도메인 중심으로 재편된다.  

트랜잭션 커플링은 클래스 커플링과 마찬가지로 실재하는 장애물이며 아키텍처 재구성 과정에서 근절하기 어려운 요소다.  

> 업무를 다시 분석할 필요도 있다고 생각 함  
> 레거시 시스템은 업무 분석이 잘 되지 않아 하나의 트랜잭션으로 묶어두는 경우가 빈번하지만, 트랜잭션을 분리해도 되는 경우도 있었음  
> 아니면 시간이 흐름에 따라 업무가 바뀔 수 있으므로, 분리된 트랜잭션으로 업무를 재정의하는 것도 하나의 방법이라고 생각 함  

대부분 개발자는 프레임워크를 사용해 쓸모 있는 것을 만들기보다 프레임워크를 직접 만드는 것을 더 선호한다.  

> 이해가 안됨  

시니어 개발자들이 다른 개발자가 사용할 인프라를 직접 만들기 시작한다.  

> 지인의 동료는 원래 C#개발자이고, 능력도 훌륭함  
> Java개발자로 포지션을 변환하면서 필요한 라이브러리를 직접 만들었다고 함  
> 이유는 Java 라이브러리를 믿지 못 해서  


### 7.5.1 마이그레이션 단계

코드베이스를 해체하는 첫 단계는 코드 베이스를 이루는 요소가 결합되는 방식을 이해하는 것이다.  

> 레거시 시스템의 코드를 분석하는건 매우 어려운 일  
> 카카오페이손해보험에서도 기간계 코드 분석을 시도했으나, 데드 코드가 많아서 실패함  
> 그래서 어떠한 비즈니스 액션에 대한 결과(DB, API 응답 데이터)만 파악하여 재구성함
> 물론, 트래픽이 많지 않고, 영향도가 적어서 시도할 수 있는 방법이라고 생각함  

아키텍트는 이러한 마이그레이션을 수행하는 이유를 설명할 수 있어야 한다.  

> 인프런 아키텍처 2023 ~ 2024 | 인프콘2023 https://youtu.be/Ty9DDg1_5Pw  
> 단순히 특정 아키텍처가 선호하기보다 현재 조직 상황에 맞게 아키텍처를 변경한 내용이 인상 깊었음  

모놀리식 아키텍처를 분해할 때는 적정 수준의 서비스 세분성을 가늠하는 것이 중요하다.  
컴포넌트를 지나치게 세분화시키면 과도한 오케스트레이션, 통신 오버헤드, 컴포넌트 상화 의존성 등의 문제가 발생한다.  


#### 비즈니스 기능 그룹

#### 트랜잭션 경계

#### 배포 목표


### 7.5.2 모듈 상호작용의 진화

공유 모듈과 컴포넌트는 마이그레이션 과정에서 개발자가 자주 마주치는 장애물이다.  

Chidamber & Kemerer 메트릭 스위트는 모듈의 분할 가능 여부나 LCOM 적용 여부를 판단할 수 있는 유용한 메트릭을 포함한다.  

LCOM은 아키텍처 마이그레이션을 앞둔 아키텍트에게 유용한 메트릭이다.  
모놀리스를 해체하면 아키텍트는 무제 도메인을 어떻게 분할할지 비교적 쉽게 결정할 수 있다.  
LCOM 점수가 낮으면 아키텍트는 클래스 분리가 아닌 다른 접근 방식을 선택해야 한다.  

공유는 커플링의 일종이며 마이크로서비스 아키텍처에서 사용하도록 권장되지는 않는다.  
공유 라이브러리의 대안이자 두 번째 선택지는 복제다.

서비스 디스커버리는 서비스가 서로를 찾고 호출할 수 있는 기능이다.  
디스커버리 메커니즘을 초기에 구축하면 시스템을 부분적으로 서서히 마이그레이션할 수 있다.  

애플리케이션을 안일하게 분할하면 자칫 심각한 성능 문제가 발생할 위험성이 있기 때문이다.  
모놀리식 아키텍처는 트랜잭션 경계, 구조적 커플링 등의 내재적 특성을 고려해 개별 서비스로 분해해야 한다.  

개발자는 피트니스 함수를 구축하고, 신규 통합 지점이 변경되지 않도록 소비자 주도 계약을 추가해 보호해야 한다.  


## 7.6 진화적 아키텍처 구축 가이드라인

진화는 핵심 메커니즘을 전체적으로 교체하기보다 새로운 계층을 쌓아 올리는 방식으로 진행된다.  

모두가 깨끗하고 이상적인 환경을 전제로 아키텍처를 논할 수 있다면 좋겠지만 실제 세계는 기술 부채, 이해 충돌, 한정된 예산 등의 문제로 혼란스럽다.  

기존 아키텍처를 개조해 진화성을 구축하는 것은 일종의 도전에 가깝다.

> 카카오페이손해보험에 합류하자마자 재무 영역을 MSA로 분리한 도박은 성공했다고 생각 함  
> 조금만 늦었더라도 쉽지 않았을 듯  

### 7.6.1 불필요한 변동성 제거

현대의 데브옵스는 눈송이 인프라를 불변 인프라로 대체하는 방식으로 동적 균형 문제를 해결했다.  
눈송이 인프라는 운영자가 손수 제작한 자산이며, 향후 모든 유지 관리 작업이 수작업일 것임을 나타내는 선언이다.  
불변 인프라는 완벽하게 프로그래밍 방식으로 정의된 시스템을 뜻한다.  

불변 개발 환경을 구축하면 유용한 도구를 프로젝트 전체로 전파할 수 있다.  

#### 눈송이의 함정

### 7.6.2 결정과 번복

공격적으로 진화하는 시스템은 필연적으로 언젠가 예상치 못한 방식으로 실패할 수밖에 없다.  
블루/그린 배포는 동일한 생태계를 두 번 만드는 방식으로 배포 환경을 구성한다.  

> 컨슈머는 블루/그린이 적합하지 않음  
> API서비스는 앞단에서 트래픽을 제어할 수 있지만, 카프카 컨슈머는 어플리케이션이 올라가면 토픽에 바로 붙기 때문  
> 제어할 수 있는 방법이 있겠지만, 아직까지는 어떻게 제어해야할 지 모르겠음  

기능 토글 또한 개발자의 결정을 되돌릴 수 있는 수단이다.  

> 당근페이 - 매일 배포하는 팀이 되는 여정(2) — Feature Toggle 활용하기  
> https://medium.com/daangn/%EB%A7%A4%EC%9D%BC-%EB%B0%B0%ED%8F%AC%ED%95%98%EB%8A%94-%ED%8C%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%97%AC%EC%A0%95-2-feature-toggle-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-b52c4a1810cd  


### 7.6.3 예측성과 진화성

알려지지 않은 미지는 소프트웨어 시스템의 천적이다.  
변화로부터 자신을 격리하기 위해 개발자가 구축하는 일반적인 보호 장치는 손상방지 계층이다.  

> 기술 서적인데, 문과적인 문장이 많음  
> 표현이 독특해서 좋음  


### 7.6.4 손상방지 계층 구축

기술 부채란 프로젝트의 일부이며, 프로젝트에 있어서는 안될 것인 동시에, 있어야 할 것의 자리를 차지하고 있는 무언가를 뜻한다.  

> 우아한형제들에서 시니어 개발자로 일하면 어떨까? – 피트스탑  
> https://techblog.woowahan.com/12292/  
> 
> 지금 팀에서도 분기별 기술부채 에픽을 생성해서 관리하고 있음  

인터페이스와 손상방지 계층을 제 위치에 배치한 덕분에, 일부 기능을 교체하는 작업이 기계적인 단순 업무로 그칠 수 있었다.  


### 7.6.5 희생적 아키텍처 구축

일단 시스템을 구축하면 그전까지 몰랐던 미지의 문제를 파악할 수 있으며 처음에는 불확실했던 아키텍처 결정을 내릴 수 있게 된다는 것이다.  
이베이는 시스템을 여러 번 재 설계했음에도 불구하고 엄청난 성공을 거두었다.  

만일 트위터 엔지니어가 출시 전부터 최종적이고 견고한 플랫폼을 구축했다면 제때 시장에 진출하지 못 했을 것이다.  

희생적 아키텍처는 클라우드 환경과 결합하면 더욱 매력적이다.  

경영진은 멀쩡한 코드를 제거핟나는 계획을 좀처럼 달가워하지 않는다.  

기술 부채는 부적절한 커플링을 한층 악화시킨다.  


### 7.6.6 외부 변화 경감

서드파티 코드는 중대한 변화가 갑자기 발생하거나 사전 공지 없이 일부분이 제거될 위험이 있다.  

개발자는 불확실성이라는 토대 위에 반복적인 엔지니어링 관행을 수립해서는 안 된다.  
서드파티가 핵심 의존성을 변경하도록 허용하는 것은 이러한 윈칙에 위배된다.  

> 서드 파티 소나큐브 때문에 프로젝트의 소스코드 또는 구조를 수정하는게 맞는가?  

#### 인터넷을 무너뜨린 11줄의 코드


### 7.6.7 라이브러리 vs 프레임워크

아키텍트는 라이브러리와 프레임워크를 구분해서 바라보는 경향이 있다.  


### 7.6.8 서비스 버전 내재화

모든 통합 아키텍처의 서비스 엔드포인트는 행동의 변화가 생길 때마다 반드시 버전을 지정해야 한다.  


### 7.6.9 사례연구 PenultimateWidgets 별점 서비스의 진화


## 7.7 피트니스 함수 주도 아키텍처

트랜잭션 속도를 측정하는 피트니스 함수를 제일 먼저 구축하고, 극단적인 목표를 달성하기 위한 실험적인 설계에 착수했다.  


### 요약

진화성을 구축하고자 하는 아키텍트는 피트니스 함수와 아키텍처 구조가 서로 협력하도록 만들어야 한다.  

도메인과 기술의 다양한 변화를 견디는 시스템을 구축하려면 피트니스 함수를 구축하고 계약을 통해 커플링을 제어해야 한다.  



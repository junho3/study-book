# 16 뉴스 피드 설계

시간 역순으로 정렬된 뉴스 항목 목록을 사용자에게 제공하는 뉴스 피드를 설계한다.  

## 16.1 요구사항

- 뉴스 항목은 시간의 역순으로 정렬돼야 하지만 이는 근사치일 수 있다.
- 뉴스 항목의 구성 요소
  - 150자 제한의 제목과 10,000자 제한의 본문
  - 생성된 시간으 나타내는 유닉스 타임스탬프
  - 오디오, 이미지, 동영상 고려하지 않음
- 기사는 여러 버전을 가질 수 있지만, 버전 관리는 고려하지 않는다.
- 일일 활성 사용자 10만 명이 하루 평균 10회씩 요청을 하고, 100만 개의 뉴스 항목을 처리할 수 있어야 한다.
  - 10만 x 10 / 24 / 60 / 60 = 11.6tps
- 읽기 작업의 P99 1초 이내
- 최대 몇 시간의 최종 일관성 허용
- 쓰기 작업의 고가용성 필요
- 읽기 작업의 고가용성은 필수는 아니다. 사용자가 오래된 뉴스를 자신의 기기에 캐시할 수 있기 때문이다.


## 16.2 상위 수준 아키텍처

뉴스 항목의 출처에서 백엔드의 수집 서비스로 뉴스 항목을 제출하면 이것이 데이터베이스에 기록된다.  
사용자는 뉴스 피드 서비스에 쿼리하고, 이 서비스는 데이터베이스에서 뉴스 항목을 가져와 사용자에게 반환한다.  

- 수집 서비스는 고가용성을 갖추고 무겁고 예측 불가능한 트래픽을 처리해야 한다. 
  - 카프카 같은 이벤트 스트리밍 플랫폼 사용을 고려해야 한다.
- 데이터베이스는 모든 항목을 보관해야 하지만 사용자에게는 최대 1,000개의 항목만 제공해야 한다.
  - 모든 항목을 보관하는 데이터베이스와 필요한 항목을 제공하는 다른 데이터베이스를 사용할 수 있음을 시시한다.
  - 1000개의 항목과 100개 태그에 해당하는 전체 뉴스 콘텐츠의 크기는 약 1GB로, 레디스 캐시에 쉽게 들어갈 수 있다.
  - 보관용으로는 HDFS 같은 분산 샤딩 파일 시스템을 사용할 수 있다.

수집기는 뉴스 항목만으로 수행할 수 있는 유효성 검사 작업을 수행한다.  

- SQL 인젝션
- 부적절한 언어 / 콘텐츠

소비자는 큐에서 폴링행 HDFS에 기록한다.  
최소한 두 개의 HDFS 테이블이 필요하다.  
하나는 소비자가 제출한 원시 뉴스 항목용이고, 기타 하나는 사용자에게 제공할 준비가 된 뉴스 항목용이다.  
이러한 HDFS 테이블은 태그와 시간으로 분할된다.  

사용자는 API 게이트웨이에 요청을 보내고, 이는 메타데이터 서비스에서 사용자의 태그를 쿼리한 다음 백엔드 서비스를 통해 레디스 캐시에서 적절한 뉴스 항목을 쿼리한다.  
레디스 캐시 키는 (tag, hour) 튜플이 될 수 있고, 값은 해당하는 뉴스 항목 목록이 될 수 있다.  

사용자가 이전 요청 후 한 시간 이내에 업데이트를 요청하면 다음 두 가지 접근 방식 중 하나 이상을 통해 서비스 부하를 줄일 수 있다.  

- 기기에서 요청을 무시한다.
- 기기에서 요청을 하지만 응답이 504 시간 초과이면 재시도 하지 않는다.


## 16.3 사전에 피드 준비하기

사용자의 피드를 사전에 준비함으로써 더 많은 저장 공간을 사용하는 대신 낮은 지연 시간 및 트래픽을 얻을 수 있다.  
{user ID, post ID}와 {post ID, post}의 두 해시맵을 준비할 수 있다.  
각각 1K, 10K 문자 항목을 가진 100개의 태그를 가정하면, 후자의 해시맵은 1GB를 약간 넘는 공간을 차지한다.  
전자의 해시맵에서는, 10억 개의 사용자 ID와 최대 100 * 1000개의 게시물 ID를 저장해야 한다.  
총 저장 공간 요구사항은 최대 800TB로, 레디스 클러스터의 용량을 초과할 수 있다.  

> 사용자 ID 10억 개는 갑자기 어떻게 등장한건지?

한 가지 해결책은 사용자를 지역별로 분할하고 데이터 센터당 두 세개의 지역만 저장하는 것이다.  

다른 해결책은 몇 십 개의 게시물 ID로 제한해 저장 공간 요구사항을 제한하는 것이지만, 이는 1,000개 항목 요구사항을 충족하지 못 한다.  

또 다른 해결책은 {user ID, post ID} 쌍에 샤딩된 SQL 구현을 사용하는 것이다.  
이 테이블을 해싱된 사용자 ID로 샤딩할 수 있어 사용자 ID가 노드 간에 무작위로 분산되고 핫 샤드 문제를 방지할 것이다.  

클러스터 간 트래픽이 불균등할 것이므로 분할의 수와 크기를 조정해 트래픽의 균형을 맞출 수 있다.  

유일한 클라이너트가 모바일 앱이라면 클라이언트에 게시물을 저장해 저장 공간을 절약할 수 있다.  

또 다른 방법은 타임스탬프 열을 추가하고 24시간보다 오래된 행을 주기적으로 삭제하는 ETL 작업을 하는 것이다.  

사용자가 모바일 앱을 열면 준비된 피드를 사용해 게시물에 첫 번째 요청만 처리하고 단일 노드에 맞는 수의 게시물 ID만 저장할 수 있다.  
사용자가 아래로 스크롤하면 앱이 더 많은 게시물을 요청할 수 있고, 이러한 요청은 레디스에서 처리될 수 있다.  

이 접근 방식은 더 낮은 지연 시간과 비용을 위해 더 높은 복잡성과 유지보수 부담을 트레이드오프한다.  





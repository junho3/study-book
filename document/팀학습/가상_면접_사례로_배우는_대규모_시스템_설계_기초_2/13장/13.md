# 13장 증권 거래소

## 1단계 문제 이해 및 설계 범위 확정

- 주식만 거래
- 새 주문을 넣을 수 있고, 채결되지 않은 주문은 취소할 수 있어야 함  
- 지정가 주문만 가능
- 시간 내 거래만 가능
- 호가 창의 정보는 실시간으로 갱신되어야 함
- 최소 수만 명 사용자가 동시에 거래할 수 있어야 함
- 100가지 주식 거래가 가능해야 함
- 거래소는 규제 시설이므로 위험성 점검이 가능해야 함
  - 특정 주식에 대한 조건을 위반하는 거래는 불가능
- 아직 체결되지 않은 주문이 있는 경우, 해당 주문에 이요된 자금은 다른 주문에 사용 불가

### 비기능 요구사항

- 가용성: 최소 99.99%
- 결함 내성
- 지연 시간: 왕복 지연 시간은 밀리초 수준이어야 하며, 특히 p99 지연 시간이 중요하다.  
- 보안

### 개략적 규모 추정

QPS: 10억(하루 주문 양) / 6.5시간(거래소 영업시간) x 3600 = 43,000
최대 QPS : 43,000 x 5 = 215,000 (장 시작 직후, 마감 직전에 거래량이 몰림)

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 증권 거래 101

#### 브로커

#### 기관 고객

#### 지정가 주문

#### 시장가 주문

#### 시장 데이터 수준

#### 봉 차트

#### FIX

금융 정보 교환 포로토콜


### 개략적 설계안

#### 거래 흐름은 지연 시간 요건이 엄격한 중요 경로다.  

1. 고객이 브로커를 통해 주문
2. 브로커가 주문을 거래소에 전송
3. 주문이 클라이언트 게이트웨이를 통해 거래소로 진입
4. 위험성 점검
5. 지갑에 주문 처리 자금이 충분한지 확인
6. 주문이 체결 엔진으로 전송
   - 매수 측과 매도 측에 각각 하나씩 총 두 개의 집행 기록 생성
   - 시퀀서는 주문 및 집행 기록을 일정 순서로 정렬
7. 주문 진햅 사실을 클라이언트에 전송

#### 시장 데이터 흐름

1. 체결 엔진은 주문이 체결되면 스트림을 만들고, 시장 데이터 게시 서비스로 전송
2. 시장 데이터 게시 서비스는 스트림 데이터로 봉 차트와 호가 창 구성
3. 시장 데이터는 실시간 분석 전용 스토리지에 저장
4. 브로커는 데이터 서비스를 통해 실시간 시장 데이터 조회 및 고객에게 전달

#### 보고 흐름

1. 보고 서비스는 주문 및 실행 기록에서 필요한 모든 값을 수집
2. 수집한 값을 정리하여 데이터베이스에 기록


### 거래 흐름

#### 체결 엔진

1. 각 주식에 대한 주문서와 호가 창을 유지 및 관리
2. 매수 주문과 매도 주문 연결
3. 집행 기록 스트림을 시장 데이터로 배포

가용성 높은 체결 엔진 구현체가 만드는 체결 순서는 결정론적이어야 한다.  
입력으로 주어지는 주문 순서가 같으면 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 한다.  

#### 시퀀서

시퀀서는 체결 엔진에 주문을 전달하기 전에 순서 ID를 붙여 보낸다.  
체결 엔진이 처리를 끝낸 모든 집행 기록 쌍에도 순서 ID를 붙인다.  
입력 시퀀서와 출력 시퀀서 두 가지가 있으며, 각각 고유한 순서를 유지한다.  

입력되는 주문과 출력하는 실행 명령에 순서 ID를 찍는 이유
1. 시의성 및 공정성
2. 빠른 복구 및 재생
3. 정확한 1회 실행 보증

시퀀서는 순서 ID만 생성하는 것이 아니며, 메시지 큐 역할도 한다.

##### 주문 관리자

주문 관리자는 한쪽에서는 주문을 받고 다른 쪽에서는 집행 기록을 받는다.  
주문 상태를 관리한다.  

- 위험성 검토
- 거래에 필요한 자금 확인
- 주문을 시퀀서에 전달

주문 관리자는 빠르고 효율적이며 정확해야 한다.  
다양한 상태 변화를 관리해야 하는 문제 때문에 주문 관리자의 구현은 아주 복잡하다.  
이벤트 소싱은 주문 관리자 설계에 적합하다.  

##### 클라이언트 게이트웨이

- 인증
- 유효성 검사
- 처리율 제한
- 정규화
- FIXT 지원

지연 시간에 민감하고, 가벼워야 한다.  
고객 유형별(개인/기관)로 클라이언트 게이트웨이는 다양하다.  
주요 고려 사항은 지연 시간, 거래량, 보안 요구사항이다.  

##### 시장 데이터 흐름

체결 엔진에서 집행 기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.  

##### 보고 흐름

- 거래 이력
- 세금 보고
- 규정 준수 여부 보고
- 결산

입력으로 들어오는 주문과 결과로 나가는 집행 기록을 잘 병합하여 보고서를 만든다.  


### API 설계

#### 주문

요청  
price: 지정가 주문의 가격. 자료형 Long

> 무조건 정수인지?

응답  
creationTime: 주문이 시스템에 생성된 시간. 자료형 Long

> Date, String 타입이 아니라 Long 타입인 이유가 있는지?

#### 집행

price: 체결 가격 자료형 String

> 요청에서는 Long, 집행에서는 String 무슨 차이인지?  
> 요청에서는 orderId가 String, 응답에서는 Long?

#### 호가 창/주문서

#### 가격 변동 이력(봉 차트)


### 데이터 모델

#### 상품, 주문, 집행

이 데이터는 자주 변경되지 않는다.  
아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기 좋다.  

중요 거래 경로는 주문과 집행 기록을 데이터베이스에 저장하지 않는다.  
성능을 높이기 위해서 메모리에서 거래를 체결하고 하드디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장하고 공유한다.  
주문과 집행 기록은 빠른 복구를 위해 시퀀서에 저장하며, 데이터 보관은 장 마감 후에 실행한다.  

#### 호가 창

- 일정한 조회 시간
- 빠른 추가/취소/실행 속도
  - 가급적 O(1) 시간 복잡도를 만족해야 한다.
- 빠른 업데이트
- 최고 매수 호가 / 최저 매도 호가 질의
- 가격 수준 순회

이중 연결 리스트를 사용하여 모든 삭제 연산이 O(1)에 처리되도록 해야 한다.  

새 주문을 넣는다는 것은 리스트 마지막에 새 주문을 추가하는 것을 의미한다.  
이중 연결 리스트에서 이 연산은 O(1)에 처리된다.  

재문을 체결한다는 것은 리스트의 맨 앞에 있는 주문을 삭제한다는 것과 같다.  
이중 연결 리스트의 경우 이 연산의 시간 복잡도는 O(1)이다.  

주문을 취소한다는 것은 호가 창에서 주문을 삭제한다는 뜻이다.  
Map<OrderId, Order> 구조에서 O(1) 시간 내에 취소할 주문을 찾을 수 있다.  

```
{
    "Order1" => {},
    "Order2" => {},
}
```

#### 봉 차트

봉 차트에서 많은 종목의 가격 이력을 다양한 시간 간격을 사용해 추적하려면 메모리가 많이 필요하다.  

1. 미리 메모리를 할당해 둔 링 버퍼에 봉을 보관하면 새 객체 할당 횟수를 줄일 수 있다.
2. 메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.

시장 데이터는 일반적으로 실시간 분석을 위해 메모리 상주 컬럼형 데이터베이스에 둔다.  


## 3단계: 상세 설계

### 성능

평균 지연 시간은 낮아야 하고, 전반적인 지연 시간 분포는 안정적이어야 한다.  

지연 시간을 줄이는 방법에는 두 가지가 있다.  
1. 중요 경로에서 실행할 작업 수를 줄인다.  
2. 각 작업의 소요 시간을 줄인다.
   1. 네트워크 및 디스크 사용량 경감
   2. 각 작업의 실행 시간 경감

중요 경로에는 꼭 필요한 구성 요소만 둔다.  
로깅도 지연 시간을 줄이기 위해 중요 경로에서는 뺀다.  

경쟁에서 앞서 나가기 위해 거래소는 주로 네트워크 및 디스크 액세스 지연 시간을 줄이거나 없애는 방안을 통해 중요 경로의 단대단 지연 시간을 수십 마이크로초로 줄였다.  
오랜 시간 동안 검증된 그 설계안의 요체는, 모든 것을 동일한 서버에 배치하여 네트워크를 통하는 구간을 없애는 것이다.  
같은 서버 내 컴포넌트 간 통신은 이벤트 저장소인 mmap를 통한다.  

> 모놀리틱을 의미하는 것인지?

애플리케이션 루프의 주된 작업 실행 메커니즘은 while 순환문을 통해 실행할 작업을 계속 폴링하는 것이다.  
엄격한 지연 시간 요건을 만족하려면 목적 달성에 가장 중요한 작업만 이 순환문 안에서 처리해야 한다.  
이 메커니즘의 목표는 각 구성 요소의 실행 시간을 줄여 전체적인 실행 시간 예측 가능하도록(p99) 보장하는 것이다.  

CPU 효율성을 극대화하기 위해 애플리케이션 루프는 단일 스레드로 구현하며, 특정 CPU 코어에 고정시킨다.  
애플리케이션 루프를 CPU에 고정하면 상당한 이점이 있다.

1. 컨텍스트 스위치가 없다.
2. 상태를 업데이트하는 스레드가 하나뿐이라서 락을 사용할 필요가 없고 잠금 경합도 없다.  

> 스레드를 유지시켜서 생성/삭제 비용도 줄인걸로 이해함  
> 옵저버 패턴 방식으로 while문을 돌면서 루프에 명령이 들어왔는지 판단하는 듯  

CPU를 고정하는 방안의 단점은 코딩이 더 복잡해진다는 것이다.  
엔지니어는 각 작업이 애플리케이션 루프 스레드를 너무 오래 점유하지 않도록 각 작업에 걸리는 시간을 신중하게 분석해야 한다.  

mmap는 파일을 프로세스의 메모리에 매핑하는 mmap(2)라는 이름의 POSIX 호환 UNIX 시스템 콜을 일컫는다.  
mmap(2)는 프로세스 간 고성능 메모리 공유 메커니즘을 제공한다.  
mmap(2)를 수행하면 공유 메모리에 접근해도 디스크 I/O는 발생하지 않는다.  

서버에서 mmap(2)를 사용하여 중요 경로에 놓인 구성 요소가 서로 통신할 때 이용할 메시지 버스를 구현하는 것이다.  
이 통신 경로를 사용하면 네트워크나 디스크에 접근하는 일은 없으며, 메시지 전송에 마이크로 초 미만이 걸린다.  

#### 이벤트 소싱

이벤트 소싱 아키텍처는 현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한 로그를 유지한다.  
이 로그를 절대적 진실의 원천으로 삼는 것이다.  

모든 이벤트를 순서대로 재생하면 주문 상태를 복구할 수 있다.  





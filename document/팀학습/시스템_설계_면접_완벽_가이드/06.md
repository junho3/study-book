# 06 기능적 분할을 위한 공통 서비스

## 6.1 다양한 서비스의 공통 기능

엔지니어가 각 서비스에 기능을 별도로 구현하면 작업이나 코드의 중복이 발생할 수 있다.  
부족한 엔지니어링 리소스가 더 많은 작업에 분산되므로 오류나 비효율성이 발생할 가능성이 높다.  

- 라이브러리
  - 라이브러리 업데이트를 하지 않으면 버그나 보안 문제가 있는 버전을 계속 실행하는 문제
  - 서비스를 실행하는 각 호스트도 라이브러리를 실행하므로 다른 기능을 독립적으로 확장하기 어려움
- API 게이트웨이
  - 여러 데이터 센터에 위치한 상태 비저장 경량 웹 서비스
  - 다른 프로그래밍 언어 가능
  - 가능한 단순해야 함

### 6.1.1 보안

- 인증
- 인가
- SSL 종료
- 서버 사이드 데이터 암호화


### 6.1.2 오류 검사

- 요청 유효성 검사
- 요청 중복 제거


### 6.1.3 성능과 가용성

- 캐싱
- 속도 제한, 스로틀링
- 요청 디스패칭
  - 벌크헤드
  - 서킷 브레이커


### 6.1.4 로깅과 분석


## 6.2 서비스 메시 / 사이드카 패턴

- 컨트롤 플레인
  - 프록시 구성
  - 외부 서비스와의 인터페이스
- 데이터 플레인
  - 파드
    - 엔보이 프록시 호스트
    - 서비스 호스트
- 관창 가능성 플레인
  - ELK
  - 분산 추적 (Zipkin, opentracing)
  - 프로메테우스

관리자는 컨트롤 플레인을 사용해 프록시를 관리하고 외부 서비스와 인터페이스할 수 있다.  

- 인증 기관에 연결해 인증서 얻기
- ID와 접근 제어 서비스에 연결해 환경 구성 관리
- 인증서 ID나 ID 접근 제어 서비스 구성을 프록시 호스트로 푸시


## 6.3 메타데이터 서비스

메타데이터 서비스는 시스템 내의 여러 구성 요소가 사용하는 정보를 저장한다.  
구성 요소들이 서로 정보를 전달할 때, 전체 데이터를 직접 넘기기보다 ID만 전달할 수 있다.  
ID를 받은 구성 요소는 메타데이터 서비스에 해당 ID에 대응하는 정보를 요청할 수 있다.  

컨슈머가 메시지를 소비할 때 해당 ID에 대응하는 HTML 파일을 메타데이터 서비스에 요청할 수 있다.  

메타데이터 서비스는 ID 조회를 위한 것이다.  


## 6.4 서비스 디스커버리

서비스 디스커버리는 클라이언트가 사용 가능한 서비스 호스트를 식별하는 방법이다.  
서비스 레지스트리는 서비스의 사용 가능한 호스트를 추적하는 데이터베이스다.  

- Spring CloudEurake
- k8s


## 6.5 기능적 분할과 다양한 프레임워크

### 6.5.1 앱의 기본 시스템 설계

### 6.5.2 웹 서버 앱의 목적

브라우저가 백엔드에 직접 요청하지 않는 이유는 무엇인가?  
백엔드가 REST 앱이라면 그 API 엔드포인트가 브라우저가 필요로 하는 정확한 데이터를 반환하지 않을 수 있다.  
브라우저는 여러 API 요청을 하고 필요 이상의 데이터를 가져와야 할 수 있다.  

GraphQL 앱은 필요한 데이터를 정확히 요청할 수 있지만, 엔드포인트 보호에는 REST보다 더 많은 작업이 필요하고 보안 취약점이 발생할 수 있다.  


### 6.5.3 웹과 모바일 프레임워크

#### 브라우저 앱 개발

- 브라우저/클라이언트 사이드
  - HTML
  - CSS
  - JavaScript
  - React
  - Angular
  - Vue.js
- 서버 사이드
  - Express
  - PHP

#### 모바일 앱 개발

- 코틀린
- 스위프트

#### 크로스 플랫폼 개발

- 리액트 네이티브
- 플러터

#### 백엔드 개발

- RPC
- REST
- GraphQL


## 6.6 라이브러리와 서비스

특정 컴포넌트에 어떤 선택이 최선이라고 즉시 단정 짓지 말아야 한다.  
대부분의 상황에서 라이브러리와 서비스 사용 사이에 명확한 선택은 없으므로 두 옵션 모두에 대해 설계와 구현 세부사항과 트레이드오프 관계를 설명할 수 있어야 한다.  

### 6.6.1 언어 특정적 vs 기술에 구애받지 않음

사용의 편의성을 위해 라이브러리는 클라이언트의 언어로 돼 있어야 하며, 따라서 지원되는 각 언어에서 동일한 라이브러리를 재구현해야 한다.  
대부분의 라이브러리는 잘 정의된 관련 작업 집합을 수행하게 최적화돼 있어 단일 언어를 사용할 때 최적으로 구현될 수 있다.  

서비스는 기술에 구애받지 않는다.  
클라이언트에게는 서비스의 HTTP, RPC, GraphQL 연결을 초기화하고 유지해야 하는 추가 오버헤드가 있다.  

### 6.6.2 지연 시간의 예측 가능성

- 라이브러리
  - 네트워크 지연 없음
- 서비스
  - 사용자의 인터넷 품질
  - 트래픽

### 6.6.3 동작의 예측 가능성과 재현성

서비스는 다른 서비스에 요청을 보내고, 서비스의 예측할 수 없고 재현할 수 없는 동작에 영향을 받을 수 있다.  

서비스 개발자는 로그에 접근할 수 있지만, 라이브러리 개발자는 사용자 기기의 로그에 접근할 수 없다.  


### 6.6.4 라이브러리의 확장성 고려사항

라이브러리는 사용자의 애플리케이션 내에 포함돼 있으므로 독립적으로 확장할 수 없다.  


### 6.6.5 기타 고려사항

일부 엔지니어는 자신의 코드를 라이브러리와 번들링하는 것에 심리적 주저함을 가지지만 서비스에 연결하는 것에는 개방적이다.  

- 라이브러리로 인한 빌드 크기 증가
- 라이브러리의 악성 코드


## 6.7 일반적인 API 패러다임

### 6.7.1 개방형 시스템 상호 연결(OSI) 모델

| 계층 번호 | 이름 | 설명                       | 예시               |
|-------|----|--------------------------|------------------|
| 7     | 응용 | 사용자 인터페이스                | FTP, HTTP        |
| 6 | 표현 | 데이터 표현, 암호화              | UTF, ASCII, JPEG |
| 5 | 세션 | 포트와 세션 유지                | RPC, SQL         |
| 4 | 전송 | 종단 간 연결, 신뢰 전송           | TCP, UDP         |
| 3 | 네트워크 | 논리 주소 지정, 물리적 경로 정의, 라우터 | IP               |
| 2 | 데이터 링크 | 네트워크 형식 | 이더넷, 와이파이        |
| 1 | 물리 | 물리적 매체를 통한 원시 비트 | 광섬유, 모뎀, USB |


### 6.7.2 REST

다른 장점으로는 하이퍼미디어와 캐싱 기능이 있다.  

#### 하이퍼미디어

하이퍼미디어 제어는 응답 내에 '다음에 가능한 작업'의 정보를 클라이언트에 제공한다.  

```
{
  "data": { ... },
  "links": {
    "pay": "https://example.com/pay"
  }
}
```

#### 캐싱

- HTTP 헤더
  - Expires
  - Cache-Control
  - ETag
  - Last-Modified

#### REST의 단점

단점은 하이퍼미디어나 OPTIONS 엔드포인트 외에 통합된 문서화 메커니즘이 없다는 것이다.  
REST는 또한 표준화된 버전 관리 절차가 없다.  


### 6.7.3 RPC (원격 프로시저 호출)

RPC는 프로그래머가 네트워크 세부 사항을 처리하지 않고도 다른 주소 공간이나 다른 호스트에서 프로시저를 실행하게 하는 기술이다.  

인코딩과 디코딩이 어떻게 이뤄지는지 이해해야 한다.  
- CSV, XML, JSON
- 쓰리프트
- 프로토콜 버퍼
- Avro

RPC 프레임워크가 REST보다 나은 주요 장점은 다음과 같다.  
- RPC는 리소스 최적화를 위해 설계 되어 Iot 기기 등 저전력 기기에 가장 적합한 통신
- 프로토콜 버퍼는 효율적인 인코딩 방식
- 파일에 엔드포인트 스키마 정의로 호환성 장점


### 6.7.4 GraphQL

GraphQL은 클라이언트가 API에서 필요한 데이터를 명확히 지정할 수 있도록 하는 선언적 쿼리 언어다.  
클라이언트가 원하는 데이터와 그 형식을 결정한다.  

- 트레이드오프 관계
  - 복잡도
  - 학습 곡성
  - 보안
  - JSON 인코딩
  - 각 API 사용자가 다른 쿼리를 수행하므로 사용자 분석 어려움
  - 데이터베이스 노출 가능성


### 6.7.5 웹소켓

웹소켓은 HTTP처럼 요청마다 새 연결을 생성하고 응답 후 연결을 닫는 방식이 아니라 지속적인 TCP 연결을 통해 전이중 통신을 가능하게 하는 통신 프로토콜이다.  

웹소켓은 연결을 열린 상태로 유지해 모든 참여자의 오버헤드를 증가시킨다.  
이는 상태 저장(Stateful)임을 의미한다.  
웹소켓의 상태 저장 특성과 연결 유지에 따른 리소스 오버헤드는 모두 웹소켓의 확장성이 낮다는 것을 의미한다.  


### 6.7.6 비교

REST와 RPC가 가장 일반적이다.  
GraphQL은 비교적 새로운 기술이다.  
웹소켓은 P2P 통신을 포함한 양방향 통신에 유용하다.  





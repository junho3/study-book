# 6장 조건 분기: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법

조건 분기를 사용하면 복잡한 판단을 빠르고 정확하게 할 수 있습니다.  
조건이 복잡해지면 코드의 동작을 이해하기 힘듭니다.  


## 6.1 조건 분기가 중첩되어 낮아지는 가독성

중첩을 하면 코드의 가독성이 크게 떨어지는 문제가 있다.  
어떤 조건을 만족할 때 어떤 로직이 처리되는지 이해하는 것만으로도 많은 시간을 낭비한다.  
**그런데 이런 낭비가 한 번으로 끝나지 않는다.**    
**코드를 읽을 때마다 낭비가 생기고, 코드를 읽는 사람 모두 이런 일을 겪으므로 가독성이 나쁜 코드는 팀 전체의 개발 생산성을 저하시킨다.**  

> 최근에 회계처리를 위한 분개룰 설계 논의를 하는 중인데, 몇몇 팀원이 단일 클래스로 구성해서 조건을 넣자는 의견을 제시함  

### 6.1.1 조기 리턴으로 중첩 제거하기

조기 리턴은 조건 로직과 실행 로직을 분리할 수 있다는 장점이 있다.  

### 6.1.2 가독성을 낮추는 else 구문도 조기 리턴으로 해결하기


## 6.2 switch 조건문 중복

### 6.2.1 switch 조건문을 사용해서 코드 작성하기

### 6.2.2 같은 형태의 switch 조건문이 여러 개 사용되기 시작

같은 형태의 switch 조건문을 여러 번 사용하는 것은 매우 좋지 않다.  

### 6.2.3 요구 사항 변경 시 수정 누락(case 구문 추가 누락)

> 코틀린은 when()을 하용하고, enum 값이 추가되었을 때 when 문에 누락이 생기면 컴파일 에러가 발생함  
> 
> when (type) {  
>   card -> ...  
>   money -> ...  
> }

### 6.2.4 폭발적으로 늘어나는 switch 조건문 중복

### 6.2.5 조건 분기 모으기

switch 조건문 중복을 해소하려면, 단일 책임 선택의 원칙을 생각해 봐야 한다.  

```
// Magic 클래스를 정의해서 생성자에서 조건과 조건에 따른 결과를 관리
class Magic {
  final String name;
  final int power;
  
  Magic(...) {
    switch (...) {
      case...
    }
  }
}
```

> 조건별 필요한 값이 동일하다면, 위 내용처럼 클래스로 정의해서 필요한 값을 모아두는 것도 좋아보임  

### 6.2.6 인터페이스로 switch 조건문 중복 해소하기

클래스가 거대해지면 관심사에 따라 작은 클래스로 분할하는 것이 중요하다.  

면적을 출력하는 같은 이름의 메서드를 만들었다고 해도 클래스가 다르므로, instanceof를 사용해서 자료형을 판정한 뒤 자료형을 강제로 변환해서 메서드를 호출해야 한다.  
인터페이스를 활용하면, 자료형 판정 분기를 따로 작성하지 않아도 된다.  

> Code_6_26Test.kt 참고

### 6.2.7 인터페이스를 switch 조건문 중복에 응용하기 (전략 패턴)

#### 종류별로 다르게 처리해야 하는 기능을 인터페이스의 메서드로 정의하기

인터페이스의 큰 장점 중 하나는 다른 로직을 같은 방식으로 처리할 수 있다는 점이다.  

#### 인터페이스의 이름을 결정하는 방법: '어떤 부류에 속하는가?'

#### 종류별로 클래스로 만들기

#### 각각의 클래스에 인터페이스 구현하기

#### switch 조건문이 아니라, Map으로 변경하기

`final Map<WeaponType, Weapon> weapons = new HashMap<>();`

이처럼 인터페이스를 사용해서 처리를 한꺼번에 전환하는 설계를 '전략 패턴'이라고 한다.  

#### 메서드를 구현하지 않으면 오류로 인식하게 만들기

구현하지 않은 메서드가 단 하나라도 존재하면, 컴파일하는 데 실패한다.  

#### 값 객체화하기


## 6.3 조건 분기 중복과 중첩



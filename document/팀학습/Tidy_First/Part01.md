# Part 01. 코드 정리법

종종 사람들이 '리팩터링'을 적용하는 동안에는 기능 개발을 멈추는 것으로 오해했기 때문에 치명적 피해를 끼쳤습니다.  
'리팩터링' 때문에 아쉽게 시스템 장애를 일으키기도 했습니다.  

## Chapter 01. 보호 구문

처음 두 줄을 도우미 메서드로 추출한 다음에 보호 구문으로 코드를 정리할 수도 있지만, 항상 그리고 반드시 작은 단계를 거쳐 코드를 정리하세요.  

> early return으로 조건문 복잡도 풀기  
> 
> if 문이 많아진다면 별도 유스케이스(클래스)로 추출하는 것을 고려해야 함  
> if 문 때문에 케이스별 테스트 코드 작성이 어려워짐  


## Chapter 02. 안 쓰는 코드

실행되지 않는 코드라면 그냥 지웁니다.  

때로는 안 쓰는 코드 찾기가 쉬울 수도 있지만, 더러는 쉽지 않을 때도 있습니다.  
리플렉션을 여러 번 사용한 코드가 그렇습니다.  

형상 관리 도구가 해결해 줍니다.  

항상 그렇듯이 각 정리 과정에서는 코드를 '조금만' 삭제하세요.  
조건 내용을 택하여 true로 줄일 수 있고, 루틴 하나, 파일 하나, 디렉토리 하나 정도로 해 나갈 수 있습니다.  

> 안 쓰는 코드 제거하는건 개발자마다 성향, 책임감 차이인 듯  
> 테스트 코드도 충분히 존재해야 함  
> 
> 코드가 많아지면 IDE 여는게 느려짐  
> 레거시 코드는 IDE에서 열리지 않아 Visual Studio로 열어본 경험이 있음  


## Chapter 03. 대칭으로 맞추기

코드는 마치 유기체처럼 성장합니다.  

코드가 유기체로 성장하면, 같은 문제라도 시대와 사람에 따라 다른 모습으로 해결됩니다.  
이것은 코드를 읽기 어렵게 만들기도 합니다.  

한가지 패턴의 코드는 읽다 보면 그 방식에 금방 익숙해집니다.  
두 가지 이상의 패턴을 섞어 쓰면 혼란스러워집니다.  

한 가지 방식을 선택해서 정합니다.  
다른 방식으로 작성한 코드를 선택한 방식으로 고칩니다.  

> PR을 통해 서로의 코드 스타일을 맞춰가는게 좋을 듯   
> 단순한 연산을 할 때도 +-*/ 를 사용하는 개발자와 .plus() .mul()과 같이 함수를 사용하는 개발자로 나눠짐  
> 
> 코드뿐만 아니라 아키텍처에도 해당하는 내용이라 생각됨  
> 단일 모듈에 패키지 구조와 클래스 suffix가 명확하지 않은 프로젝트를 접했을 때 어떻게 작업해야할지 혼란스러운 경험이 있음  
> 프로젝트 오너와 얘기하면서 맞춰 나감  
> Archunit의 중요성을 다시 한번 느낌  
>
> 프로젝트 오너는 본인이 담당하는 서비스의 아키텍처를 명확하게 정의할 필요가 있다고 생각함  

## Chapter 04. 새로운 인터페이스로 기존 루틴 부르기

루틴을 호출해야 하는데 기존 인터페이스 때문에 어렵거나, 복잡하거나, 혼란스럽거나, 지루해지곤 합니다.  
이 모든 경우에 호출하고 싶은 인터페이스를 새롭게 구현해서 호출하세요.  

- 거꾸로 코딩하기: 루틴의 마지막 줄부터 시작해 보세요. 이때는 마치 마지막 줄에 이르기까지 필요한 결과는 모두 확보한 듯이 짜는 거죠.

> 프록시 패턴?  
> 토스페이먼츠가 이런 방식으로 결제 API 스펙을 개선한걸로 알고 있음  
> 
> 기간계(레거시)시스템 작업할 때 활용 중  
> 기간계 시스템의 dto는 워낙 복잡하다보니 새로운 컨트롤러/서비스에서 레거시 클래스를 직접 호출하는 것이 부담스러움
> 새로운 컨트롤러/서비스에서는 필요한 값만 정의하고, factory라는 어댑터 성격의 클래스를 통해 레거시 클래스를 호출함
>
> paymentControllerV2 > paymentService > LegacyPaymentFactory (레거시 클래스 호출을 위한 dto 정의) > LegacyPaymentService

## Chapter 05. 읽는 순서

다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리치세요.  
읽어 가면서 이해나 변경을 어렵게 하는 세부 사항들도 주목했을 텐데, 나중에 이들을 정리할 때가 있습니다.  

되도록 전체 파일의 순서를 바꾸는 대신에, 읽는 순서가 영향을 크게 주는 것들부터 바꾸세요.  

> 레거시 시스템의 특징, 전통적으로 함수 최상위에 모든 변수를 선언하고, 로직을 풀어나감  
> 변수를 선언하는 위치와 사용하는 위치간 차이가 커서 종종 수정 함
>
> '다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리치세요.' 이 유혹을 뿌리치는 노하우가 있는지?  


## Chapter 06. 응집도를 높이는 배치

코드의 순서를 바꿔서 변경할 요소들을 가까이 두면 됩니다.  
두 루틴에 결합도가 있으면 서로 옆에 두세요.  
두 파일에 결합도가 있으면 같은 디렉토리에 넣습니다.  

결합도를 제거할 수 있다면 그렇게 하세요.  
`결합도 제거 비용 + 변경 비용 < 결합도에 따른 비용 + 변경 비용`

- 당장 어떻게 해야 할지 모를 경우
- 할 수 있지만, 시간적 여유가 없을 경우
- 팀이 이미 충분한 변경을 수행하고 있는 경우

스위스 치즈처럼 여기저기 코드가 구멍 난 듯 흩어진 채로 두고 동작 변경에만 매달리지 마세요.  

> 서비스 클래스와 DTO의 패키지 위치를 어떻게 구성하는지?  
> service 패키지 안에 서비스와 DTO 클래스를 모두 넣는지?  
> service 패키지와 dto 패키지를 구분하는지?  


## Chapter 07. 선언과 초기화를 함께 옮기기

타입이 포함된 선언과 초기화 코드가 떨어져 있기라도 하면 읽어 내기는 더 어려워집니다.  
한참 뒤에야 초기화 코드를 보게 된다면, 이미 변수가 어떤 맥락에서 선언되었는지 잊어버릴지도 모르니까요.  

변수와 변수에 값을 채우는 코드들의 순서를 이전 그대로 둘 수는 없습니다.  

데이터 종속을 수작업으로 분석한다면, 결국 실수를 하게 될 것입니다.  
구조만 개선하려고 하다가 실수로 동작까지 변경하게 될 수도 있습니다.  
그래도 문제는 없습니다.  
올바른 버전의 코드로 되돌리면 됩니다.  
작은 단계로 작업하세요.  

> 변수 선언과 초기화 위치가 떨어져있는건 그나마 나음  
> 해당 변수가 초기화 되었음에도 값을 계속 덮어씌우는 스타일이 문제라고 생각함  
> 변수 선언과 초기화를 분리해야한다면 최소한 final을 선언해야한다고 생각함  
>
> 코틀린은 기본적으로 변수 선언과 초기화를 같이 해야함  
> lateinit var로 초기화를 나중에 하도록 할 수 있지만, 초기화가 없으면 빌드 실패 발생  


## Chapter 08. 설명하는 변수

코드의 어떤 표현식들은 계속 성장합니다.  
처음에는 작게 시작했더라도, 시간이 흐르면 코드는 반드시 커집니다.  

어렵게 크고 복잡한 코드의 표현식을 이해했다면 전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당해 보세요.  

이렇게 설명하는 변수를 적용하면 이제 표현식과 분리되었기 때문에 다음 번 코드를 변경할 때 둘 중 하나만 읽으면 되니까 재빨리 변경할 수 있습니다.  

> 내용을 정확히 이해하지 못 함
> 
> 코틀린은 매개변수 힌트를 지정할 수 있어서 변수 초기화 후 생성자에 할당할 필요가 없다고 생각 함  
> val point = Point(weight = 100, height = 200)  
> 
> 그리고 복잡한 코드 표현식(계산식)은 도메인의 영역으로 봐도 되지 않을까 싶음  
> 예를 들어 포인트 클래스를 정의할 때 외부에서 포인트를 계산하여 객체를 생성하는게 아니라, 포인트 계산에 필요한 기초 데이터(결제금액, 적립률)를 생성자로 받고, 포인트 객체 내부에서 계산한다면 코드 응집도가 올라가지 않을까?
> 
> class Point(  
>   val transactionAmount: Long,  
>   val pointRatio: Double,  
> ) {  
>   val point: Long  
>      get() = transactionAmount * pointRatio  
> }


## Chapter 09. 설명하는 상수

상징적인 상수를 만드세요.  
리터럴 상수로 사용된 곳은 상징적인 상수로 바꿉니다.  

같은 리터럴 상수가 두 곳에서 나타날 때는 다른 의미로 쓰이는지 확인하세요.  
그러니 다음과 같은 빈약한 의미를 가진 코드 정리는 도움이 되지 않습니다.  

한번에 바뀌어야 하거나 함께 이해해야 하는 상수들을 한곳에 모아두고, 다른 이유로 묶인 변수들을 분리하는 후속 작업을 해야죠.  


## Chapter 10. 명시적인 매개변수

앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달합니다.  

맵에서 매개변수가 블록으로 전달되는 경우가 흔합니다.  
이렇게 하면, 코드를 읽으면서도 어떤 데이터가 필요한지 알기 어렵습니다.  
또한, 이후에 매개변수를 변경하여 암묵적으로 사용하는 일과 같은 끔찍한 남용의 길이 열립니다.  

매개변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 준비하세요.  
이렇게 만들면 코드는 읽기와 테스트, 분석이 쉬워집니다.  

> 내용을 정확히 이해하지 못 함  
> 거대한 dto를 만들지말고, 성격에 따라 개별 파라미터로 넘기라는 의미로 이해함  
> 책의 예시처럼 foo를 foo_body로 분리하여 함수의 깊이를 깊게 하는건 선호하지 않음  
> 함수가 깊어질수록 코드 읽기(이해)가 어려움  
> 
> 함수에서 사용하는 값만 파라미터로 넘길 수 있도록 함수의 매개변수를 정의하는게 중요하다고 생각함  

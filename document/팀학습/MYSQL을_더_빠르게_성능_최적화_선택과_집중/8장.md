# 8장 트랜잭션

MySQL에는 MyISAM과 같은 비트랜잭션 스토리지 엔진이 있지만 InnoDB가 기본값이고, 사실상 모든 MySQL 쿼리는 단일 SELECT 문이라도 트랜잭션에서 실행됩니다.  
애플리케이션 워크로드가 잘 최적화되면 트랜잭션은 성능과 관련된 문제가 없습니다.  

## 8-1 로우 락

읽기는 행을 잠그지 않지만, 쓰기는 항상 행을 잠급니다.  
`REPEATBALE READ` 트랜잭션에서 InnoDB는 쓰기 행 말고도 훨씬 더 많은 행을 잠글 수 있습니다.  

테이블은 인덱스이므로, 행은 인덱스 레코드입니다.  
InnoDB 로우 락은 인덱스 레코드 갭 때문에 로우 락이 아니라 레코드 락 관점에서 논의됩니다.  

> MySQL 인덱스는 B-tree로 관리  
>        1    ...    10  
>    1  ..  5   |   6  ..  10   
>  1 . 2 | 3 . 5 |  6 . 7 | 8 . 10  
> 3번 데이터를 업데이트 할 경우, 3, 4, 5번 데이터가 잠김  

간단히 말해, 애플리케이션은 행 단위로 처리하고 InnoDB 로우 락은 레코드 단위로 처리합니다.  
이 절의 예는 갭 락이 상당히 광범위하고 개별 레코드 락보다 더 중요하다는 것을 보여 줍니다.  

### 레코드와 넥스트-키 락

```
UPDATE elem SET c = '' WHERE id BETWEEN 2 AND 5;  
하한 ... 2 (레코드 락) ... 5 (넥스트-키 락) ... 상한 (넥스트-키 락)  
```

> 2와 5 사이에는 갭 락이 존재  
> 5는 넥스트-키 락이 아니라 레코드락이 아닌지?  

흥미로운 질문은 "테이블 조건에서 5보다 큰 프라이머리 키값을 제외할 때, 5보다 큰 모든 프라이머리 키값을 포함하는 상한.의사 레코드를 잠그는 이유는 무엇일까요?" 입니다.  

새로운 값(3)을 삽입할 2와 5 사이의 갭에서 **삽입 의도 잠금**을 획득하려고 시도하는 첫번째 INSERT는 시간 초과가 발생합니다.  
lock_data 열에 값 5가 나열되지만 레코드나 넥스트-키 락이 아니므로 이 레코드는 잠기지 않습니다.  
이것은 특별한 유형의 갭 락인 삽입 의도 잠금이므로 값 5 이전의 갭을 잠급니다.  

두 번째 INSERT는 새 값 6이 현재 최댓값 5보다 크기 때문에 상한-의사 레코드에서 넥스트-키 락을 획득하려고 시도할 때 시간이 초과되어 최대 레코드와 상한 의사 레코드 사이에 삽입됩니다.  

영향을 받는 레코드 앞의 갭을 잠그면 넥스트-키 락은 쿼리가 접근하는 레코드의 전체 범위를 격리합니다.  
이는 ACID 속성 가운데 I(격리성)을 나타냅니다.  
이는 트랜잭션이 이전에 읽지 않은 행을 나중에 읽을 때 **팬텀 행**이라는 현상을 방지합니다.  

`REPEATABLE READ`는 MySQL의 기본값이며 InnoDB는 넥스트-키 락을 사용하여 REPEATABLE READ에서 팬텀 행을 방지합니다.  

트랜잭션 격리 수준인 `READ COMMITTED`는 넥스트-키 락을 포함하는 갭 락을 비활성화합니다.  
`READ COMMITTED` 트랜잭션의 동일한 UPDATE 문은 일치하는 행(2, 5)에서만 레코드 락을 획득합니다.  

`READ COMMITTED`에는 2가지 중요한 부작용이 있습니다.  
- 동일한 읽기 문을 다시 실행하면 다른 행을 반환할 수 있습니다.
- 동일한 쓰기 문을 다시 실행하면 다른 행에 영향을 미칠 수 있습니다.

> A1 트랜잭션 시작  
> A1 트랜잭션에서 SELECT 실행: 값이 5  
> B1 트랜잭션 시작  
> B1 트랜잭션에서 UPDATE 실행: 값이 5에서 1로 변경  
> A1 트랜잭션에서 SELECT 실행: 값이 5가 아닌 1로 조회 됨 << 이 부분이 문제인 듯  
> A1 트랜잭션 종료  
> B1 트랜잭션 종료  





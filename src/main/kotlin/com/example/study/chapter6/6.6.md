# 6.6 미래를 대비한 열거형 처리

열거형을 다뤄야 할 가능성
- 다른 사람의 코드의 결과를 사용해야 하며 어떤 이유로든 그들이 열거형을 즐겨 사용할 수 있다.
- 다른 시스템에서 제공하는 결과를 사용하고 있을 때 열거형은 종종 데이터 형식에서 유일하게 실용적인 옵션일 수 있다.

> Enum을 사용할 때 코드 값을 축약해서는 안됨. 잘못 사용하면 매직값이 되어버림  
> 토스페이먼츠의 결제 API에서는 한글 Enum도 사용하는 것으로 보임 https://youtu.be/E4_0WWqmF3M

## 6.6.1 미래에 추가될 수 있는 열것값을 암묵적으로 처리하는 것은 문제가 될 수 있다

> if 문으로 열거값을 조건으로 처리함으로서 발생한 문제로 테스트 코드를 케이스별로 작성하면 보완할 수 있지 않을까?

## 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

모든 열것값을 명시적으로 처리하고, 처리되지 않은 새로운 열것값이 추가되는 경우 코드 컴파일이 실패하거나 테스트가 실패하게 하는 것이다.  

> 코틀린은 switch() 대신에 when()을 지원하는데, Enum을 처리할 경우 모든 값을 명시하거나 else 처리를 반드시 해줘야함  
> 코틀린의 when()과 sealed class를 조합하여, 클래스별 케이스에 대한 처리를 강제화함  
> sealed class 소개: https://kotlinworld.com/165
> 카카오페이에서 예외처리를 구현하는 방법: https://tech.kakaopay.com/post/msa-transaction/

## 6.6.3 기본 케이스를 주의하라

열거형을 처리하는 스위치 문에 기본 케이스를 추가하면 향후 열거형 값이 암시적으로 처리될 수 있으며 잠재적으로 예기치 않은 문제와 버그가 발생할 수 있다.  

> dev, stage, prod 환경을 구분할 수 있는 조건문이 있었고, 기본 값이 prod 였음. qa라는 환경이 추가되면서, qa 환경에서 prod 시스템을 호출하는 문제가 발생하였음  

## 6.6.4 주의사항: 다른 프로젝트의 열거형에 의존

때로는 자신이 작성한 코드가 다른 프로젝트나 조직이 개발한 코드의 열거형에 의존할 수 있다.  
그 프로젝트에서 미리 알려주지 않고 새로운 열것값을 추가할 가능성이 있고 이로 인해 코드가 작동하지 않을 수 있다면, 새로운 값을 다루는 데 있어 허용의 범위가 좀 더 넓어질 수밖에 없다.  

> MSA 환경에서 코드 값 공유는 약속이라고 생각함

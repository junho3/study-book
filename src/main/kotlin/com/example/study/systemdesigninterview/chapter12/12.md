# 12장 채팅 시스템 설계

## 1단계 문제 이해 및 설계 범위 확정

- 1:1 채팅과 그룹 채팅을 모두 지원 해야함
- 모바일 앱과 웹을 모두 지원해야함
- 일별 사용자는 5000만명
- 그룹 채팅은 최대 100명
- 사용자 접속 상태를 표시 해야함
- 텍스트 메시지만 전송 가능
- 최대 메세지 길이는 100,000자
- 채팅 이력은 영구 보관

## 2단계 개략적 설계안 제시 및 동의 구하기

클라이언트 > 채팅 서비스 < 클라이언트

통신 프로토콜을 어떤 것을 사용할 것인가?  
채팅 서비스 접속에는 HTTP keep-alive 헤더를 사용하면, 클라이언트와 서버 사이의 연결을 끊지 않고, 계속 유지할 수 있음  
TCP 접속 과정에서 발생하는 핸드셰이크 횟수를 줄일 수 있음  

### 폴링

클라이언트가 주기적으로 서버에게 새 메시지가 있는지 확인하는 방법  
답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비 됨  

### 롱 폴링

클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다.  
새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.  

메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하지 않을 수 있다.  
서버 입장에서 클라이언트가 연결을 해제했는지 알 수 없다.  

### 웹소켓

처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드 된다.  
연결이 맺어지면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.  

### 개략적 설계안

#### 무상태 서비스

#### 상태 유지 서비스

#### 제3자 서비스 연동

#### 규모 확장성

서버만 한 대 갖는 설계안에서 출발하여 점차로 다듬어 나가는 것은 괜찮다.  
서버가 한 대인 경우 SPOF에 주의해야 함  

#### 저장소

다중화와 샤딩은 이런 데이터의 가용성과 규모 확장성을 보증하기 위해 보편적으로 사용되는 기술이다.  

- 키-값 저장소는 수평적 규모확장이 쉽다.  
- 키-값 저장소는 데이터 접근 지연시간이 낮다.
- 관계형 데이터베이스는 인덱스가 커지면 데이터에 대한 무작위적 접근을 처리하는 비용이 늘어난다.  

### 데이터 모델

#### 1:1 채팅을 위한 메시지 테이블

> message_id bigint 금방 고갈되지 않을까?

#### 그룹 채팅을 위한 메시지 테이블

#### 메시지 ID

- message_id는 고유해야 한다.
- 정렬 가능해야 하며 시간 순서와 일치해야 한다.  

채번 방식  
- RDBMS는 auto increment를 제공하지만, NoSQL은 제공하지 않음  
- 64 bit 스노플레이크  
- 지역적 순서 번호 생성기  

## 3단계 상세 설계

### 서비스 탐색

사용자가 시스템에 접속하면 아파치 주키퍼가 클라이언트 위치, 서버 용량 등을 판단하여 적합한 서버로 연결시켜 줌  

### 메시지 흐름

#### 1:1 채팅 메시지 처리 흐름

#### 여러 단말 사이의 메시지 동기화

#### 소규모 크룹 채팅에서의 메시지 흐름

### 접속상태 표시

#### 사용자 로그인

> 뱃지 알림 서비스도 비슷한 구조 였음  
> Redis에 특정 키 값으로 저장해 두고, Redis에 값이 있으면 뱃지가 노출  
> 뱃지를 확인하면 Redis에 키 값을 제거하는 방식  

#### 로그아웃

#### 접속 장애

heartbeat 검사를 통해 지정된 시간동안 접속 상태를 유지  

#### 상태 정보의 전송

각각의 친구 관계마다 채널을 하나씩 두어 상태를 체크  

## 4단계 마무리

- 사진이나 비디오 등을 지원하는 경우
- 종단간 암호화
- 읽은 메시지 캐시
- 로딩 속도 개선
- 오류 처리


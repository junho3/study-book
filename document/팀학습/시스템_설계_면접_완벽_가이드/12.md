# 12 플리커 설계

파일/이미지 공유 외에도 사용자는 접근 제어, 댓글, 또는 즐겨찾기와 같은 메타데이터를 파일과 다른 사용자에게 추가할 수 있다.  


## 12.1 사용자 스토리와 기능 요구사항


## 12.2 비기능적 요구사항

- 예상되는 사용자 수와 API를 통한 다운로드 수
  - 10억 명
  - 1,000만(10 억명의 1%) * 10 (일 평균 업로드 수) * 10 (이미지 용량) = 1PB (매일 업로드 총 양)
  - 트래픽 급증을 대비하여 초당 10GB 계획
- 업로드, 삭제, 설정 변경의 지연 시간
  - 몇 분 소요 가능
  - 최종 일관성 보장
- 네트워크 속도 및 비용
- 99.999% 가용성
- 썸네일 다운로드에서는 P99 1초
- 업로드에는 높은 성능을 요구하지 않음

첫 번째 접근 방식은 클라이언트가 썸네일을 요청할 때마다 서버가 전체 해상도 이미지에서 썸네일을 생성하는 것이다.  
이 방식은 비용이 매우 많이 든다.  
게다가 처리와 저장을 별도의 서비스로 나누는 기능적 분할을 할 수 없게 된다.  

유일하게 확장 가능한 접근 방식은 파일이 업로드 된 직후 썸네일을 생성하고 저장한 다음, 뷰어가 요청할 때 이 썸네일을 제공하는 것이다.  


## 12.3 고수준 아키텍처

첫 번째는 이미지 파일과 이미지 메타데이터를 위한 CDN이다.  

CDN이 다양한 데이터 센터에 이미지를 복제하는 데 최대 몇 시간이 걸릴 수 있다.  
그 사이 다운로드 요청 비율이 높으면 도운로드 속도가 느려질 수 있다.  

파일을 CDN에 업로드한 후 파일 저장 서비스에서 삭제하거나 백업으로 유지할 수 있다.  


## 12.4 SQL 스키마

각 공유자에게 고유한 CDN 디렉터리를 할당할 수 있으며, 이는 ImageDir 테이블을 사용해 추적한다.  


## 12.5 CDN에서 디렉터리와 파일 구성하기

디렉터리 계층 구조는 사용자 > 앨범 > 해상도 > 파일이 될 수 있다.  

앨범 디렉터리는 다양한 해상도의 여러 이미지 파일을 각각 고유한 디렉터리에 저장하고, JSON 이미지 메타데이터 파일도 저장할 수 있다.  


## 12.6 사진 업로드하기

### 12.6.1 클라이언트에서 썸네일 생성하기

클라이언트에서 썸네일을 생성하면 백엔드의 계산 리소스를 절약할 수 있고, 썸네일이 작아 네트워크 트래픽에 거의 영향을 주지 않는다.  

두 파일을 폴더에 넣은 다음 Gzip이나 Brotli 같은 인코딩으로 압축한다.  
네트워크 트래픽을 절약할 수 있지만, 백엔드에서 압축을 풀기 위해 CPU와 메모리 리소스를 사용할 것이다.  


#### 클라이언트 사이드 생성의 단점

클라이언트 기기를 제어할 수 없고 그 환경을 자세히 알지 못해 버그를 재현하기가 어렵다.  

- 디스크 공간 부족
- 네트워크 연결 끊김

클라이언트에서 생성하려면 각 클라이언트 유형(브라우저, 안드로이드, iOS)을 유지보수해야 한다.  

악의적인 활동을 막을 수 없다.  

앱에 로컬 저장소 쓰기 권한과 같은 더 많은 권한이 필요할 수 있고, 일부 사용자가 불편하게 여길 수 있다.  


#### 지루하고 긴 소프트웨어 릴리스 수명주기

작은 변경 사항을 빠르게 릴리스하고 롤백할 수 없다.  

```
1. 새 함수를 추가하되 기존 함수를 사용한다.  
2. 함수를 디버그하고 버그가 관찰되지 않을 때까지 새 버전을 릴리스 한다.  
3. 이전 함수에서 새 함수를 사용하게 코드를 전환한다.  
4. 새로운 함수가 충분히 안정화되었다고 판단될 때 기존 함수를 코드에서 삭제한다.  
```

이 접근 방식의 한계는 이전 버전과 호환되지 않는 코드를 도입하기 어렵다는 점이다.  
이 접근 방식은 클라이언트에서 더 많은 계산 리소스와 에너지를 소비하며, 클라이언트 앱의 크기를 증가시킨다.  


### 12.6.2 백엔드에서 썸네일 생성하기

파일이 백엔드에 업로드되면 백엔드는 파일을 파일 저장 서비스와 CDN에 기록한 다음 썸네일을 생성하는 스트리밍 작업을 트리거한다.  

#### 코레오그래피 사가 패턴 접근 방식

FTP는 디스크에 기록하므로 추가 처리를 하면 디스크에서 메모리로 읽는 데 지연 시간과 CPU 리소스가 발생한다.  
이는 POST 요청이나 RPC를 사용할 때는 발생하지 않는 불필요한 단계다.  


#### 오케스트레이션 사가 패턴 접근 방식

> 그림 12.6은 코레오그레피가 아닌지?


### 12.6.3 서버 사이드와 클라이언트 사이드 생성 모두 구현하기

클라이언트는 먼저 썸네일 생성을 시도한다.  
실패하면 서버에서 생성할 수 있다.  

이 접근 방식은 서버 사이드 생성만 하는 것보다 더 복잡하고 비용이 많이 들지만, 클라이언트 사이드 생성만 하는 것보다는 더 저렴하고 쉬울 수 있다.  
클라이언트 사이드 생성에 서버 사이드 생성이 페일 오버 역할을 하므로 클라이언트 사이드 버그와 충돌 비용이 덜 들기 때문이다.  


## 12.7 이미지와 데이터 다운로드하기

뷰어가 이미지를 즐겨찾기 할 때 이미지의 불변성을 활용해 저장 공간이 충분하다면 썸네일과 전체 해상도 이미지를 모두 클라이언트에 캐시할 수 있다.  


### 12.7.1 썸네일 페이지 다운로드 하기

`GET thumbnails?page=<page>&page_version=<page_version>`과 같이 페이지네이션에 버전을 부여하는 것이다.  
page_version이 생략되면 백엔드는 기본적으로 최신 버전으로 대체할 수 있다.  
사용자가 1페이지로 돌아갈 때 page_version을 생략하면 최신 1페이지의 썸네일이 표시된다.  

그러나 이 기법은 썸네일이 목록의 시작 부분에 추가되거나 삭제될 때만 작동한다.  

더 나은 기법은 클라이언트가 현재 첫 번째 항목이나 마지막 항목을 백엔드에 전달하는 것이다.  
사용자가 앞으로 넘기면 `GET thumbnails?previous_last=<last_item>`을 사용한다.  
사용자가 뒤로 넘기면 `GET thumbnails?previous_first=<first_item>`을 사용한다.


## 12.8 모니터링과 경보


## 12.9 기타 서비스

### 12.9.1 프리미엄 기능

### 12.9.2 결제와 세금 서비스

판매세, 소득세, 법인세 등 많은 종류의 세금이 있을 수 있다.  
각 유형에는 국가, 주, 카운티, 시 세금 등 많은 구성 요소가 있을 수 있다.  

### 12.9.3 검열/콘텐츠 조정

콘텐츠 조정은 수동과 자동으로 모두 수행할 수 있다.  

### 12.9.4 광고

### 12.9.5 개인화


## 12.10 기타 논의 가능한 주제

- 저작권 권리와 워터마킹 시스템
- 데이터 손실과 도난 예방
- 저장 비용을 제어하기 위한 전략




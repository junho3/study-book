# Part 01. 코드 정리법

종종 사람들이 '리팩터링'을 적용하는 동안에는 기능 개발을 멈추는 것으로 오해했기 때문에 치명적 피해를 끼쳤습니다.  
'리팩터링' 때문에 아쉽게 시스템 장애를 일으키기도 했습니다.  

## Chapter 01. 보호 구문

처음 두 줄을 도우미 메서드로 추출한 다음에 보호 구문으로 코드를 정리할 수도 있지만, 항상 그리고 반드시 작은 단계를 거쳐 코드를 정리하세요.  

> early return으로 조건문 복잡도 풀기  
> 
> if 문이 많아진다면 별도 유스케이스(클래스)로 추출하는 것을 고려해야 함  
> if 문 때문에 케이스별 테스트 코드 작성이 어려워짐  


## Chapter 02. 안 쓰는 코드

실행되지 않는 코드라면 그냥 지웁니다.  

때로는 안 쓰는 코드 찾기가 쉬울 수도 있지만, 더러는 쉽지 않을 때도 있습니다.  
리플렉션을 여러 번 사용한 코드가 그렇습니다.  

형상 관리 도구가 해결해 줍니다.  

항상 그렇듯이 각 정리 과정에서는 코드를 '조금만' 삭제하세요.  
조건 내용을 택하여 true로 줄일 수 있고, 루틴 하나, 파일 하나, 디렉토리 하나 정도로 해 나갈 수 있습니다.  

> 안 쓰는 코드 제거하는건 개발자마다 성향, 책임감 차이인 듯  
> 테스트 코드도 충분히 존재해야 함  
> 
> 코드가 많아지면 IDE 여는게 느려짐  
> 레거시 코드는 IDE에서 열리지 않아 Visual Studio로 열어본 경험이 있음  


## Chapter 03. 대칭으로 맞추기

코드는 마치 유기체처럼 성장합니다.  

코드가 유기체로 성장하면, 같은 문제라도 시대와 사람에 따라 다른 모습으로 해결됩니다.  
이것은 코드를 읽기 어렵게 만들기도 합니다.  

한가지 패턴의 코드는 읽다 보면 그 방식에 금방 익숙해집니다.  
두 가지 이상의 패턴을 섞어 쓰면 혼란스러워집니다.  

한 가지 방식을 선택해서 정합니다.  
다른 방식으로 작성한 코드를 선택한 방식으로 고칩니다.  

> PR을 통해 서로의 코드 스타일을 맞춰가는게 좋을 듯   
> 단순한 연산을 할 때도 +-*/ 를 사용하는 개발자와 .plus() .mul()과 같이 함수를 사용하는 개발자로 나눠짐  
> 
> 코드뿐만 아니라 아키텍처에도 해당하는 내용이라 생각됨  
> 단일 모듈에 패키지 구조와 클래스 suffix가 명확하지 않은 프로젝트를 접했을 때 어떻게 작업해야할지 혼란스러운 경험이 있음  
> 프로젝트 오너와 얘기하면서 맞춰 나감  
> Archunit의 중요성을 다시 한번 느낌  
>
> 프로젝트 오너는 본인이 담당하는 서비스의 아키텍처를 명확하게 정의할 필요가 있다고 생각함  

## Chapter 04. 새로운 인터페이스로 기존 루틴 부르기

루틴을 호출해야 하는데 기존 인터페이스 때문에 어렵거나, 복잡하거나, 혼란스럽거나, 지루해지곤 합니다.  
이 모든 경우에 호출하고 싶은 인터페이스를 새롭게 구현해서 호출하세요.  

- 거꾸로 코딩하기: 루틴의 마지막 줄부터 시작해 보세요. 이때는 마치 마지막 줄에 이르기까지 필요한 결과는 모두 확보한 듯이 짜는 거죠.

> 프록시 패턴?  
> 토스페이먼츠가 이런 방식으로 결제 API 스펙을 개선한걸로 알고 있음  
> 
> 기간계(레거시)시스템 작업할 때 활용 중  
> 기간계 시스템의 dto는 워낙 복잡하다보니 새로운 컨트롤러/서비스에서 레거시 클래스를 직접 호출하는 것이 부담스러움
> 새로운 컨트롤러/서비스에서는 필요한 값만 정의하고, factory라는 어댑터 성격의 클래스를 통해 레거시 클래스를 호출함
>
> paymentControllerV2 > paymentService > LegacyPaymentFactory (레거시 클래스 호출을 위한 dto 정의) > LegacyPaymentService

## Chapter 05. 읽는 순서

다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리치세요.  
읽어 가면서 이해나 변경을 어렵게 하는 세부 사항들도 주목했을 텐데, 나중에 이들을 정리할 때가 있습니다.  

되도록 전체 파일의 순서를 바꾸는 대신에, 읽는 순서가 영향을 크게 주는 것들부터 바꾸세요.  

> 레거시 시스템의 특징, 전통적으로 함수 최상위에 모든 변수를 선언하고, 로직을 풀어나감  
> 변수를 선언하는 위치와 사용하는 위치간 차이가 커서 종종 수정 함
>
> '다른 코드 정리 작업을 함께 하고픈 유혹이 오더라도 뿌리치세요.' 이 유혹을 뿌리치는 노하우가 있는지?  


## Chapter 06. 응집도를 높이는 배치

코드의 순서를 바꿔서 변경할 요소들을 가까이 두면 됩니다.  
두 루틴에 결합도가 있으면 서로 옆에 두세요.  
두 파일에 결합도가 있으면 같은 디렉토리에 넣습니다.  

결합도를 제거할 수 있다면 그렇게 하세요.  
`결합도 제거 비용 + 변경 비용 < 결합도에 따른 비용 + 변경 비용`

- 당장 어떻게 해야 할지 모를 경우
- 할 수 있지만, 시간적 여유가 없을 경우
- 팀이 이미 충분한 변경을 수행하고 있는 경우

스위스 치즈처럼 여기저기 코드가 구멍 난 듯 흩어진 채로 두고 동작 변경에만 매달리지 마세요.  

> 서비스 클래스와 DTO의 패키지 위치를 어떻게 구성하는지?  
> service 패키지 안에 서비스와 DTO 클래스를 모두 넣는지?  
> service 패키지와 dto 패키지를 구분하는지?  


## Chapter 07. 선언과 초기화를 함께 옮기기

타입이 포함된 선언과 초기화 코드가 떨어져 있기라도 하면 읽어 내기는 더 어려워집니다.  
한참 뒤에야 초기화 코드를 보게 된다면, 이미 변수가 어떤 맥락에서 선언되었는지 잊어버릴지도 모르니까요.  

변수와 변수에 값을 채우는 코드들의 순서를 이전 그대로 둘 수는 없습니다.  

데이터 종속을 수작업으로 분석한다면, 결국 실수를 하게 될 것입니다.  
구조만 개선하려고 하다가 실수로 동작까지 변경하게 될 수도 있습니다.  
그래도 문제는 없습니다.  
올바른 버전의 코드로 되돌리면 됩니다.  
작은 단계로 작업하세요.  

> 변수 선언과 초기화 위치가 떨어져있는건 그나마 나음  
> 해당 변수가 초기화 되었음에도 값을 계속 덮어씌우는 스타일이 문제라고 생각함  
> 변수 선언과 초기화를 분리해야한다면 최소한 final을 선언해야한다고 생각함  
>
> 코틀린 변수 선언과 초기화별 동작 방식
>
> 1. val, var 변수를 선언만 하는 경우 빌드 가능  
> val number: Int  
> var number: Int  
>
> 2. val, var 변수를 선언하고, 사용하는 경우 빌드 불가능  
> val number: Int  
> var number: Int  
> println(number)  
>
> 3. lateinit var 변수를 선언하고, 사용하는 경우 빌드 가능, UninitializedPropertyAccessException 발생    
> lateinit var text: String  
> println(text)  
> 
> 4. Delegates val, var 변수를 선언하고, 사용하는 경우 빌드 가능, IllegalStateException 발생  
> val number by Delegates.notNull<Int>()  
> var number by Delegates.notNull<Int>()  
> println(number)  


## Chapter 08. 설명하는 변수

코드의 어떤 표현식들은 계속 성장합니다.  
처음에는 작게 시작했더라도, 시간이 흐르면 코드는 반드시 커집니다.  

어렵게 크고 복잡한 코드의 표현식을 이해했다면 전체에서 일부 표현식을 추출한 후, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당해 보세요.  

이렇게 설명하는 변수를 적용하면 이제 표현식과 분리되었기 때문에 다음 번 코드를 변경할 때 둘 중 하나만 읽으면 되니까 재빨리 변경할 수 있습니다.  

> 내용을 정확히 이해하지 못 함
> 
> 코틀린은 매개변수 힌트를 지정할 수 있어서 변수 초기화 후 생성자에 할당할 필요가 없다고 생각 함  
> val point = Point(weight = 100, height = 200)  
> 
> 그리고 복잡한 코드 표현식(계산식)은 도메인의 영역으로 봐도 되지 않을까 싶음  
> 예를 들어 포인트 클래스를 정의할 때 외부에서 포인트를 계산하여 객체를 생성하는게 아니라, 포인트 계산에 필요한 기초 데이터(결제금액, 적립률)를 생성자로 받고, 포인트 객체 내부에서 계산한다면 코드 응집도가 올라가지 않을까?
> 
> class Point(  
>   val transactionAmount: Long,  
>   val pointRatio: Double,  
> ) {  
>   val point: Long  
>      get() = transactionAmount * pointRatio  
> }


## Chapter 09. 설명하는 상수

상징적인 상수를 만드세요.  
리터럴 상수로 사용된 곳은 상징적인 상수로 바꿉니다.  

같은 리터럴 상수가 두 곳에서 나타날 때는 다른 의미로 쓰이는지 확인하세요.  
그러니 다음과 같은 빈약한 의미를 가진 코드 정리는 도움이 되지 않습니다.  

한번에 바뀌어야 하거나 함께 이해해야 하는 상수들을 한곳에 모아두고, 다른 이유로 묶인 변수들을 분리하는 후속 작업을 해야죠.  


## Chapter 10. 명시적인 매개변수

앞부분에서 매개변수 값을 채운 후, 뒷부분에서 명시적으로 전달합니다.  

맵에서 매개변수가 블록으로 전달되는 경우가 흔합니다.  
이렇게 하면, 코드를 읽으면서도 어떤 데이터가 필요한지 알기 어렵습니다.  
또한, 이후에 매개변수를 변경하여 암묵적으로 사용하는 일과 같은 끔찍한 남용의 길이 열립니다.  

매개변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 준비하세요.  
이렇게 만들면 코드는 읽기와 테스트, 분석이 쉬워집니다.  

> 내용을 정확히 이해하지 못 함  
> 거대한 dto를 만들지말고, 성격에 따라 개별 파라미터로 넘기라는 의미로 이해함  
> 책의 예시처럼 foo를 foo_body로 분리하여 함수의 깊이를 깊게 하는건 선호하지 않음  
> 함수가 깊어질수록 코드 읽기(이해)가 어려움  
> 
> 함수에서 사용하는 값만 파라미터로 넘길 수 있도록 함수의 매개변수를 정의하는게 중요하다고 생각함  
> foo(hugeDto) (x)  
> foo(hugeDto.id, hugeDto.name, hugeDto.age) (o)  


## Chapter 11. 비슷한 코드끼리

긴 코드 덩어리를 읽다가 '아, 이 부분은 이렇게 하고, 저 부분은 저렇게 하는구나'라고 구분이 될 때는 두 부분 사이에 빈 줄을 넣어 분리합시다.  

소프트웨어 설계가 큰일이 되면, 설계 작업을 아예 그만두고 싶은 위험에 직면합니다.  
작은 소프트웨어 설계로 변화를 좀 더 쉽게 만들 수 있습니다.  

`소프트웨어 설계 또한 복리처럼 뒤따르는 소프트웨어 설계를 더 쉽게 만듭니다.`  
제대로 된 소프트웨어 설계는 유연성을 확보하지만, 그렇지 못한 경우는 자칫 변화 자체를 망각하고 소프트웨어 설계의 소용돌이에 빠질 수 있습니다.  

> 기간계(레거시)시스템 분석할 때 주로 사용했던 방법  
> 코드의 도메인적 의미는 이해하지 못 했지만, 최소한 코드를 읽기 쉽도록 연관 있는 코드끼리 분리했음  
> 
> 미래를 예측한 설계를 하는건 도메인 지식이 풍부하지 않는 이상 어렵다고 생각함  
> 변화에 대응하기 쉽도록 최소한 SRP라도 잘 지키는게 중요  


## Chapter 12. 도우미 추출

코드 블록을 추려내고, 도우미로 추출한 후에 이름을 붙입니다.  
`이때, 도우미의 이름은 작동 방식이 아니라 목적에 따라 짓습니다.`  

리팩토링을 알고 계신 분들이라면, 이 정리법이 바로 '메서드 추출' 리팩토링임을 알아볼 것입니다.  

해당하는 줄들을 도우미로 추출하고, 도우미 안의 내용만 변경한 다음, 적절하다고 판단한 뒤에 도우미를 호출하는 문장에 반영하세요.  
이 작업을 응집도 높은 요소 만들기로 이해하실 수 있을 것입니다.  

도우미 추출의 또 다른 특수 사례는 시간적 결합을 표현하는 경우입니다.  
이럴 때는 다음(ab())처럼 바꾸세요.  

도우미는 필요한 모든 곳에서 사용할 수 있습니다.  
도우미 사용은 또 다른 코드 정리에 도움이 됩니다.  

> 코틀린은 object 키워드로 싱글턴 클래스를 쉽게 만들 수 있음  
> object 클래스로 helper를 정의하는 편  
> 함수 또한 public으로 선언할 수 있어서 테스트 코드를 작성할 수 있음  
> 
> Java에서 도우미 메소드를 private으로 정의하는지? 별도 클래스로 정의 후 주입해서 사용하는지?  
>
> if (condition1 == true || condition2 == true) { ... } (x)  
> if (isCondition1() || isCondition2()) { ... } (x)  
> if (isPayAble()) { ... } (o)  
> isCondition1(), isCondition2()과 같이 너무 작은 도우미 함수는 의미 없다고 생각함  
> 
> if (condition) { doSomething() } vs doSomething(condition)  
> 조건을 만족하는 경우에 도우미 함수를 호출하는지? 아니면 도우미 함수에 조건 자체를 넘기는지?  
> 
> 도우미 함수도 누군가가 유지 보수해야함  
> value class Money (val value: BigDecimal) {  
>   fun toInt() { ... }  
>   fun toLong() { ... }  
> }  
> Money.toInt() vs Money.value.toInt()  


## Chapter 13. 하나의 더미

필요한 만큼의 코드를 하나의 더미처럼 느껴질 때까지 흩어진 코드를 모으세요.  
그리고 나서 깔끔하게 정리하세요.  

코드를 만드는 데, 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는 데 드는 비용입니다.  
코드 정리를 선행하면 더 작은 조각 단위로 결합을 제거하는 길을 제시하여 응집도를 높일 수 있습니다.  

작은 코드 조각들이 서로 교류하는 방식은 코드를 더 알기 어렵게 합니다.  
명확성을 되찾으려면, 먼저 코드를 한데 모아서 이해하기 어려운 부분은 추출해서 새롭게 정리해야 합니다.  

다음 증상들을 찾아보기 바랍니다.  
- 길고 반복되는 인자 목록
- 반복되는 코드, 그 중에서도 반복되는 조건문
- 도우미에 대한 부적절한 이름
- 공유되어 변경에 노출된 데이터 구조

이쯤 되면 책 제목에 있는 질문에 이르게 됩니다.  
'Tidy First? 코드를 먼저 정리할까? 아니면 지금 눈에 보이는 것만 먼저 정리할까?'  

> 코드 작성을 두려워하는 사람들이 하는 실수  
> 기존 코드를 복붙하여 본문에서 얘기하는 증상들이 생겨남  
> 
> 기존 코드와 구조에 두려움을 갖지 않는게 중요한 듯  


## Chapter 14. 설명하는 주석

자신이 이 코드를 처음 읽는 사람이라고 가정해 보세요.  
미리 알았더라면 좋았을 점은 무엇인가요?  

요점은 다른 사람의 관점에서 생각하고 예상되는 질문을 선제적으로 언급하려고 노력하는 것입니다.  

파일 앞에 주석이 없는 경우, 설명을 추가하여 파일을 읽는 사람이 얻게 될 유용함을 미리 알려줍니다.  

코드의 결함을 발견했다면, 그 즉시 해당 위치에 주석을 달아야 합니다.  

물론 코드가 이런 식으로 결합되어 있는 것은 바람직하지 않습니다.  
결국, 이를 제거하는 방법을 배워야 하겠지만, 그 때까지는 주석을 달아서 결합도 문제를 미리 지적해 두는 것이, 모래 속에 묻듯 그냥 두는 것보다 훨씬 나을 것입니다.  


## Chapter 15. 불필요한 주석 지우기

코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제하세요.  

코드를 작성하는 목적은 다른 프로그래머에게 컴퓨터가 해야 할 일을 설명하는데 있습니다.  
주석과 코드는 작성할 때와 나중에 볼 때, 시간이 흐르고 나면 서로 맞지 않는 경우가 있습니다.  

# 8 스케줄링: 멀티 레벨 피드백 큐

멀티 레벨 피드백 큐(MLFQ)가 해결하려고 하는 기본적인 문제는 두 가지이다.  

첫째, 짧은 작업을 먼저 실행시켜 반환 시간을 최적화하고자 한다.  
SJF나 STCF 같은 알고리즘은 작업의 실행 시간 정보를 필요로 하지만, 불행히도 운영체제는 이 실행 시간을 미리 알 수 없다.  

둘째, MLFQ는 대화형 사용자에게 응답이 빠른 시스템이라는 느낌을 주고 싶었기 때문에 응답 시간을 최적화한다.  
불행히도 RR과 같은 알고리즘은 응답 시간을 단축시키지만 반환 시간은 거의 최악이다.  

## 8.1 MLFQ: 기본 규칙

MLFQ는 여러 개의 큐로 구성되며, 각각 다른 우선순위가 배정된다.  
실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다.  
MLFQ는 실행할 프로세스를 결정하기 위하여 우선순위를 사용한다.  
높은 우선순위를 가진 작업이, 즉 높은 우선순위 큐에 존재하는 작업이 선택된다.  

큐에 둘 이상의 작업이 존재할 수 있다.  
이들은 모두 같은 우선순위를 가진다.  
이 작업들 사이에서는 RR 스케줄링 알고리즘이 사용된다.  

MLFQ는 각 작업에 고정된 우선순위를 부여하는 것이 아니라 각 작업의 특성에 따라 동적으로 우선순위를 부여한다.  
예를 들어, 어떤 작업이 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 MLFQ는 해당 작업의 우선순위를 높게 유지한다.  
대신에 한 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 MLFQ는 해당 작업의 우선순위를 낮춘다.  

규칙 1: Priority(A) > Priority(B) 이면, A가 실행된다.  
규칙 2: Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다.  

## 8.2 시도 1: 우선순위의 변경

규칙 3: 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다.  
규칙 4a: 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다.  
규칙 4b: 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다.  

스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없기 때문에 일단 짧은 작업이라고 가정하여 높은 우선순위를 부여한다.  
진짜 짧은 작업이면 빨리 실행되고 바로 종료할 것이다.  
짧은 작업이 아니라면 천천히 아래 큐로 이동하게 되고 스스로 긴 배치형 작업이라는 것을 증명하게 된다.  

### 현재 MLFQ의 문제점

첫째, 기아 상태가 발생할 수 있다.  
시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이고 따라서 긴 실행 시간 작업은 CPU 시간을 할당받지 못할 것이다.  

둘째, 똑똑한 사용자라면 스케줄러를 자신에게 유리하게 동작하도록 프로그램을 다시 작성할 수 있다.  
스케줄러를 자신에게 유리하게 동작시킨다는 것은 일반적으로 스케줄러를 속여서 지정된 몫보다 더 많은 시간을 할당하도록 하게 만드는 것을 가리킨다.  

## 8.3 시도 2: 우선순위의 상향 조정

간단한 아이디어는 주기적으로 모든 작업의 우선순위를 상향 조정 하는 것이다.  

규칙 5: 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.  

새 규칙은 두 가지 문제를 한번에 해결한다.  
첫째, 프로세스는 굶지 않는다는 것을 보장받는다.  
둘째, CPU 위주의 작업이 대화형 작업으로 특성이 변할 경우 우선순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용한다.  

## 8.4 시도 3: 더 나은 시간 측정

규칙 4: 주어진 단계에서 시간 할당량을 소진하면, 우선순위는 낮아진다.  

## 8.5 MLFQ 조정과 다른 쟁점들

우선순위가 높은 큐는 보통 짧은 타임 슬라이스가 주어진다.  
이 큐는 대화형 작업으로 구성되고, 결국 이 작업들을 빠르게 교체하는 것은 의미가 있다.  

## 8.6 요약

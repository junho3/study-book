# 2장 인덱스와 인덱싱

MySQL의 성능은 여러 요인이 결정하지만 인덱스 없이는 성능을 달성할 수 없으므로 인덱스는 특별한 존재라고 하겠습니다.  

최적화(Optimizations)는 MySQL 측면에서 하드웨어를 효율적으로 활용하게 해주는 다양한 기술과 알고리즘, 데이터 구조를 의미합니다.  
데이터베이스가 작으면 하드웨어와 최적화로도 충분합니다.  
그러나 데이터 규모가 증가하면서 하드웨어와 최적화라는 조합의 이점은 줄어듭니다.  
이때 인덱스가 없으면 성능이 심각하게 제한됩니다.  

## 2-1 성능 향상과 관련 없는 딴짓

레드헤링: 목표로부터 주의를 딴 데로 돌리는 상황을 나타내는 영어 관용구

### 더 좋고 빠른 하드웨어!

스케일업이 당장은 도움이 되겠지만, 여러분은 아무것도 배우지 못합니다.  

첫째, 하드웨어 성능부족으로 명백하게 느린 거라면 적절한 성능의 하드웨어로 스케일업해야 합니다.  
둘째, 애플리케이션의 사용량이 급증하고 있으며, 하드웨어 스케일업이 애플리케이션 실행에 있어 안정성을 담보하기 위한 임시 방편이라면 이 방법도 시행합니다.  

이러한 예외 상황이 아니라면 MySQL 성능을 향상시킬 목적으로 취하는 하드웨어 확장은 최후의 선택입니다.  

"애플리케이션이 MySQL을 완전히 활용할 수 있는가?"
애플리케이션이 테이블 스캔을 발생시키는 경우 메모리를 늘려도 성능이 향상되지 않을 수 있습니다.  
하드웨어 확장이 애플리케이션 워크로드와 함께 확장될 때만 성능 향상에 효과적입니다.  

> 신규 서비스 오픈할 때는 인프라를 좋은 성능의 하드웨어 투입

### MySQL 튜닝

#### 튜닝

튜닝은 연구개발을 목적으로 MySQL 시스템 변수를 조정하는 행위로 구체적인 목표와 기준이 있는 실험실 수준의 작업입니다.  
그 목표는 특히 현재 한계와 관련하여 MySQL에 대한 우리의 집단 지식과 이해를 확장하는 것입니다.  

#### 구성

구성(configuring)은 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위입니다.  
MySQL 구성은 일반적으로 MySQL 인스턴스가 프로비저닝 되거나 하드웨어가 변경될 때 수행됩니다.  

#### 최적화

최적화(optimizing)는 워크로드를 줄이거나 효율성을 높여 MySQL 성능을 향상시키는 행위입니다.  
목표는 기존 하드웨어로 더 빠른 응답 시간과 더 많은 용량을 제공하는 것입니다.  

엔지니어는 튜닝과 구성, 최적화 작업을 모두 수행하므로 용어 구분이 중요하지만, 이 가운데 최적화 작업만이 여러분의 시간 측면에서 효율성을 높이는 방법입니다.  

MySQL 튜닝은 다음과 같은 두 가지 이유로 성능 측면에서 레드헤링입니다.  
첫째, 그것은 통제된 실험실에서 이루어지는 실험처럼 수행되지 않을 때가 많아 결과가 의심될 수 있습니다.  
둘째, MySQL은 이미 고도로 최적화 되었으므로 튜닝의 결과는 기대보다 성능에 큰 영향을 미치지 않습니다.  


## 2-2 MySQL 인덱스: 시각적 소개

### InnoDB 테이블은 인덱스다

InnoDB 테이블은 프라이머리 키로 구성된 B-트리 인덱스입니다.  
행은 인덱스 구조에서 리프노드에 저장된 인덱스 레코드가 됩니다.  
각 인덱스 레코드에는 로우 락, 트랜잭션 격리 등에 사용되는 메타데이터가 포함되어 있습니다.  

```
               1 .. 4 (pk)                      Root
         ↙                   ↘
      1 .. 2 (pk)    ↔     3 .. 4 (pk)          Internal
    ↙      ↘              ↙        ↘
1 (pk)      2 (pk)      3 (pk)      4 (pk)      Leaf
Ag          Au          Al          Ar
B           Be          Br          Br
C           Co          Cr          Cd
```

- 프라이머리 키 조회(lookup)은 매우 빠르고 효율적입니다.
- 프라이머리 키는 MySQL 성능에서 핵심적인 역할을 합니다.

B-트리 인덱스가 본질적으로 빠르고 효율적이라서 많은 데이터베이스 서버가 이를 채택하고 있다는 것입니다.  

`KEY 'idx_a_b' ('a', 'b')` 세컨더리 인덱스도 B-트리 인덱스지만 리프 노드는 프라이머리 키값을 저장합니다.  
MySQL이 행을 찾으려고 세컨더리 인덱스를 사용하면 전체 행을 읽기 위해 프라이머리 키를 이용하여 두 번째 조회를 수행합니다.  

1. 세컨더리 인덱스 Root 노드에서 시작
2. 세컨더리 인덱스 B-트리 내부 노드에서 검색
3. 세컨더리 인덱스 리프 노드에서 프라이머리 키값 확보
4. 3번에서 확보한 프라미어리 키값으로 프라이머리 키 Root 노드에서 시작
5. 프라이머리 키 B-트리 내부 노드에서 검색
6. 프라이머리 키 리프 노드에서 일치하는 행 확보

MySQL의 세계에서 모든 것은 프라이머리 키를 중심으로 돌아갑니다.  

### 테이블 접근 방법

때로는 쿼리에 따라 인덱스 조회가 불가능할 때도 있으며, 이 때는 인덱스 스캔 또는 테이블 스캔 같은 접근 방법이 유일합니다.  
인덱스 스캔과 테이블 스캔은 피해야 합니다.  

#### 인덱스 조회

인덱스 조회에서는 인덱스의 정렬된 구조와 접근 알고리즘을 활용하여 특정 행이나 행 범위를 찾습니다.  

#### 인덱스 스캔

인덱스 조회가 불가능할 때 MySQL은 전체 데이터 순차 찾기 같은 억지 기법으로 행을 찾아야 합니다.  
즉, 모든 행을 읽고 일치하지 않는 행을 필터링 합니다.  
MySQL은 프라이머리 키로 모든 행을 읽기 전에 세컨더리 인덱스로 행 읽기를 시도합니다.  
이를 **인덱스 스캔**이라고 합니다.  

- 풀 인덱스 스캔
  - 인덱스 순서대로 모든 행을 읽음
  - 인덱스 순서가 `ORDER BY`쿼리와 일치할 때 행 정렬을 피할 수 있음
  - 세컨더리 인덱스를 순서대로 스캔하는 것은 순차 읽기일 수 있지만, 프라이머리 키 조회는 거의 무작위 읽기
- 인덱스 전용 스캔
  - 인덱스에서 열값을 읽음
  - 커버링 인덱스 필요: `select index_column from table where index_column = x` select 절로 인덱스 컬럼만 조회할 때
  - 풀 스캔이 아닌 이상 인덱스 스캔으로 최적화하지 말라

#### 테이블 스캔

풀 테이블 스캔은 프라이머리 키 순서로 모든 행을 읽습니다.  
MySQL이 인덱스 조회나 인덱스 스캔을 수행할 수 없을 때 테이블 스캔이 유일한 옵션입니다.  

테이블 스캔을 허용하거나 더 나은 경우
- 테이블이 작고 접근 빈도가 낮을 때
- 테이블 선택도가 매우 낮을 때

테이블 스캔을 당연하게 여기면 안 됩니다.  
일반적으로 성능에 굉장히 나쁩니다.  


### 맨 왼쪽 접두사(leftmost prefix) 요구사항

인덱스를 사용하려면 쿼리는 인덱스의 맨 왼쪽 접두사 즉 인덱스 정의에서 지정한 맨 왼쪽 인덱스 열로 시적하는 하나 이상의 인덱스 열을 반드시 사용해야 합니다.  
기본적인 인덱스 구조는 인덱스 열 순서에 따라 정렬되므로 맨 왼쪽 접두사가 필요하며 그 순서로만 탐색(검색)할 수 있습니다.  

인덱스 정의를 보려면 `SHOW CREATE TABLE` 또는 `SHOW INDEX` 명령문을 사용하세요.  

맨 왼쪽 접두사에 대한 요구사항은 두 가지 논리적인 결과를 가져옵니다.  

첫째, 인덱스 (a, b)와 (b, a)는 서로 다릅니다.  
같은 열을 인덱싱하고 있지만 순서가 달라서 맨 왼쪽 접두사가 다릅니다.  

둘째, MySQL은 인덱스 (a)와 (a, b) 대신 (a, b, c)를 사용할 가능성이 큽니다.  
인덱스 (a)와 (a, b)는 중복되어 삭제될 수 있습니다.  
중복 인덱스를 찾아 확인하려면 'pt-duplicate-key-checker'를 사용합니다.  

프라이머리 키는 모든 세컨더리 인덱스에 추가됩니다.  

인덱스 (a, b, id)를 생성하여 문자 그대로 프라이머리 키를 추가할 수 있지만 그렇게 하지마세요.  
이는 모든 세컨더리 인덱스의 크기를 증가시키므로 중요합니다.  
즉, 프라이머리 키값은 세컨더리 인덱스에 중복됩니다.  

인덱스가 클수록 더 많은 메모리가 필요한데, 이는 인덱스가 작을수록 메모리를 더 작게 사용한다는 의미이기도 합니다.  
프라이머리 키의 크기를 작게 유지하고 세컨더리 인덱스 수를 적절하게 유지해야 합니다.  


### EXPLAIN: 쿼리 실행 계획

`EXPLAIN` 명령은 MySQL이 쿼리를 실행하는 방법을 설명하는 쿼리 실행 계획 또는 EXPLAIN 계획을 보여 줍니다.  

#### table 필드

`table` 필드는 테이블 이름이나 참조된 서브 쿼리입니다.  

#### type 필드

`type` 필드는 테이블 접근 방법이나 인덱스 조회의 접근 유형입니다.  
- `ALL`: 풀스캔  
- `index`: 인덱스 스캔  

#### possible_keys 필드

`possible_keys` 필드는 쿼리가 맨 왼쪽 접두사를 사용하므로 MySQL이 사용할 수 있는 인덱스를 나열합니다.  

#### key 필드

`key` 필드는 MySQL이 사용할 인덱스의 이름이거나 인덱스를 사용할 수 없을 때에는 `NULL`입니다.  

#### ref 필드

`ref` 필드는 인덱스에서 행을 조회하는 데 사용되는 값의 소스를 나열합니다.  

#### rows 필드

`rows` 필드는 MySQL이 일치하는 행을 찾기 위해 조회할 예상 행의 수입니다.  

#### Extra 필드

`Extra` 필드는 쿼리 실행 계획에 대한 부가 정보를 제공합니다.  
이 필드는 MySQL이 적용할 수 있는 쿼리 최적화를 나타내므로 중요합니다.  


### WHERE

MySQL은 인덱스를 사용하여 `WHERE` 절의 테이블 조건과 일치하는 행을 찾을 수 있습니다.  

`const` 접근 유형은 프라이머리 키나 유니크 세컨더리 인덱스의 모든 인덱스 열에 상수 조건(`ref: const`)이 있을 때만 발생하는 특별한 경우입니다.  
`id = 1`로 식별되는 행은 상수로 처리할 수 있는데, 쿼리가 실행될 때 `id = 1`은 오직 하나의 행만 일치하기 때문입니다.  
다시 말해서, `const` 접근 유형은 매우 빠릅니다.  

```
INDEX (a, b)  
WHERE a = 'AI' AND c = 'Co'  
```
MySQL은 여전히 세컨더리 인덱스를 사용하지만 c 열의 조건은 MySQL이 인덱스만 사용하여 행을 일치시키는 것을 방지합니다.  
대신 MySQL은 인덱스를 사용하여 a열의 조건에 대한 행을 조회하고 읽은 다음, c열의 조건과 일치하는 행을 찾습니다.  

```
INDEX (a, b)
WHERE b = 'Be
```
a열에 조건이 없으므로 b열에 대한 조건에 인덱스를 사용할 수 없습니다.  
`type:ALL`, `possible_keys:NULL` 또는 `key:NULL`이 표시되면 쿼리를 멈추고 분석해야 한다는 의미입니다.  


### GROUP BY

`GROUP BY`를 최적화하기 위해 인덱스를 사용할 수 있습니다.  

```
GROUP BY a에 대한 EXPLAIN 계획
EXPLAIN SELECT a, COUNT(*) FROM elem GROUP BY a
```

`Key: idx_a_b`는 MySQL이 인덱스를 사용하여 `GROUP BY`를 최적화하는지 확인해 줍니다.  
`Extra`필드의 "Using index"는 MySQL이 인덱스에서 오직 a열의 값만 읽고 프라이머리 키에서 전체 행을 읽지 않음을 나타냅니다.  

```
동일한 인덱스 열의 GROUP BY와 WHERE에 대한 EXPLAIN 계획
EXPLAIN SELECT a, COUNT(a) FROM elem WHERE a != 'Ar' GROUP BY a
```

`Extra`필드의 "Using where"는 `WHERE a != 'Ar'`을 나타냅니다.  
흥미로운 점은 `type: range`로 바뀌었다는 것입니다.
'같지 않음'연산자(!= 혹은 <>) 때문에 범위 접근 유형이 작동합니다.  

```
다른 인덱스 열의 GROUP BY와 WHERE에 대한 EXPLAIN 계획
EXPLAIN SELECT a, b FROM elem WHERE b = 'B' GROUP BY a
```

'같음(=)'이 '같지 않음(!=)'으로 변경되면 쿼리 최적화가 손실됩니다.  

```
맨 왼쪽 접두사가 없는 GROUP BY에 대한 EXPLAIN 계획
EXPLAIN SELECT b, COUNT(*) FROM elem GROUP BY b
```

`key: idx_a_b`를 보면 MySQL은 쿼리가 a열에 조건이 없음에도 인덱스를 사용한다는 것을 기억하세요.  
MySQL이 a열의 인덱스(`type: index`)를 스캔하고 있으므로 충족됩니다.  

`GROUP BY c`는 풀 테이블 스캔을 합니다.  
인덱스에 b열값은 있지만 c열값은 없기 때문입니다.  

MySQL은 인덱스에서 a열 값을 읽을 때 임시 테이블(메모리)에서 b열 값을 수집합니다.  
a열의 모든 값을 읽은 후에는 `COUNT(*)`에 의해 그룹화되고 집계된 임시 테이블에 대해 테이블 스캔을 합니다.  


### ORDER BY

MySQL은 `ORDER BY`를 최적화하기 위해 정렬된 인덱스를 사용할 수 있습니다.  
MySQL은 행을 정렬할 때 EXPLAIN 계획의 `Extra`필드에 "Using filesort"를 출력합니다.  
파일 정렬이란 행 정렬을 의미합니다.  
파일 정렬은 느리다는 평판이 있습니다.  

인덱스를 사용하여 `ORDER BY`를 최적화하는 방법은 세 가지가 있습니다.  
1. `ORDER BY`절에 인덱스의 맨 왼쪽 접두사를 사용하는 것입니다. (ex ORDER BY id, ORDER BY a) 
2. 인덱스 상수로 맨 왼쪽 부분을 유지하고 다음에 인덱스 열을 기준으로 정렬하는 것입니다. (ex WHERE a = 'Ar' ORDER BY b) 
3. `WHERE a = 'Ar' And b = 'B' ORDER BY id`

왜 `ORDER BY id`가 파일 정렬을 일으키지 않을까요?  
"모든 세컨더리 인덱스의 끝에는 프라이머리 키가 숨겨져 있습니다."  

`WHERE a = 'Ar' ORDER BY id`는 b열 조건이 제거되어 "using filesort"가 나옵니다.  

인덱스 컨디션 푸시다운은 스토리지 엔진이 인덱스를 사용하여 `WHERE` 조건과 일치하는 행을 찾는다는 의미입니다.  
인덱스 컨디션 푸시다운은 응답 시간을 개선하는 데 도움이 되지만, MySQL이 가능한 경우 자동으로 사용하므로 최적화하려고 노력하지 않아도 됩니다.  

`ORDER BY a, b DESC`에서 a열은 b DESC와 달리 암시적 ASC 정렬이므로 해당 정렬은 작동하지 않습니다.  

MySQL 8.0.18부터 `EXPLAIN ANALYZE`가 패널티를 측정하여 보고합니다.  

MySQL은 데이터 정렬이 `sort_buffer_size`를 초과할 때 디스크의 임시 파일을 사용하게 되고 하드 드라이브는 메모리보다 수십 배 느립니다.  
그러나 오늘날에는 SSD가 표준이며 이 스토리지는 일반적으로 매우 빠릅니다.  
파일 정렬은 높은 처리량(QPS)의 쿼리에 문제가 될 수 있으므로 `EXPLAIN ANALYZE`를 사용하여 측정하고 확인해야 합니다.  


### 커버링 인덱스

커버링 인덱스를 사용하면 MySQL은 인덱스에서 열값만 읽을 수 있습니다.  
이는 프라이머리 키 조회를 피할 수 있어서 세컨더리 인덱스에 가장 유용합니다.  

커버링 인덱스는 매력적이지만 실제 쿼리에서는 인덱스 하나가 맡기에는 너무 많은 열과 조건, 절이 있어서 실용적이지 않습니다.  


### 테이블 조인

접근 유형 `eq_ref`는 프라이머리 키나 유니크 not-null 세컨더리 인덱스를 사용하는 단일 행 조회를 의미합니다.  
`eq_ref` 접근 유형을 사용하는 인덱스 조회가 가장 좋으며 빠릅니다.  
`eq_ref` 조회가 최대 하나의 행과 일치하도록 보장합니다.  

때로는 MySQL이 선택한 테이블 조인 순서와 인덱스를 이해하려거나 MySQL이 쿼리를 재작성하는 방법을 보기 위해서는 `EXPLAIN`을 실행한 후에 `SHOW WARNINGS` 명령을 실행해 보세요.  

MySQL은 쿼리에 작성되는 테이블 순서가 아니라 가능한 한 최상의 순서로 테이블을 조인하므로 테이브 조인 순서가 중요합니다.  
`EXPLAIN`은 조인 순서에 따라 위에서 아래로 테이블을 출력합니다.  
기본 조인 알고리즘인 중첩 반복 조인은 조인 순서를 따릅니다.  

쿼리를 조금만 변경해도 테이블 조인 순서나 쿼리 실행 계획이 크게 달라질 수 있으므로 테이블 조인 순서를 추측하거나 추정해서는 안 됩니다.  

MySQL은 인덱스 없이 테이블 조인을 할 수 있습니다.  
이것을 `풀 조인`이라고 하며 쿼리가 수행할 수 있는 최악의 작업입니다.  


## 2-3 인덱싱: MySQL처럼 생각하는 방법

인덱스와 인덱싱은 다른 주제입니다.  

엔지니어들이 인덱싱에 어려움을 겪는 이유는 자신이 쿼리에 대해 생각하는 방식을 MySQL이 쿼리에 대해 생각하는 방식과 혼동하기 때문입니다.  
엔지니어로서 우리는 애플리케이션 맥락에서 쿼리를 생각합니다.  
MySQL은 인덱스와 테이블 조건이라는 훨씬 더 작고 단순한 맥락에서 쿼리를 생각합니다.  

### 쿼리 알기

MySQL처럼 생각하는 첫 번째 단계는 최적화하려는 쿼리의 기본 정보를 파악하는 것입니다.  

- SHOW CREATE TABLE
- SHOW TABLE STATUS
- SHOW INDEXES

#### 쿼리

- 쿼리는 몇 개의 행에 접근해야 합니까?
- 쿼리는 몇 개의 행을 반환해야 합니까?
- 어떤 열이 선택(반환)됩니까?
- GROUP BY, ORDER BY, LIMIT 절(있는 경우)은 무엇입니까?
- 하위 쿼리(subqueries)가 있습니까? (있다면 각 쿼리에 대해 이 과정을 반복합니다)

#### 테이블 접근(테이블마다)

- 테이블 조건은 무엇입니까?
- 쿼리는 어떤 인덱스를 사용해야 합니까?
- 쿼리가 사용할 수 있는 다른 인덱스는 무엇입니까?
- 각 인덱스의 카디널리티는 무엇입니까?
- 테이블의 크기(데이터 크기와 행 수)는 얼마입니까?


### EXPLAIN으로 이해하기

두 번째 단계는 `EXPLAIN`에서 보고한 현재 쿼리 실행 계획을 이해하는 것입니다.  
`EXPLAIN` 출력의 `key` 필드부터 시작하여 인덱스와 관련된 각 테이블과 해당 조건을 고려합니다.  
`possible_keys` 필드에 다른 인덱스가 나열되었으면, 항상 맨 왼쪽 접두사에 대한 요구사항을 염두에 두고 MySQL이 해당 인덱스를 사용하여 행에 접근하는 방법을 생각합니다.  

쿼리와 응답 시간은 하나의 퍼즐이고, 여러분은 실행 계획, 테이블 조건, 테이블 구조, 테이블 크기, 인덱스 카디널리티, 쿼리 메트릭과 같은 퍼즐 조각을 모두 가지고 있습니다.  

- MySQL 8.0.16에서 EXPLAIN FORMAT=TREE
- 옵티마이저 트레이싱
- DBA에게 문의


### 쿼리 최적화

세 번째 단계는 직접 쿼리 최적화로 쿼리, 인덱스 또는 둘 모두를 변경합니다.  

단순 쿼리가 느릴 때는 쿼리가 아닌 인덱스를 변경해야 할 가능성이 큽니다.  
그리고 인덱스 변경으로 문제가 해결되지 않으면 간접 쿼리 최적화로 여정을 옮겨야 합니다.  


### 배포와 검증

마지막 단계는 변경 사항을 배포하고 응답 시간이 개선되는지 검증하는 것입니다.  
하지만 먼저 변경 사항으로 인해 의도하지 않은 부작용이 발생할 경우 배포를 되돌릴 방법을 확인하고 준비해야 합니다.  


## 2-4 좋은 인덱스였는데...

현실적으로는 무언가 변해서 좋은 인덱스를 나쁘게 만들고 성능을 떨어뜨립니다.  

### 쿼리 변경

쿼리가 변경될 때 맨 왼쪽 접두사에 대한 요구사항이 손실될 수 있습니다.  

### 과도하고 중복되며 사용되지 않음

인덱스가 과도하면 2가지 문제가 발생합니다.  
1. 인덱스가 많아지면 더 많은 메모리를 사용하므로 아이러니하게도 각 인덱스에 사용할 수 있는 메모리가 줄어듭니다.  
2. MySQL이 데이터를 작성할 때 모든 인덱스를 확인하고 갱신하고, 잠재적으로 재구성해야 하므로 쓰기 성능이 떨어진다는 것입니다.  

중복 인덱스를 만들 때, 인덱스를 만드는 데 사용되는 `ALTER` 문은 경고를 알리지만, 이를 보려면 `SHOW WARNINGS`를 실행해야 합니다.  
기존의 중복 인덱스를 찾으려면 pt-duplicate-key-checker를 사용하세요.  

사용되지 않은 인덱스는 식별하기가 훨씬 더 까다롭습니다.  
극단적인 경우를 제외하고 다음 쿼리를 실행하여 사용되지 않는 인덱스를 나열합니다.
```
SHOW CREATE VIEW sys.schema_unused_indexes;

SELECT * FROM sys.schema_unused_indexes
WHERE object_schema NOT IN ('performance_schema);
```

인덱스를 삭제할 때는 주의해야 합니다.  
`MySQL 8.0부터 인비저블 인덱스`로 인덱스를 보이지 않게 하고 성능에 영향을 미치지 않는지 확인한 다음 인덱스를 삭제할 수 있다.  


### 최고의 선택도

카디널리티는 인덱스의 고윳값 수입니다.  
선택도는 카디널리티를 테이블의 행 수로 나눈 값입니다.  
카디널리티에는 `SHOW INDEX`를 사용하고 행 수에는 `SHOW TABLE STATUS`를 사용하여 직접 계산해야 합니다.  

선택도가 매우 낮은 인덱스는 각 고윳값이 많은 수의 행과 일치할 수 있으므로 거의 영향력이 없습니다.  
ex) true / false 컬럼  

쿼리에서 선택도가 매우 낮은 인덱스를 사용하는 경우, 더 나은 선택도를 갖는 인덱스를 만든 수 있는지 확인하거나 더 나은 선택도를 갖는 인덱스를 사용하도록 쿼리를 다시 작성하는 것이 좋습니다.  
또는 접근 패턴과 관련하여 데이터를 잘 구성하도록 스키마를 변경하는 것을 생각해 보세요.  

선택도가 매우 높은 세컨더리 인덱스가 많은 경우, 다른 기준이나 차원으로 전체 테이블을 보거나 검색하는 접근 패턴을 나타낼 가능성이 높습니다.  


### 이것은 함정이다! - MySQL이 다른 인덱스를 선택할 때

매우 드물지만 MySQL이 인덱스를 잘못 선택하기도 합니다.  
일반적인 이유는 많은 수의 행을 갱신할 때 갱신된 행 수가 인덱스 '통계'의 자동 갱신을 유발하기에는 조금 모자라기 때문입니다.  

MySQL은 다음과 같은 경우 테이블에 대한 인덱스 통계를 갱신합니다.  
- 테이블이 처음으로 열릴 때
- ANALYZE TABLE 명령이 실행되었을 때
- 마지막 업데이트 이후 테이블의 1/16이 수정되었을 때
- innodb_stats_on_metadata가 활성화되고 다음 중 한 경우일 때
  - SHOW INDEX나 SHOW TABLE STATUS 명령어가 실행될 때
  - INFORMATION_SCHEMA.TABLES가 조회되었을 때
  - INFORMATION_SCHEMA.STATISTICS가 조회되었을 때

`ANALYZE TABLE`을 실행하는 것은 안전하면서 대체로 매우 빠르지만 사용량이 많은 서버에서는 주의해야 합니다.  
테이블에 접근하는 모든 쿼리를 차단할 수 있는 플러시 잠금이 필요하기 때문입니다.  


## 2-5 테이블 조인 알고리즘

기본 테이블 조인 알고리즘은 중첩 반복 조인이라고 하며 코드에서 사용하는 중첩 `foreach` 반복문처럼 작동합니다.  

가장 안쪽 테이블에 상당히 자주 접근하고 풀 조인을 사용하면 접근 속도가 매우 느려진다는 것입니다.  
블록 중첩반복 조인 알고리즘이 이 문제를 해결합니다.  
t1과 t2에서 일치하는 행의 조인 열값은 조인 버퍼에 저장됩니다.  

MySQL 8.0.20부터 해시 조인 알고리즘이 블록 중첩 반복 조인 알고리즘을 대체합니다.  
해시 조인은 조인 테이블을 메모리 내에 해시 테이블로 생성합니다.  



# 2장 자바 메모리 영역과 메모리 오버플로

## 2.1 들어가며

하지만 통제권을 위임했기 때문에 문제가 한번 터지면 가상 머신의 메모리 관리 방식을 이해하지 못하는 한 해결하기가 상당히 어렵다.  

## 2.2 런타임 데이터 영역

### 2.2.1 프로그램 카운터

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기'라고 생각하면 쉽다.  

스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다.  
따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립적인 영역에 저장된다.  
이 메모리 영역을 스레드 프라이빗 메모리라고 한다.  


### 2.2.2 자바 가상 머신 스택

자바 가상 머신 스택도 '스레드 프라이빗'하며, 연결된 스레드와 운명을 같이 한다.  
그런 다음 스택 프레임을 가상 머신 스택에 푸시하고 메서드가 끝나면 팝하는 일을 반복한다.  

'스택'이라고 하면 보통 자바 가상 머신 스택을 가리키는데, 특히 지역 변수 테이블을 가리킬 때가 많다.  

지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라 한다.  
일반적으로 슬록의 크기는 32비트이다.  
지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다.  

스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크다면 `StackOverflowError`를 던진다.
여유 메모리가 충분하지 않다면 `OutOfMemoryError`를 던진다.


### 2.2.3 네이티브 메서드 스택

가상 머신 스택은 자바 메서드(바이트코드)를 실행할 때 사용하고, 네이티브 메서드 스택은 네이티브 메서드를 실행할 때 사용한다.  

```
네이티브 메서드  
JNI는 Java 프로그램이 다른 언어로 작성된 프로그램과 상호 작용할 수 있게 해주는 인터페이스로 C 와 C++ 로 작성된 프로그램과의 상호작용을 위해 사용됩니다.  
native 키워드를 사용하여 선언되며 실제 구현은 Java가 아닌 C/C++ 로 작성됩니다.  
start0() 메소드는 OS 가 바로 읽을 수 있는 형태의 native code 를 호출하기 위해 native 메소드를 사용하고 있는 예가 됩니다.  

https://ones1kk.tistory.com/entry/Java-Native-Method
```


### 2.2.4 자바 힙

자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다.  
힙 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것이고, 자바 세계의 '거의'모든 객체 인스턴스가 이 영역에 할당된다.  

자바 힙은 가비지 컬렉터가 관리하는 메모리 영역이기 때문에 GC 힙이라고도 한다.  

자바 힙을 다시 작게 구분하는 목적은 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.  

자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관없으나 논리적으로는 연속되어야 한다.  


### 2.2.5 메서드 영역

메서드 영역도 모든 스레드가 공유한다.  
메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는 데 이용된다.  


### 2.2.6 런타임 상수 풀

런타임 상수 풀은 메서드 영역의 일부다.  
상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.  


### 2.2.7 다이렉트 메모리

다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 자바 가상 머신 명세에 정의된 영역도 아니다.  

> OS에서 관리하는 메모리 영역으로 이해 함  
> Network I/O 과정에서 힙 메모리로 변환하면 느리기 때문에 물리적인 메모리를 직접 사용하여 속도를 향상시킴  
> 
> [NIO] JAVA NIO의 ByteBuffer와 Channel로 File Handling에서 더 좋은 Perfermance 내기!  
> http://eincs.com/2009/08/java-nio-bytebuffer-channel-file/  


## 2.3 핫스팟 가상 머신에서의 객체 들여다보기

### 2.3.1 객체 생성

객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라주는 일이라 할 수 있다.  

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리하며, 포인트거 두 영역의 경계인 가운데 지점을 가리키게 될 것이다.  
이 상태에서 메모리를 할당하면 포인터를 여유 공간 쪽으로, 정확히 객체 크기만큼 이동시키게 된다.  
이러한 할당 방식을 `포인터 밀치기`라고 한다.  

하지만 자바 힙은 규칙적이지 않다.  
사용 중인 메모리와 여유 메모리가 뒤섞여 있어서 포인터를 밀쳐 내기가 그리 간단하지 않다.  
그 대신 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리하며, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당한 후 목록을 갱신한다.  
이 할당 방식을 `여유 목록`이라 한다.  

어떤 방식을 쓸지는 자바 힙(가비지 컬렉터)이 규칙적이냐 아니냐에 따라 달라진다.  

여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 생길 수 있다.  

해법은 두 가지다.  
첫 번째는 메모리 할당을 동기화하는 방법이다.  
두 번째는 스레드마다 다른 메모리 공간을 할당하는 방법이다.  
이런 메모리를 `스레드 로컬 할당 버퍼(TLB)`라고 한다.

메모리 할당이 끝났으면 가상 머신은 할당받은 공간을 0으로 초기화한다.  
자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 바로 이 단계 덕이다.  

> NULL을 의미하는 것인지?

일반적으로 new 명령어에 이어서 <init>() 메서드까지 실행되어 객체를 개발자의 의도대로 초기화해야 비로소 사용 가능한 진짜 객체가 완성된다.  

자바 컴파일러는 자바의 new 키워드를 발견하면 바이트코드 명령어인 `new(메모리 할당)`와 `invokespecial(<init>() 호출)`로 변환한다.  


### 2.3.2 객체의 메모리 레이아웃

핫스팟 가상 머신은 객체를 세 부분으로 나눠 힙에 저장한다.  
바로 객체 헤더, 인스턴스 데이터, 길이 맞추기용 정렬 패딩이다.  


#### 객체 헤더

첫 번째 유형은 객체 자체의 런타임 데이터다.  
해시 코두, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드의 아이디, 편향된 시각의 타임스탬프 등이다.  
이 부분을 마크 워드라고 하며, 데이터 구조는 동적으로 의미가 달라진다.  
작은 공간에 가능한 한 많은 정보를 담고, 객체 상태에 따라 공간으 재활용할 수도 있게 하기 위해서이다.  

객체 헤더에서 마크 워드 다음에는 클래스 워드가 온다.  
클래스 워드에는 객체의 클래스 관려 메타데이터를 가리키는 클래스 포인터가 저장된다.  
자바 가상 머신은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.  

추가로 자바 배열의 경우 배열 길이도 객체 헤더에 저장한다.  
위치는 클래스 위드 다음이다.  


#### 인스턴스 데이터

객체 레이아웃의 두 번째 부분인 인스턴스 데이터는 객체가 실제로 담고 있는 정보다.  

핫스팟 가상 머신은 기본적으로 long double, int, short char, byte boolean, 일반 객체 포인터 순으로 할당한다.  


#### 정렬 패딩

마지막 세 번째 부분은 정렬 패딩이다.  
이 부분은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 한다.  
객체 헤더는 정확히 8바이트의 정수배가 되도록 잘 설계되어 있다.  
따라서 인스턴스 데이터가 조건을 충족하지 못하는 경우에만 패딩으로 채운다.  


### 2.3.3 객체에 접근하기

객체에 접근하는 방식 역시 가상 머신에서 구현하기 나름이며, 주로 핸들이나 다이렉트 포인터를 사용해 구현한다.  

핸들 방식에는 자바 힙에 핸들 저장용 풀이 별도로 존재할 것이다.  
참조에는 객체의 핸들 주소가 저장되고 핸들에는 다시 해당 객체의 인스턴스 데이터, 타입 데이터, 구조 등의 정확한 주소 정보가 담길 것이다.  
핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다.  
그 대신 핸들 내의 인스턴스 데이터 포인터만 변경하면 된다.  

다이렉트 포인터 방식에서는 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다.  
스택의 참조에는 객체의 실제 주소가 바로 저장되어 있다.  
다이렉트 포인터 방식의 가장 큰 장점은 속도다.  


## 2.4 실전: OutOufMemoryError 예외

### 2.4.1 자바 힙 오버플로

`-XX:+HeapDumpOnOutOfMemoryError` 매개 변수를 설정하면 메모리가 오버플로 됐을 때 가상 머신이 예외 발생 시점의 힙 메모리 스냅숏을 파일로 저장해 준다.  

이 메모리 문제를 해결하는 일반적인 방법은 메모리 이미지 분석 도구로 힙 덤프 스냅숏을 분석해 보는 것이다.  
다시 말해 메모리 누수인지, 오버플로인지 확인한다.  

메모리 누수라면 도구를 이용해 누수된 객체로부터 GC 루트까지의 참조 사슬을 살펴본다.  

메모리 누수가 아니라면, 먼저 자바 가상 머신의 힙 매개 변수 설정(-Xmx와 -Xms)과 컴퓨터의 가용 메모리를 비교하여 가상 머신에 메모리를 더 많이 할당할 수 있는지 알아본다.  


### 2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로

1. 스레드가 요구하는 스택 깊이가 가상 머신이 허용하는 최대 깊이보다 크면 StackOverflowError를 던진다.  
2. 가상 머신이 스택 메모리를 동적으로 확장하는 기능을 지원하나, 가용 메모리가 부족해 스택을 더 확장할 수 없다면 OutOfMemoryError를 던진다.

스택 용량이 부족하여 새로운 스택 프레임을 담을 수 없을 때만 StackOverflowError가 발생한다.  

새로운 스택 프레임용 메모리를 할당할 수 없었다면 핫스팟 가상 머신은 StackOverflowError를 던진다.  

똑같은 코드가 스택 코기를 동적으로 확장할 수 있는 클래식 VM에서는 StackOverflowError가 아닌 OutOfMemoryError를 일으켰다.  

스레드를 계속 만들어 내면 핫스팟에서도 메모리 오버플로를 일으킬 수 있다.  
이렇게 일으키는 오버플로는 운영 체제 자체의 메모리 사용 상태에 영향을 크게 받는다.  
가상 머신은 기본적으로 자바 스레드를 운영 체제의 커널 스레드와 매핑시키므로 스레드를 무한정 만들면 운영 체제에 엄청난 압박을 준다.  
스레드를 너무 많이 만들어서 운영 체제가 멈춰 버릴 수도 있다.  

스레드를 더 많이 만들 수 있는 유일한 방법은 최대 힙 크기와 스택 용량을 줄이는 것뿐이다.  
메모리 오버플로를 해결하기 위해 '메모리 용량을 줄인다'는 아이디어는 이 분야에 경험이 없다면 떠올리기 쉽지 않다.  


### 2.4.3 메서드 영역과 런타임 상수 풀 오버플로

런타임 상수 풀은 메서드 영역에 속하므로 이 두 영역의 오버플로 테스트는 함께 수행할 수 있다.  
핫 스팟은 JDK 7부터 영구 세대를 점진적으로 없애기 시작하여 JDK 8에 와서 메타스페이스로 완전히 대체했다.  

하지만 같은 코드를 JDK 7 이상에서 실행하면 아무런 예외도 던지지 않고 무한 루프를 돌며 절대 멈추지 않는다.  
이유는 영구 세대에 저장했던 문자열 상수 풀을 JDK 7부터 자바 힙으로 옮겼기 때문이다.  

반면 JDK 7 이상 intern() 메서드는 분자열 인스턴스를 영구 세대에 복사할 필요가 없다.  
문자열 상수 풀 위치가 자바 힙이므로 그저 풀에 있는 첫 번째 인스턴스의 참조로 바꿔주면 된다.  
따라서 intern()이 반환하는 참조는 StringBuilder가 생성한 문자열 인스턴스와 같다.  

> 코드 레벨에서는 동일하더라도 JDK 버전에 따라 결과가 다르게 나오는게 흥미로움  
> JDK 버전 올릴 때 주의가 필요해보이고, 테스트 코드의 필요성과 중요성이 느껴지는 대목  

가비지 컬렉터가 클래스 하나를 회수해 가기 위한 조건은 생각보다 까다로운 편이다.  
애플리케이션에서 빈번히 실행되는 코드가 동적 클래스를 많이 생성한다면 이 클래스들을 회수하는 시점에 특별히 신경 써야 한다.  

JDK 8부터는 영구 세대가 완전히 사라졌고, 대체제로 메타스페이스를 이용한다.  
그래서 기본 설정으로 실행할 경우 앞의 테스트들과 같은 일반적인 동적 생성 시나리오로는 메서드 영역에서 오버플로를 일으키기 어렵다.  


### 2.4.4 네이티브 다이렉트 메모리 오버플로

다이렉트 메모리에서 발생한 메모리 오버플로의 특징은 힙 덤프 파일에서는 이상한 점을 찾을 수 없다는 것이다.  
메모리 오버 플로로 생성된 덤프 파일이 매우 작다면 그리고 프로그램에서 DirectMemory를 직접 또는 간접적으로 사용했다면, 다이렉트 메모리에서 원인을 찾는 데 집중해야 할 것이다.  



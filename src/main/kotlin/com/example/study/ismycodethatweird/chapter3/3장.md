# 3장 클래스 설계: 모든 것과 연결되는 설계 기반

유지 보수와 변경이 쉬운 코드를 작성하려면, 관심사 분리가 중요하다.  

## 3.1 클래스 단위로 잘 동작하도록 설계하기

클래스는 클래스 하나로도 잘 동작할 수 있게 설계해야 한다.  
또한, 복잡한 초기 설정을 하지 않아도 곧바로 사용할 수 있게 만들어야 한다.  
클래스를 마음대로 조작해서 클래스 전체가 고장 나는 일(버그)이 없게 최소한의 조작 방법(메서드)만 외부에 제공해야 한다.

### 3.1.1 클래스의 구성 요소

잘 만들어진 클래스의 요소
- 인스턴스 변수
- 인스턴스 변수에 잘못된 값이 할당되지 않게 막고, 정상적으로 조작하는 메서드

### 3.1.2 모든 클래스가 갖추어야 하는 자기 방어 임무

다른 클래스를 사용해서 초기화와 유효성 검사를 해야 하는 클래스는 그 자체로는 안전하게 사용할 수 없는 미성숙한 클래스이다.  
클래스 스스로 자기 방어 임무를 수행할 수 있어야 소프트웨어의 품질을 높이는 데 도움이 된다.  

## 3.2 성숙한 클래스로 성장시키는 설계 기법

### 3.2.1 생성자로 확실하게 정상적인 값 설정하기

인스턴스 변수를 모드 초기화하는 데 필요한 매개변수들을 받는 생성자를 만든다.  
잘못된 값이 유입되지 못하게 유효성 검사를 생성자 내부에 정의한다.  
코드 3.4의 생성자처럼 처리 범위를 벗어나는 조건을 메서드 가장 앞 부분에서 확인하는 코드를 가드라고 부른다.  

> Code_3_4.kt 참고  
> 코틀린은 init 블럭과 require()로 체크  

### 3.2.2 계산 로직도 데이터를 가진 쪽에 구현하기

> Code_3_4.kt 참고

### 3.2.3 불변 변수로 만들어서 예상하지 못한 동작 막기

변수의 값이 계속해서 바뀌면, 값이 언제 변경되었는지, 지금 값은 무엇인지 계속 신경 써야 한다.  
비즈니스 요구 사항이 바뀌어서 코드를 수정하다가 의도하지 않은 값을 할당하는 '예상하지 못한 부수 효과'가 쉽게 발생할 수 있다.  
이를 막으려면, 인스턴스 변수를 불변으로 만든다.  

### 3.2.4 변경하고 싶다면 새로운 인스턴스 만들기

인스턴스 변수의 내용을 변경하는 것이 아니라, 변경된 값을 가진 새로운 인스턴스를 만들어서 사용하면 된다.  

> Code_3_4.kt 참고

### 3.2.5 메서드 매개변수와 지역 변수도 불변으로 만들기

메서드의 매개변수와 지역 변수는 메서드 내부에서 변경할 수 있다.  
매개변수와 지역 변수에 final을 붙여서 불변으로 만든다.  

> 코틀린은 val로 변수를 선언하면 기본적으로 불변

### 3.2.6 엉뚱한 값을 전달하지 않도록 하기

엉뚱한 값이 전달되지 않도록 하려면, Money 자료형만 매개변수로 받을 수 있게 메서드를 변경하면 된다.  

> 코틀린은 value class로 대응 가능  
> Code_3_4.kt 참고  

### 3.2.7 의미 없는 메서드 추가하지 않기

시스템 사양에 필요하지 않은 메서드를 선의로 추가했다면, 이후에 누군가가 이를 무심코 사용했을 때 버그가 될 수 있다.  

## 3.3 악마 퇴치 효과 검토하기

클래스 설계란 인스턴스 벼수가 잘못된 상태에 빠지지 않게 하기 위한 구조를 만드는 것이라고 해도 과언이 아니다.  
같은 데이터라고 해도 메서드 매개변수, 지역 변수, static 변수로 설계했다면 악마의 공격을 방어할 수 없다.  

## 3.4 프로그램 구조의 문제 해결에 도움을 주는 디자인 패턴

- 완전 생성자: 잘못된 상태로부터 보호함
- 값 객체: 특정한 값과 관련된 로직의 응집도를 높임
- 전략: 조건 분기를 줄이고, 로직을 단순화함
- 정책: 조건 분기를 단순화하고, 더 자유롭게 만듦
- 일급 컬렉션: 값 객체의 일종으로 컬렉션과 관련된 로직의 응집도를 높임
- 스프라우트 클래스: 기존 로직을 변경하지 않고, 안전하게 새로운 기능을 추가함

### 3.4.1 완전 생성자

### 3.4.2 값 객체

'값 객체 + 완전 생성자'는 객체 지향 설계에서 폭넓게 사용되는 기법이라고 할 수 있다.  


# Part 02. 관리

코드 정리 작동 방법은 실천을 통해서 익힐 수 있습니다.  
항상 한 번에 조금씩이라면 괜찮습니다.  
그렇게 소프트웨어 설계에 익숙해지기 바랍니다.  
코드 정리는 리팩토링으로 가는 관문입니다.  


## Chapter 16. 코드 정리 구분

코드 정리는 별도의 PR로 만들고, 가급적 PR당 몇 개의 코드 정리만 넣습니다.  

첫 단계에서는 그냥 변경 작업을 하는 즉, 변경을 구분하지 않은 상태에서 다수의 변경을 반영하기 시작합니다.  
예를 들어, if 문을 변경하는 도중에 이름이 잘못되었다는 것을 깨닫고 이름을 변경한 후 다시 if 문으로 돌아가는 경우를 생각해 봅시다.  
변경은 변경을 낳습니다.  

변경 대상 중에는 프로그램 동작 변경이 있습니다.  
반면, 어떤 변경은 프로그램 구조 변경입니다.  
이 시점(두번째 단계)에서는 아직 계획도 없고, 바뀌는 동작 변경과 구조 변경 사이에 어떤 흐름도 없습니다.  
서로 다른 두 가지가 함께 작용하고 있다고 이제 막 인식했을 뿐입니다.  

이 과정(세번째 단계)이 조금 지나면 공통 흐름을 알아채기 시작합니다.  
비슷한 코드끼리 정리하면 설명하는 도우미가 드러나고, 설명하는 도우미를 만들면 이어지는 동작 변경이 훨씬 쉬워집니다.  
다만 아직 큰 PR 한 개에 섞여 있을 뿐임을 주의합니다.  
쉽게 변경하던가 또는 변경하기 쉽게 만들던가, 둘 중 하나를 목표로 삼는 것이 좋습니다.  

그러니 우리는 변경 사항을 나누어 별도의 PR로 만들어야 합니다.  
순서가 있는 일련의 코드 정리는 PR 한 개로 만듭니다.  
코드 정리와 동작 변경 사이를 번갈아 가면서 전환할 때마다 새 PR을 열어야 합니다.  

크고 포괄적인 PR로 만들면 전체 그림을 보여주지만, 검토하는 입장에서는 유용한 피드백을 제공하기에는 너무 큰 덩어리일 수 있습니다.  
반대로 아주 작은 PR은 소소한 피드백을 유도할 수 있지만, 잡초처럼 무시될 우려가 있습니다.  

대체로 코드를 느리게 검토한다면, 더 큰 PR을 만드는 결과를 초래하여, 향후 검토를 더욱 느리게 만듭니다.  

> PR 검토 사이클 속도를 올리려면 어떻게 하면 좋을까?  
> 
> 책 내용처럼 진행하려면 준 실시간으로 PR 검토가 이루어져야 한다고 봄  
> 준 실시간으로 돌아가기 위해서는 모든 구성원들이 업무의 0순위는 PR 검토이고, 따라서 PR 검토가 중요한 이유를 이해해야 함  
> PR 검토가 0순위에서 1순위로 되는 순간, 업무 우선 순위에 밀려 지연되는 듯  
> 개인적으로 PR 검토는 자발적이어야하며, PR 홍보를 좋아하진 않음  
> 왜냐하면 PR을 홍보하면, 검토자가 LGTM 승인을 해버릴 것 같은 느낌  
>
> 최근에 'PR 검토(승인)을 왜 주저하는가?'에 대한 논의를 했었음  
> 1. 코드 뒤에 숨겨진 업무 맥락을 몰라서
> 2. 다른 업무로 인해 PR 검토 시간 부족
> 3. 코틀린 코드를 잘 몰라서 (개발 이해도, 지식 부족)
> 4. 완벽한 검토를 해야한다는 생각 때문에 전체 맥락을 확인하느라 검토하는데 시간을 너무 많이 사용
> 
> 이에 대한 해결책으로
> 1. 업무 맥락을 모르면, 문법이나 컨벤션만 확인하기  
> 2. 업무를 시작하기 전에 일정 시간은 무조건 PR 검토하기  
> 3. 지식을 올리려면 팀 차원에서 학습해야하나 부담스러운건 사실 (보류)  
> 4. 1번 해결책으로 대체. 업무 맥락을 아는 메인터너가 책임져야 하며, 반드시 메인터너의 승인이 있어야 함     
>
> 보통 하나의 PR에 B(동작) 커밋을 하고 S(구조) 커밋으로 진행하는 듯  
> 변경이 있기 때문에 구조 변경이 발생한다고 생각해서 B와 S를 분리해서 작업하는건 불가능하고, 검토자가 이해를 못 할 가능성이 높다고 생각함  
> "왜 구조가 변경되는 것인지?" 그리고 "변경할 구조가 올바른 방향인지?" 알기 어려움  
> S가 매우 크다고 판단될 경우(신규 결제수단 추가), S PR 완료 후 B PR 진행
> 
> Git lable을 사용해서 feature와 refactoring으로 PR 구분  


## Chapter 17. 연쇄적인 정리

코드를 계속 정리하고 싶은 충동을 관리하는 것도 코드 정리의 핵심 기술입니다.  

아주 작은 단계로 나누어 코드를 정리하는 방식을 고수하면서 실험해 보는 것입니다.  

코드 정리를 하고 난 후에는 다음 수를 두는 것처럼 다음에 어떤 정리를 할지 살펴봅시다.  

1. 보호 구문 
   1. early return 
   2. 조건을 설명하는 도우미 추출 가능 
   3. 설명하는 변수 추출 가능
2. 안 쓰는 코드 
   1. 코드를 읽는 순서에 맞춰 정렬 가능 
   2. 응집도를 높이는 배치로 정리 가능
3. 대칭으로 맞추기
   1. 유사한 코드를를 순서대로 읽기 가능
4. 새로운 인터페이스로 기존 루틴 부르기
5. 읽는 순서
   1. 대칭으로 맞추기 가능
6. 응집도를 높이는 배치
   1. 하위 요소로 추출 가능
7. 설명하는 변수
   1. 도우미 추출 가능
   2. 불필요한 주석 삭제 가능
8. 설명하는 상수
   1. 응집도를 높이는 배치로 정리 가능
9. 명시적인 매개변수
   1. 매개변수 집합을 묶어 객체로 만들기 가능
   2. 새로운 추상화 도출 가능
10. 비슷한 코드끼리
    1. 설명하는 주석 추가 가능
    2. 도우미로 추출 가능
11. 도우미 추출
    1. 보호 구문 도입 가능
    2. 설명하는 상수, 변수 추출 가능
    3. 불필요한 주석 제거 가능
12. 하나의 더미
    1. 도우미 추출 가능
    2. 설명하는 주석 정리 가능
13. 설명하는 주석
    1. 주석 내용을 코드로 구현 가능
14. 불필요한 주석 지우기

### 결론

너무 많이 너무 빠르게 변경하지 않도록 주의하세요.  
대개 작은 정리를 순차적으로 성공하는 것이 무리한 정리로 실패하는 것보다 시간을 아껴줍니다.  


## Chapter 18. 코드 정리의 일괄 처리량

통합과 배포를 하기전에 코드 정리는 어느 정도 크기가 적절할까요?  
- 기본적으로 코드 정리는 먼 미래를 바라보는 것이 아니기 때문에 즉각적인 필요를 다뤄야 합니다.  


모든 코드 정리를 한꺼번에 할 것인지, 아니면 모두 개별적으로 할 것인지, 아니면 그 중간을 택할 것인지에 대한 의문은 여전히 남아 있습니다.  

### 충돌

일괄 처리하는 코드 정리 작업이 많을수록, 통합 과정에서 지연 시간이 길어지고, 코드 정리 작업이 다른 사람의 진행 중인 작업과 충돌할 가능성도 커집니다.  
코드 병합 과정에서 충돌이 발생할수록 작업을 병합하는 비용 또한 큰 폭으로 증가합니다.  

> 충돌이 발생할 때 해결 방법 Rebase? Merge?

### 상호작용

다수의 코드 정리를 한번에 처리하다가 우연히 동작 변경을 할 수도 있습니다.  

### 추측

한 번에 처리하는 코드 정리가 많을수록 자연스럽게 더 많은 코드를 정리하게 됩니다.  
그로 인해 예상치 못한 추가 비용이 발생합니다.  

> 한 번에 처리하는 코드 정리가 많다는게 무엇인지?

이러한 요인으로 인해 보통 한 번에 처리하는 코드 정리 개수를 줄인 후 통합과 배치에 임합니다.  

`많은 조직에서 하나의 변경 사항을 검토하고 배포하는 데 드는 고정 비용은 상당히 많습니다.`  
코드 정리 비용을 줄이고자 한다면, 코드 정리 개수를 늘려서 동작 변경에 소요되는 비용을 줄이세요.  

> 한 번에 많이 정리하여 QA를 한 번만(QA 비용 ↓) 하라는 의미인지?  

여러분과 여러분의 팀은 검토 비용을 제대로 줄일 수 있는 방법을 찾아야 합니다.  
팀에 신뢰와 강력한 문화가 있다면 코드 정리 후에는 굳이 검토할 필요가 없습니다.  

> 테스트 코드?  
> 개발환경에 장기간 올려놓기?  
> 
> 검토 비용을 줄일 수 있는 예시를 알려줘야하는게 아닌가.


## Chapter 19. 리듬

코드 정리를 관리하는 기술 중에는 정리의 리듬을 관리하는 일도 있습니다.  
코드 정리할 때 한번에 처리하는 규모를 작게 할 것을 권했습니다.  

소프트웨어 설계는 프랙탈이므로 설계는 크게도 작게도 할 수 있습니다.  
그래서 분 단위를 유지하되, 한 시간을 넘지 않습니다.  
한 번의 코드 정리에 한 시간 이상이 걸린다면, 이는 원하는 동작 변경을 위해 필요한 최소한의 구조 변경 시기를 놓쳤다는 의미일 수 있습니다.  

코드가 너무 엉망이라서 동작 변경에 앞서 몇 시간을 들여서라도 코드 정리를 선행하는 것이 더 유리할 수도 있습니다.  

동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있습니다.  
```
Chat gpt  
코드의 동작을 변경하는 작업은 주로 코드의 특정 부분에 집중되는 경향이 있다는 의미입니다.  
즉, 코드 전체가 아닌 특정 파일이나 모듈에서 변경이 많이 발생한다는 것입니다.  
```

파레토 법칙에 따르면 80%의 변경 사항이 20%의 파일에서 발생합니다.  
```
Chat gpt  
파레토 법칙(80/20 법칙)을 적용하면, 전체 변경 사항의 80%가 코드베이스의 20% 파일에서 발생한다고 설명합니다.
이는 소수의 파일에서 대부분의 변경이 집중된다는 것을 의미합니다.
```

코드 정리를 선행할 때, 탁월한 장점 중에는 코드 정리 내용도 뭉쳐진다는 것입니다.
```
Chat gpt  
코드 정리를 먼저 하면, 변경 사항이 집중된 파일이나 모듈도 잘 정리된다는 장점이 있다는 뜻입니다.
즉, 코드를 정리하면서 변경 사항도 자연스럽게 집중 관리할 수 있게 됩니다.
```

그리고 코드 정리가 코드를 뭉친 결과는 정확하게 동작 변경하기에 가장 좋은 위치에서 뭉쳐져 있습니다.
```
Chat gpt  
코드 정리를 통해 코드를 모듈화하고 집중시키면, 동작을 변경하기 좋은 위치에 코드를 집중시킬 수 있게 됩니다.
즉, 변경이 필요한 부분이 잘 정리된 상태로 유지되어, 변경 작업이 더 쉽고 효율적으로 이루어질 수 있다는 의미입니다. ` 
```

계속 코드 정리를 한다면, 대부분의 변경 작업은 이미 정리된 코드 안에서 이루어지게 됩니다.  

그렇기 때문에 코드 정리는 몇 분에서 한 시간 정도면 충분하다고 자신 있게 말할 수 있습니다.  

> 코드 정리를 시작하고 나서 정리할 코드들이 계속 보여도 1시간 쯤에서 멈추라는 의미인지?  
> 파레토 법칙에 의해 1시간 이후의 정리들은 큰 의미가 없을 수 있다는 것인지?  
> 문장들이 직역이라 의미가 잘 이해 안 됨


## Chapter 20. 얽힘 풀기

코드 정리를 진행합니다.  
그런 다음 새로운 테스트 케이스를 작성합니다.  
이제 동작을 변경해야 합니다.  
그랬더니 코드 정리할 곳이 더 생겼습니다.  

- 문제는 정리한 코드와 변경할 동작이 함께 얽혀버렸습니다.  

**컴퓨터에 지시하려는 여러분의 의도를 사람들에게도 설명해야 하기 때문이죠.**  
컴퓨터에 지시만 하는 빠른 수행이 흥미로운 최종 목표가 되는 것은 아닙니다.  

다시 구현하면서 새로운 것을 발견할 가능성이 높아집니다.  
그리고 동일한 동작 변경을 하면서도 더 많은 가치를 끌어낼 수도 있습니다.  

**실타래를 풀려면 실이 엉켜 있다는 사실을 알아차려야 시작할 수 있습니다.**  
따라서 실타래를 풀어야 할 필요성을 더 일찍 깨달을수록 작업량은 적어질 것입니다.  
먼저 정리할 것인지 나중에 정리할 것인지 고민하다가 코드 정리와 동작 변경 사이에서 전환 시점을 놓치기 일쑤일 겁니다.  
코드 정리와 동작 변경 사이의 선후 문제는 보통 시간이 지나면 해결될 테니까요.  

> 우리가 작성하는 코드는 컴퓨터가 아닌 사람에게 설명해야한다는 점에 매우 동의  
> 여기서 사람은 현재의 동료뿐만 아니라 미래의 동료도 포함해야 한다고 생각 함  
> 따라서 엉켜 있는 실을 풀어서 미래의 동료도 쉽게 접근할 수 있도록 해야 함  
> 
> 엉켜 있는 실을 정상적인 실타래의 한 부분이라고 생각하면 안 됨  
> 컨벤션의 얽힘 또한 누군가는 풀어줘야 함  
> 
> do(parameterA  
> , parameterB  
> , parameterC  
> )
> 
> static Name =             "name";  
> static id =               "id";  
> static phoneNumber =      "xxx-xxxx-xxxx";


## Chapter 21. 코드 정리 시점

### 아예 안 한다면

진짜로 변경이 필요 없는 시스템이라면 "고장 나지 않으면 고치지도 말자"는 말이 합리적으로 통하겠죠.  

### 나중에 정리하기

하지만 제가 나중에 코드를 정리하겠다는 선택을 마치 정답처럼 여기는 이유는 지금 정리할 코드가 너무 많으니 언제 해도 상관없다는 논리입니다.  
저는 여러분이 정말 나중에 정리해도 무방하다고 말씀드리고 싶습니다.  

나중에 정리할 목적으로 엉망인 코드 목록을 만들 수도 있습니다.  

물론 먼저 코드 정리를 해 놓으면, 나중에 시스템 동작 변경을 더 쉽게 합니다.  
시스템에서 반드시 변경할 거라고 보장할 정도면, 그 보편적 영역을 정리하는 것만으로 향후 변경을 단순화하는 가치가 창출됩니다.  

한 가지는 지저분함 보유세를 줄이는 것입니다.  
하지만 그때까지는 새 API에 변경 사항이 발생하면, 거울처럼 이전 API에도 똑같이 반영해야 하는 불편함이 있죠.  

새로운 API 전환에 따라 영향을 받는 코드 모두를 변경하고 나면, 어떤 클래스들은 변경하기가 훨씬 쉬워집니다.  

코드 정리를 나중에 할 근거 중 다른 하나는 학습 도구로 활용하는 것을 들 수 있습니다.  
코드 정리는 설계한 세부 결과를 깨달을 수 있는 좋은 방법입니다.  

여러분이 행복을 느낄 때, 얼마든지 더 나은 프로그래머 될 수 있음을 간과하지 마세요.  

### 동작 변경 후에 코드 정리

같은 영역을 다시 변경하게 된다면, 동작 변경 후 코드 정리하는 일은 상당한 의미가 있습니다.  

나중에 가면 정리하는 일이 더 힘들 수도 있습니다.  
나중에는 맥락을 잊어버릴 수 있기 때문이죠.  
또는 다른 변경 건이 생겨 코드 정리를 하는 데 훼방을 놓을 수도 있습니다.  
나중에 코드를 정리할 때까지 기다리느라 비용이 너무 많이 증가할 가능성이 있다면, 지금 정리하는 것이 좋습니다.  

- 코드 정리하는 데 드는 시간이 동작 변경에 드는 시간과 거의 비슷할 때

### 코드 정리 후에 동작 변경

- 지저분한 상태 그대로 코드를 변경한다면, 일이 얼마나 더 어려운가?
- 코드 정리의 이점을 바로 얻을 수 있는가?
- 코드 정리에 드는 비용을 어떻게 보상받을 수 있을까요?
- 코드 정리에 대해 얼마나 확신하고 계신가요?

일반적으로 코드를 먼저 정리하는 것을 선호하지만, 정리 그 자체를 목적으로 삼지 않도록 경계해야 합니다.  

### 요약

다음 상황에는 코드 정리를 하지 마세요.  
- 앞으로 다시는 코드를 변경하지 않을 때
- 설계를 개선하더라도 배울 것이 없을 때

다음 상황에서는 나중으로 정리를 미루세요.  
- 정리할 코드 분량이 많은데, 보상이 바로 보이지 않을 때
- 코드 정리에 대한 보상이 잠재적일 때
- 작은 묶음으로 여러 번에 나눠서 코드 정리를 할 수 있을 때

다음 상황에서는 동작 변경 후에 정리하세요.
- 다음 코드 정리까지 기다릴수록 비용이 더 불어날 때
- 코드 정리를 하지 않으면 일을 끝냈다는 느낌이 들지 않을 때

다음 상황에서는 코드 정리 후에 동작 변경을 하세요.
- 코드 정리를 했을 때, 코드 이해가 쉬워지거나 동작 변경이 쉬워지는 즉각적인 효과를 얻을 수 있을 때
- 어떤 코드를 어떻게 정리해야 하는지 알고 있을 때

> 코드 정리로 얻는 이점 중에 '행복', '만족'과 같이 감정 관점은 신선했음  
>
> '나중에 정리하기'와 '동작 변경 후에 코드 정리'는 리뷰어 입장에서 동료에 대한 믿음이 중요한 듯   

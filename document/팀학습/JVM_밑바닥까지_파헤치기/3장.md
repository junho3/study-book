# 3장 가비지 컬렉터와 메모리 할당 전략

## 3.1 들어가며

가비지 컬렉션의 역사는 자바보다 훨씬 오래되었다.  
동적 메모리 할당과 가비지 컬렉션 기술을 가장 처음 사용한 언어는 1960년에 MIT에서 개발된 리스프다.  

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면, 이 '자동화된' 기술을 적절히 모니터링하고 조율할 수 있어야 하기 때문이다.  

반면 자바 힙과 메서드 영역은 불확실한 게 아주 많다.  
같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다.  


## 3.2 대상이 죽었는가?

### 3.2.1 참조 카운팅 알고리즘

1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.  
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

자바 가상 머신에서는 참조 카운팅을 쓰지 않는다.  
간단한 참조 카운팅만으로는 순환 참조 문제를 풀기 어렵다.  


### 3.2.2 도달 가능성 분석 알고리즘

오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다.  

GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다.  
시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다.  
어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해 진다.  


### 3.2.3 다시 참조 이야기로

- 강한 참조: Object obj = new Object()
- 부드러운 참조: 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다.  
- 약한 참조: 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다.
- 유령 참조: 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.


### 3.2.4 살았나 죽었나?

도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다.  
필터링 조건은 'finalize() 메서드를 실행해야 하는 객체인가'이다.  

finalize()를 실행해야 하는 객체로 판명되면 F-큐라는 대기열에 추가된다.  

다시 말하지만 가능한 finalize()를 사용하지 말자.  
실행하는 비용도 높고 불확실성도 크다.  

finalize()로 할 수 있는 일은 전부 try finally 등의 다른 방법으로 제때 더 잘 처리할 수 있다.  


### 3.2.5 메서드 영역 회수하기

메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다.  
더 이상 사용되지 않는 '상수'와 '클래스'다.  

더 이상 쓰이지 않는 '클래스'인지 판단하는 조건은 더 까다롭다.  
다음 세 조건을 동시에 만족해야 한다.  

- 자바 힙에 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.


## 3.3 가비지 컬렉션 알고리즘

참조 카운팅 GC 알고리즘은 주류 자바 가상 머신들에서는 사용하지 않기 때문에 이번 절에서 소개할 알고리즘들은 모두 추적 GC에 속한다.

### 3.3.1 세대 단위 컬렉션 이론

한 번 살아남은 객체는 통계쩍으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영역을 회수하는 빈도를 줄이는 것이다.  
이렇게 하면 가비지 컬렉션에 드는 전체 시간도 줄고 메모리 공간도 효율적으로 이용할 수 있다.  

자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC식으로 부르곤 한다.  

- 부분 GC: 자바 힙의 일부만 회수
  - 마이너 GC: Young Generation 대상 (Eden, Survivor1, Survivor2)
  - 메이저 GC: Old Generation 대상 (Old)
  - 혼합 GC: Young Generation 전체와 Old Generation 일부를 대상
- 전체 GC: 자바 힙 전체와 메서드 영역까지 모든 대상


### 3.3.2 마크-스윕 알고리즘

먼저 회수할 객체들을 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다.  

마크-스윕 알고리즘의 큰 단점은 두 가지다.  
첫째, 실행 효율이 일정하지 않다. 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어진다.
둘째, 메모리 파편화가 심하다. 그 결과 또 다른 가비지 컬렉션을 유발한다.  


### 3.3.3 마크-카피 알고리즘

가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다.  
한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다.  

가용 메모리를 절반으로 줄여 낭비가 제법 심하다는 점이다.  
상용 자바 가상 머신 대부분은 Young Generation에 이 알고리즘을 활용한다.  


### 3.3.4 마크-컴팩트 알고리즘

생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.  

이런 식의 객체 이동은 사용자 애플리케이션을 모두 멈춘 상태에서 진행해야 하므로 아주 신중하게 고려해야 할 단점이다.  
이와 같은 일시 정지 현상을 'Stop the world'라는 말로 아주 생생하게 표현해 냈다.  

객체를 이동시킬 때와 아닐 때 모두 단점이 있다.  
객체를 이동시키면 회수 작업이 복잡해지고, 이동시키지 않으면 할당 작업이 복잡해진다.  

메모리를 할당하고 접근하는 빈도가 가비지 컬렉션 수행 빈도보다 훨씬 많으므로 할당과 접근 효율이 떨어지면 전체적인 처리량은 여전히 나빠진다.  




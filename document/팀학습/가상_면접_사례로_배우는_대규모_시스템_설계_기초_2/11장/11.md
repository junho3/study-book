# 11장 결제 시스템

결제 시스템은 얼핏 보기에는 이해하기 쉽지만, 작업하기 부담스런 시스템이기도 하다.  
작은 실수로도 상단한 매출 손실이 발생하고 사용자의 믿음이 무너질 수 있기 때문이다.  

## 1단계: 문제 이해 및 설계 범위 확정

- 전자상거래 애플리케이션을 위한 결제 백엔드를 구축한다고 가정
- 모든 결제 수단을 지원해야 하지만, 신용 카드만 지원한다고 가정
- 결제는 PG사를 통해 처리
- 민감한 데이터 처리는 PG사에 의존
- 전 세계적으로 사용될 수 있는 애플리케이션이지만, 하나의 통화만 사용한다고 가정
- 하루에 100만 건 거래 발생
- 매월 판매자에게 대금 지급 프로세스 존재
- 조정 작업을 수행하고 불일치가 발견되면 교정

### 기능 요구사항

- 대금 수신
- 대금 정산

> 1P: 직매입 후 판매 (컬리)  
> 3P: 판매할 수 있는 공간(사이트)를 제공 (쿠팡, 무신사)  
> 대금 수신 후 정산까지 얘기하고 있어서 3P인 듯  

### 비기능 요구사항

- 신뢰성 및 내결함성
- 내부 서비스와 외부 서비스간 조정 프로세스: 시스템 간의 결제 정보가 일치하는지 비동기적으로 확인

### 개략적인 규모 추정

100만 건의 트랜잭션 / 10^5 = 초당 10 TPS  
일반적인 DB로 별 문제 없이 처리 가능

> e-commerce에서 주문 대비 결제는 필요 QPS가 낮음  
> 쿠팡의 경우 주문완료와 결제를 다른 프로세스로 진행하는 것으로 알고 있음  
> 주문과 결제를 같은 트랜잭션으로 묶을 것인지 말 것인지 각각 장단점이 존재  


## 2단계: 개략적 설계안 제시 및 동의 구하기

### 대금 수신 흐름

#### 결제 서비스

사용자로부터 결제 이벤트를 수락하고 결제 프로세스를 조율한다.  
AML/CFT와 같은 규정을 준수하는지, 자금 세탁이나 테러 자금 조달과 같은 범죄 행위의 증거가 있는지 평가하는 위험 점검이다.  
일반적으로 위험 확인 서비스는 매우 복잡하고 고도로 전문화되어 있기 때문에 제 3자 제공업체를 이용한다.  

> 위험 확인 서비스를 구성한 경험은 없음.  
> PG사에서 해줄 듯  

#### 결제 실행자

결제 서비스 공급자(PSP)를 통해 결제 주문 하나를 실행한다.  

> PSP(Payment service provider)와 PG사(Payment Gateway 전자지급결제대행서비스) 의미적으로 같은 듯  

#### 카드 유형

#### 원장

결제 트랜잭션에 대한 금융 기록이다.  
원장 시스템은 전자상거래 웹사이트의 총 수익을 계산하거나 향후 수익을 예측하는 등 결제 후 분석에서 매우 중요한 역할을 한다.  

> Insert만 존재하고, Update는 하면 안 됨  
> 원장으로 규정한 데이터를 수기로 수정이 필요할 경우 더 까다로운 프로세스를 거쳐야 함  
> 
> 컬리에 있을 때 정산 목적으로 시스템을 구축했으나, 마케팅팀, 데이터팀에서도 분석용으로 쓰임

#### 지갑

판매자의 계정 잔액을 기록한다.  

> 결제 시스템에서 판매자의 지갑 개념이 필요한건지는 모르겠음  
> e-commerce에서는 상품코드가 존재하고, 여기서 얘기하는 판매자 정보도 상품코드와 맵핑될 확률이 높기 때문  
> 그리고 판매자에 대한 대금 정산은 실시간으로 하는게 아닐거라 비동기로 처리해도 되지 않나 싶음  


### 결제 서비스 API

payment_order_id가 전역적으로 고유한 ID라는 점에 유의하자.  
결제 실행자가 타사 PSP에 결제 요청을 전송할 때, PSP는 payment_order_id를 중복 제거 멱등키로 사용된다.  

> auto increment 키를 사용하는 것보다 특정 조건으로 지정된 길이의 키를 생성해서 사용하는 것이 좋음  
> PG사에서도 payment_id를 내려주므로, 일반적으로 payment_order_id와 payment_id 페어로 묶임  
> payment_order_id가 유일하지 않아도 될 수 있음  

amount 필드의 데이터 유형이 double이 아닌 string이라는 것에 유의하자  

> double은 나눗셈이나 반올림에서 잘못된 결과가 나올 수 있음  
> 그렇다고 string을 사용하는 건 매우 잘못된 정보  
> BigDecimal을 사용해야 함  
> 원화(₩)는 결제금액에 소수점이 발생할 일이 없어서 Long 타입으로 해도 될 듯  

### 결제 서비스 데이터 모델

결제 시스템용 저장소 솔루션을 고를 때 일반적으로 성능은 가장 중요한 고려사항은 아니다.  
대신 다음 사항에 중점을 둔다.  

- 안정성이 검증되었는가?
- 모니터링 및 데이터 탐사에 필요한 도구가 풍부하게 지원되는가?
- DBA 채용 시장이 성숙했는가?

일반적으로는 NoSQL/NewSQL보다는 ACID 트랜잭션을 지원하는 전통적인 관계형 데이터베이스를 선호한다.  

> NewSQL https://ko.wikipedia.org/wiki/NewSQL  

일반적으로, 종결되지 않은 결제 주문을 모니터링 하기 위해 주기적으로 실행되는 작업을 마련해 둔다.  

> 고객이 결제창까지 진입하고, 결제를 안하는 경우도 꽤나 존재함  
> timeout 등이 발생하여 우리는 실패하고, PG사는 처리된 경우를 위한 작업은 필요함  

### 복식부기 원장 시스템

모든 결제 거래를 두 개의 별도 원장 계좌에 같은 금액으로 기록한다.  
한 계좌에서는 차감이 이루어지고 다른 계좌에는 입금이 이루어진다.  

복식부기 시스템에서 모든 거래 항목의 합계는 0이어야 한다.  
이 시스템을 활용하면 자금의 흐름을 시작부터 끝까지 추적할 수 있으며 결제 주기 전반에 걸쳐 일관성을 보장할 수 있다.  

> 중요한 개념이긴하나, 결제 서비스의 컨텍스트에 따라 복식부기 원장 개념을 추가할지 말지 결정할 듯  
> 다른 서비스 대비 결제 서비스가 평균 응답속도가 느린건 맞지만, 그렇다고 응답속도가 느린 결제 서비스는 고객 이탈이 발생할 수 있음  
> 
> 개인적으로는 결제 서비스는 최소한의 유효성 검사와 Insert 위주의 기록만 남기고, 복식부기 같은 정밀 검증은 후처리로 하는게 낫다고 봄  
> 카카오페이손해보험 기간계(레거시) 시스템의 결제 프로세스에 여러가지 검증이 붙어서 코드도 복잡하고 평균 5초 이상 걸렸음  
> 지금은 Kafka를 사용하여 검증 프로세스를 후처리로 옮겨서 1~2초만에 끝남  

### 외부 결제 페이지

대부분의 기업은 시용 카드 정보를 내부에 저장하지 않는데, 이는 신용 카드 정보를 내부에 저장할 경우 미국의 PCI DSS 같은 복잡한 규정을 준수해야 하기 때문이다.  
외부 신용 카드 페이지는 위젯 또는 iframe이며, 모바일 애플리케이션의 경우에는 결제 SDK에 포함된 사전에 구현된 페이지다.  
여기서 중요한 점은 우리 결제 서비스가 아니라 PSP가 제공하는 외부 결제 페이지가 직접 고객 카드 정보를 수집한다는 것이다.  

> iframe은 보안 취약점이 있는걸로 앎  
> 일반적으로 PG사의 결제 창 페이지로 리다이렉트 되는 구조  
> 카카오페이는 결제 창 페이지 URL을 내려주고, 결제 창을 띄움  
> 다른 PG사는 javascript를 제공하고, 값을 셋팅한 다음에 특정 함수를 호출해서 결제 창을 띄움  

### 대금 정산 흐름

정산 흐름에서는 타사 정산 서비스를 사용하여 전자상거래 웹사이트 은행 계좌에서 판매자 은행 계좌로 돈을 이체한다는 점이다.  


## 3단계: 상세 설계

### PSP 연동

9. 비동기적으로 PSP는 웹훅을 통해 결제 상태와 함께 결제 서비스를 호출한다.  

> 일반적으로 결제서비스가 PG사에 결제승인 API를 호출하는 구조임  
> 8번부터 결제 완료 페이지 > 결제 서비스 > PG사 호출이 되야 함  
> PG사에서 우리쪽으로 웹훅을 호출하진 않음  

### 조정 (대사)

이는 시스템 성능을 높이기 위해 비동기 통신을 자주 사용하는 결제 관련 사업에 일반적이다.  
PSP나 은행 같은 외부 시스템도 비동기 통신을 선호한다.  

> 결제 연동을 하면서 비동기 처리를 한적은 없는 듯  
> 한국과 미국의 결제 생태계가 다른건지  

매일 밤 PSP나 은행은 고객에게 정산 파일을 보낸다.  
정산 파일에는 은행 계좌의 잔액과 하루 동안 해당 계좌에서 발생하는 모든 거래 내역이 기재되어 있다.  
조정 중에 발견된 차이는 일반적으로 재무팀에 의뢰하여 수동으로 고친다.  

> 책에서는 결제 서비스에서 직접 대사를 하는 것으로 표현했는데, 결제 서비스와 정산 서비스는 분리하는게 맞음  
> 정산서비스는 CPU나 메모리를 많이 사용하고, 긴 작업을 수행하기 때문에 대사를 수행하는 결제 서비스에 장애가 발생할 수 있음  

### 결제 지연 처리

결제 요청이 평소보다 오래 걸리게 되는 몇 가지 사례다.  

- PSP가 해당 결제 요청의 위험성이 높다고 보고 담당자 검토를 요구하는 경우
- 신용 카드사가 구매 확인 용도로 카드 소유자의 추가 정보를 요청하는 3D 보안 인증 같은 추가 보호 장치를 요구하는 경우

> 이거는 PSP와 카드사의 문제 아닌지  
> 결제 서비스와 PSP의 문제는 아닌 것 같은데  
> 
> 오히려 PSP나 카드사의 시스템 장애로 인한 지연 사례가 더 적합할 듯  
> 일반적으로 PG사에서 권장하는 timeout 정책이 있고, 결제 서비스도 그 timeout에 맞추는게 좋긴 함    
> 그렇다고 timeout이 너무 길면 우리쪽 서비스에 장애가 발생할 수 있으니 적절하게 대응 필요  

### 내부 서비스 간 커뮤니케이션

#### 동기식 통신

HTTP와 같은 동기식 통신은 소규모 시스템에서는 잘 작동하지만 규모가 커지면 단점이 분명해진다.  

- 성능 저하
- 장애 격리 곤란
- 높은 결합도
- 낮은 확장성

#### 비동기 통신

- 단일 수신자
- 다중 수신자

> 단일 수신자는 안 쓸 듯  

### 결제 실패 처리

#### 결제 상태 추적

실패가 일어날 때마다 결제 거래의 현재 상태를 파악하고 재시도 또는 환불이 필요한지 여부를 결정한다.  
결제 상태는 데이터 추가만 가능한 데이터베이스 테이블에 보관한다.  

> 보통 특정 결제건에 대해 취소를 하려면 해당 결제건의 우리쪽 결제키와 PG사의 결제키를 페어로 호출해야 하지만, 
> 특수한 경우를 위해 PG사에서는 우리쪽 결제키만으로 취소할 수 있는 망취소 API를 제공 함   

#### 재시도 큐 및 실패 메시지 큐

실패를 우아하게 처리하기 위해서는 재시도 큐와 실패 메시지 큐를 두는 것이 바람직하다.  

- 재시도 큐
- 실패 메시지 큐

#### 정확히 한 번 전달

결제 시스템에 발생 가능한 가장 심각한 문제 중 하나는 고객에게 이중으로 청구하는 것이다.  
결제 주문이 정확히 한 번만 실행되도록 결제 시스템을 설계하는 것이 중요하다.  

수학적으로 보자면, 다음의 요건이 충족되면 주어진 연산은 정확히 한 번 실행된다.  

1. 최소 한 번은 실행된다.
2. 최대 한 번 실행된다.

##### 재시도

간혹 네트워크 오류나 시간 초과로 인해 결제 거래를 다시 시도해야 하는 경우가 있다.  
재시도 메커니즘을 활용하면 어떤 결제가 최소 한 번은 실행되도록 보장 가능하다.  

- 즉시 재시도
- 고정 간격
- 증분 간격
- 지수적 백오프
- 취소

네트워크 문제가 단시간 내에 해결될 것 같지 않다면 지수적 백오프를 사용하라는 것이다.  
지나치게 공격적인 재시도 전략은 컴퓨팅 자원을 낭비하고 서비스 과부하를 유발한다.  
에러 코드를 반환할 때는 Retry-After 헤더를 같이 붙여 보내는 것이 바람직하다.  

> PG사에서도 결제건에 대한 유효시간이 있기 때문에 재시도보다 처음부터 프로세스를 진행하는게 안전하다고 봄

##### 멱등성

API 관점에서 보자면 멱등성은 클라이언트가 같은 API 호출을 여러 번 반복해도 항상 동일한 결과가 나온다는 뜻이다.  
일반적으로 클라이언트가 생성하고 일정 시간이 지나면 만료되는 고유한 값을 멱등 키로 사용한다.  
스트라이프, 페이팔 같은 많은 기술 회사가 UUID를 멱등키로 권장하며 실제로 널리 쓰인다.  

- 시나리오 1: 고객이 '결제' 버튼을 빠르게 두 번 클릭하는 경우
  - 처음 요청만 처리하고, 두 번째 요청은 429 Too Many Requests 상태 코드 반환
  - DB 고유 키 제약 조건 활용
- 시나리오 2: PSP가 결제를 성공적으로 처리했지만 네트워크 오류로 응답이 결제시스템에 전달되지 못하여, 사용자가 '결제' 버튼을 다시 클릭하는 경우

> 시나리오 1은 Redis에 결제 키 Lock을 잡음  
> 시나리오 2는 우리쪽 결제 데이터가 실패 상태로 되어 있을거라 PG사에서 제공하는 결제 조회를 호출하여 검증할 듯  

### 일관성

분산 환경에서는 서비스간 통신 실패로 데이터 불일치가 발생할 수 있다.  
내부 서비스 간에 데이터 일관성을 유지하려면 요청이 '정확히 한 번 처리'되도록 보장하는 것이 아주 중요하다.  

내부 서비스와 외부 서비스(PSP) 간의 데이터 일관성 유지를 위해서는 일반적으로 멱등성과 조정 프로세스를 활용한다.  
외부 서비스가 멱등 API를 지원하더라도 외부 시스템이 항상 옳다고 가정할 수는 없으므로 조정 절차를 생략할 수는 없다.  

> 우리 결제 데이터를 기준으로 PG사 데이터를 검증하고, PG사 데이터를 기준으로 우리 결제 데이터를 검증하는 쌍방 대사를 해야 함  

데이터를 다중화하는 경우에는 복제 지연으로 인해 기본 데이터베이스와 사본 데이터가 불일치하는 일이 생길 수 있다.

1. 주 데이터베이스에서만 읽기와 쓰기 연산을 처리한다.  
   1. 설정이 쉬움
   2. 규모 확장성이 떨어짐
   3. 사본 데이터는 트래픽 처리를 하지 않으므로 자원낭비가 된다.
2. 모든 사본이 항상 동기화되도록 한다.
   1. 팩서스, 래프트 같은 합의 알고리즘 사용
   2. YugabyteDB, CockroachDB와 같은 합의 기반 분산 데이터베이스를 사용한다.

> 필요한 부분만 마스터 DB를 보도록 하고, 일반적인 조회는 사본 데이터를 보면 되지 않을까?  
> 
> 앞 절에서 DBA 채용도 중요한 요소라고 언급해놓고, 일반적이지 않은 합 기반 DB를 제안하는건 이해를 못 함  


### 결제 보안

> 금액 계산은 클라이언트가 아니라 결제 서비스(백엔드)에서 이루어져야 함  


## 4단계 마무리

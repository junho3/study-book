# 12장 전자 지갑

## 1단계: 문제 이해 및 설계 범위 확정

- 이체 기능에만 집중
- 초당 트랜잭션은 1,000,000TPS 가정
- 데이터베이스가 제공하는 트랜잭션 보증이면 충분
- 처음부터 데이터를 재생하여 언제든지 과거 잔액을 재구성할 수 있는 시스템
- 가용성 요구사항 99.99%
- 환전은 필요없음

### 개략적 추정

본 설계안에서 사용할 데이터베이스 노드는 1,000TPS를 지원할 수 있다고 가정하겠다.  
따라서 1백만 TPS를 지원하려면 1,000개의 데이터베이스 노드가 필요하다.  

한 계좌에서 인출 연산을 실행해야 하고, 다른 계좌에서는 입금 연산을 실행해야 한다.  
1백만 건의 TPS를 처리하기 위해서는 2백만 TPS를 지원해야 하고, 결국 2000개 노드가 필요하다는 뜻이다.  

이번 장의 설계 목표 중 하나는 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것이다.  


## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 설계

한 가지 유의할 부분은 'amount' 필드의 자료형이 double이 아니라 string이라는 점이다.  

> openRTB: "bidfloor": 0.03 float 타입  
> paypal: "value": "10.99" string 타입  
> toss payments 해외결제: "value": 664.98 number 타입 // 소수점 두 번째 자리까지 허용  

그러나 실제로는 float이나 double을 택하는 경우도 많은데, 대부분의 프로그래밍 언어와 데이터베이스가 지원하기 때문이다.  
정밀도를 잃을 위험이 있음을 이해하고 사용한다면 적절한 선택일 수 있다.

> php: 언어 자체에 BigDecimal 없고, 라이브러리 존재  
> https://stackoverflow.com/questions/49020952/bigdecimal-equivalent-for-php  
> 
> python: decimal.Decimal  
> https://stackoverflow.com/questions/16996527/what-is-the-python-for-javas-bigdecimal  
> 
> nodejs: BigInt, 그 외 라이브러리 존재  
> https://stackoverflow.com/questions/16742578/bigdecimal-in-javascript  

### 인메모리 샤딩

지갑 애플리케이션은 모든 사용자 계정의 잔액을 유지한다.  
<사용자, 잔액> 관계를 나타내기 좋은 자료 구조는 해시 테이블이라고 불리는 맵 또는 키-값 저장소다.  

레디스 노드 한 대로 100만 TPS 처리는 벅차다.  
클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다.  
이 절차를 파티셔닝 또는 샤딩이라고 한다.  

키-값 데이터를 n개 파티션에 고르게 분배하려면 키의 해시 값을 계산하고 이를 파티션의 수 n으로 나누는 것이 한 가지 방법이다.  
그 결과로 얻은 나머지 값이 데이터를 저장할 파티션 번호다.  

모든 레디스 노드의 파티션 수 및 주소는 한군데 저장해 둔다.  
높은 가용성을 보장하는 설정 정보 전문 저장소 주키퍼를 이 용도로 쓰면 좋다.  

그림 12.3 설계는 작동은 하지만 정확성 요구사항을 충족하지 못한다.  
지갑 서비스는 이체할 때마다 두 개의 레디스 노드를 업데이트하는데, 그 두 연산이 모두 성공하리라는 보장은 없다.  

### 분산 트랜잭션

#### 데이터베이스 샤딩

트랜잭션 데이터베이스를 사용해도 이런 식이면 문제의 일부만 해결할 수 있다.  

#### 분산 트랜잭션: 2단계 커밋

분산 트랜잭션은 이들 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안이다.  

저수준 방안은 데이터베이스 자체에 의존하는 방안이다.  
이때 가장 일반적으로 사용되는 알고리즘은 2단계 커밋(2PC)이다.  

이 방안이 저수준 방안인 이유는, 이기종 데이터베이스 사이에 2PC를 실행하려면 모든 데이터베이스가 X/Open XA 표준을 만족해야 한다.  
2PC의 가장 큰 문제점은 다른 노드의 메시지를 기다리는 동안 락이 오랫동안 잠긴 상태로 남을 수 있어서 성능이 좋지 않다는 것이다.  
또 다른 문제는 조정자가 SPOF가 될 수 있다는 것이다.  

#### 분산 트랜잭션: TC/C

TC/C(시도-확정/취소, 즉 Try-Confirm/Cancel)는 두 단계로 구성된 보상 트랜잭션이다.  

시도 단계에서는 조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 데이터베이스로 전송한다.  
데이터베이스는 NOP 명령에 대해 아무 작업도 수행하지 않으며 항상 성공했다는 응답을 보낸다.  

두 데이터베이스가 모두 예라고 응답하면 지갑 서비스는 확정 단계를 시작한다.  

이미 종료된 트랜잭션의 효과를 되돌리려면 지갑 서비스는 또 다른 트랜잭션을 시작하여 계정 A에 1달러를 다시 추가해야 한다.  
시도 단계에서 계정 C의 잔액은 업데이트하지 않았으므로, 계정 C의 데이터베이스에는 NOP 명령을 전송하기만 하면 된다.  

##### 2PC와 TC/C의 비교

|      | 첫 번째 단계                      | 두 번째 단계: 성공         | 두 번째 단계: 실패             |
|------|------------------------------|---------------------|-------------------------|
| 2PC  | 로컬 트랜잭션은 아직 완료되지 않은 상태       | 모든 로컬 트랜잭션을 커밋      | 모든 로컬 트랜잭션을 취소          |
| TC/C | 모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료 | 필요한 경우 새 로컬 트랜잭션 실행 | 이미 커밋된 트랜잭션의 실행 결과를 되돌림 |

##### 단계별 상태 테이블

TC/C의 진행 상황, 특히 각 단계 상태 정보를 트랜잭션 데이터베이스에 저장하면 된다.  
이 상태 정보는 최소한 다음을 포함해야 한다.  
- 분산 트랜잭션의 ID와 내용
- 각 데이터베이스에 대한 시도 단계의 상태
- 두 번째 단계의 이름
- 두 번째 단계의 상태
- 순서가 어긋났음을 나타내는 플래그

> 11장 결제시스템에도 동일한 구성 필요

##### 불균형 상태

분산 트랜잭션 실행 도중에는 항상 데이터 불일치가 발생한다.  
데이터베이스와 같은 하위 시스템에서 불일치를 수정하는 경우에는 그 사실을 알 필요는 없지만, 그렇지 않다면 우리가 직접 처리해야 한다.  

##### 유효한 연산 순서

##### 잘못된 순서로 실행된 경우

취소 명령이 먼저 도착하면 데이터베이스에 아직 상응하는 시도 명령을 못 보았음을 나타내는 플래그를 참으로 설정하여 저장해둔다.  
시도 명령이 도착하면 항상 먼저 도착한 취소 명령이 있는지 확인한다.  
있었으면 바로 실패를 반환한다.  

#### 분산 트랜잭션: 사가

##### 선형적 명령 수행

사가는 유명한 분산 트랜잭션 솔루션 가운데 하나로 마이크로서비스 아키텍처에서는 사실상 표준이다.  

1. 분산 조율 (Choreography)
2. 중앙 집중형 조율 (Orchestration)

어떤 방식으로 조율할지는 사업상의 필요와 목표에 따라 정한다.  
일반적으로는 중앙 집중형 조율 방식을 선호하는데, 복잡한 상황을 잘 처리하기 때문이다.  

##### TC/C vs 사가

사가의 연산은 순서대로 실행해야 하지만 TC/C에서는 병렬로 실행할 수 있다.  
지연 시간에 민감하고 많은 서비스/운영이 관계된 시스템이라면 TC/C가 더 낫다.  


### 이벤트 소싱

#### 배경

전자 지갑 서비스 제공 업체도 감사를 받을 수 있다.  

1. 특정 시점의 계정 잔액을 알 수 있나요?
2. 과거 및 현재 계정 잔액이 정확한지 어떻게 알 수 있나요?
3. 코드 변경 후에도 시스템 로직이 올바른지는 어떻게 검증하나요?

이러한 질문에 체계적으로 답할 수 있는 설계 철학 중 하나는 도메인 주도 설계에서 개발된 기법인 이벤트 소싱이다.  

#### 정의

##### 명령(command)

명령은 외부에서 전달된, 의도가 명확한 요청이다.  
이벤트 소싱에서 순서는 아주 중요하다.  
따라서 명령은 일반적으로 FIFO 큐에 저장된다.  

##### 이벤트(event)

작업 이행 전에는 반드시 명령의 유효성을 검사해야 한다.  
그리고 검사를 통과한 명령은 반드시 이행되어야 한다.  
명령 이행 결과를 이벤트라고 부른다.  

이벤트는 검증된 사실로, 실행이 끝난 상태다.  
그래서 이벤트에 대해 이야기할 때는 과거 시제를 사용한다.  

명령에는 무작위성이나 I/O가 포함될 수 있지만 이벤트는 결정론적이다.  

하나의 명령으로 여러 이벤트가 만들어질 수 있다.  
이벤트 생성 과정에는 무작위성이 개입될 수 있어서, 같은 명령에 항상 동일한 이벤트들이 만들어진다는 보장이 없다.  

##### 상태

상태는 이벤트가 적용될 때 변경되는 내용이다.  
지갑 시스템에서 상태는 모든 클라이언트 계정의 잔액으로, 맵을 자료 구조로 사용하여 표현할 수 있다.  
키는 계정 이름 또는 ID이고, 값은 계정 잔액이다.  

##### 상태 기계

상태 기계는 이벤트 소싱 프로세스를 구동한다.  

1. 명령의 유효성을 검사하고 이벤트를 생성한다.  
2. 이벤트를 적용하여 상태를 갱신한다.

이벤트 소싱을 위한 상태 기계는 결정론적으로 동작해야 한다.  
따라서 무작위성을 내포할 수 없다.  
이벤트를 상태에 반영하는 것 또한 항상 같은 결과를 보장해야 한다.  

#### 지갑 서비스 예시

명령은 FIFO 큐에 기록하며, 큐로는 카프카를 널리 사용한다.  
상태 기계는 명령을 큐에 들어간 순서대로 확인한다.  

#### 재현성

이벤트 소싱이 다른 아키텍처에 비해 갖는 가장 중요한 장점은 재현성이다.  
이벤트를 처음부터 다시 재생하면 과거 잔액 상태는 언제든 재구성할 수 있다.  

> 카프카 메시지 보관 기간 때문에 재현성을 원하는대로 수행할 수 있을지?  

#### 명령-질의 책임 분리 (CQRS)

CQRS에서는 상태 기록을 담당하는 상태 기계는 하나고, 읽기 전용 상태 기계는 여러 개 있을 수 있다.  
읽기 전용 상태 기계는 상태 뷰를 만들고, 이 뷰는 질의에 이용된다.  

읽기 전용 상태 기계는 실제 상태에 어느 정도 뒤쳐질 수 있으나 결국에는 같아진다.  
따라서 결과적 일관성 모델을 따른다 할 수 있다.  


## 3단계: 상세 설계

### 고성능 이벤트 소싱

#### 파일 기반의 명령 및 이벤트 목록

명령과 이벤트를 카프카 같은 원격 저장소가 아닌 로컬 디스크에 저장하는 방안을 생각해 볼 수 있다.  
이렇게 하면 네트워크를 통하 전송 시간을 피할 수 있다.  
이벤트 목록은 추가 연산만 가능한 자료 구조에 저장한다.  
추가는 순차적 쓰기 연산으로, 일반적으로 매우 빠르다.  

최근 명령과 이벤트를 메모리에 캐시하는 방안도 생각해 볼 수 있다.  

mmap을 사용하면 로컬 디스크에 쓰는 동시에, 최근 데이터는 메모리에 자동으로 캐시할 수 있다.  
mmap은 디스크 파일을 메모리 배열에 대응시킨다.  
운영체제는 파일의 특정 부분을 메모리에 캐시하여 읽기 및 쓰기 연산의 속도를 높인다.  

#### 파일 기반 상태

상태 정보도 로컬 디스크에 저장할 수 있다.  
파일 기반 로컬 관계형 데이터베이스 SQLite를 사용하거나, 로컬 파일 기반 키-값 저장소 RocksDB를 사용할 수 있다.  

본 설계안에서는 RocksDB를 사용할 터인데, 쓰기 작업에 최적화된 자료 구조 LSM을 사용하기 때문이다.  
최근 데이터는 캐시하여 읽기 성능을 높인다.  


#### 스냅숏

주기적으로 상태 기계를 멈추고 현재 상태를 파일에 저장한다면 시간을 절약할 수 있을 것이다.  
이 파일을 스냅숏이라 부른다.  

지갑 서비스 같은 금융 애플리케이션은 00:00에 스냅숏을 찍는 일이 많다.  
스냅숏은 거대한 이진 파일이며, 일반적으로는 HDFS과 같은 객체 저장소에 저장한다.  

### 신뢰할 수 있는 고성능 이벤트 소싱

#### 신뢰성 분석

상태 및 스냅숏의 안정성을 향상시키려면 이벤트 목록의 신뢰성만 보장하면 된다.  

이벤트 생성은 결정론적 과정이 아니며, 난수나 외부 입출력 등의 무작위적 요소가 포함될 수 있다.  
따라서 명령의 신뢰성 만으로는 이벤트의 재현성을 보장할 수 없다.  

이벤트는 불변이며 상태 재구성에 사용할 수 있다.  
따라서 높은 신뢰성을 보장할 유일한 데이터는 이베느다.  

#### 합의

복제 과정은 다음을 보장해야 한다.  

1. 데이터 손실 없음
2. 로그 파일 내 데이터의 상대적 순서는 모든 노드에 동일

이 목표를 달성하는 데는 합의 기반 복제 방안이 적합하다.  

래프트 알고리즘을 사용하면 노드의 절반 이상이 온라인 상태면 그 모두에 보관된 추가 전용 리스트는 같은 데이터를 가진다.  
래프트 알고리즘을 사용하몀 과반수 노드가 작동하는 한 시스템은 안정적이다.  

#### 고신뢰성 솔루션

복제 매커니즘을 활용하면 파일 기반 이벤트 소싱 아키텍처에서 단일 장애 시점(SPOF) 문제를 없앨 수 있다.  

리더에 장애가 발생하면 래프트 알고리즘은 나머지 정상 노드 중에서 새 리더를 선출한다.  
새 리더는 외부 사용자로부터 오는 명령을 수신할 책임을 진다.  

팔로어에 장애가 생기면 해당 팔로어로 전송된 요청은 실패한다.  

### 분산 이벤트 소싱

#### 풀 vs 푸시

풀 모델에서는 외부 사용자가 읽기 전용 상태 기계에서 주기적으로 실행 상태를 읽는다.  
이 모델은 실시간이 아니며, 읽는 주기를 너무 짧게 설정하면 지갑 서비스에 과부하가 걸릴 수도 있다.  

외부 사용자와 이벤트 소싱 노드 사이에 역방향 프락시를 추가하면 개선할 수 있다.  

#### 분산 트랜잭션


## 4단계: 마무리




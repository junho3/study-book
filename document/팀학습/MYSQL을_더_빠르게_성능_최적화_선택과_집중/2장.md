# 2장 인덱스와 인덱싱

MySQL의 성능은 여러 요인이 결정하지만 인덱스 없이는 성능을 달성할 수 없으므로 인덱스는 특별한 존재라고 하겠습니다.  

최적화(Optimizations)는 MySQL 측면에서 하드웨어를 효율적으로 활용하게 해주는 다양한 기술과 알고리즘, 데이터 구조를 의미합니다.  
데이터베이스가 작으면 하드웨어와 최적화로도 충분합니다.  
그러나 데이터 규모가 증가하면서 하드웨어와 최적화라는 조합의 이점은 줄어듭니다.  
이때 인덱스가 없으면 성능이 심각하게 제한됩니다.  

## 2-1 성능 향상과 관련 없는 딴짓

레드헤링: 목표로부터 주의를 딴 데로 돌리는 상황을 나타내는 영어 관용구

### 더 좋고 빠른 하드웨어!

스케일업이 당장은 도움이 되겠지만, 여러분은 아무것도 배우지 못합니다.  

첫째, 하드웨어 성능부족으로 명백하게 느린 거라면 적절한 성능의 하드웨어로 스케일업해야 합니다.  
둘째, 애플리케이션의 사용량이 급증하고 있으며, 하드웨어 스케일업이 애플리케이션 실행에 있어 안정성을 담보하기 위한 임시 방편이라면 이 방법도 시행합니다.  

이러한 예외 상황이 아니라면 MySQL 성능을 향상시킬 목적으로 취하는 하드웨어 확장은 최후의 선택입니다.  

"애플리케이션이 MySQL을 완전히 활용할 수 있는가?"
애플리케이션이 테이블 스캔을 발생시키는 경우 메모리를 늘려도 성능이 향상되지 않을 수 있습니다.  
하드웨어 확장이 애플리케이션 워크로드와 함께 확장될 때만 성능 향상에 효과적입니다.  

> 신규 서비스 오픈할 때는 인프라를 좋은 성능의 하드웨어 투입

### MySQL 튜닝

#### 튜닝

튜닝은 연구개발을 목적으로 MySQL 시스템 변수를 조정하는 행위로 구체적인 목표와 기준이 있는 실험실 수준의 작업입니다.  
그 목표는 특히 현재 한계와 관련하여 MySQL에 대한 우리의 집단 지식과 이해를 확장하는 것입니다.  

#### 구성

구성(configuring)은 시스템 변수를 하드웨어와 환경에 적합한 값으로 설정하는 행위입니다.  
MySQL 구성은 일반적으로 MySQL 인스턴스가 프로비저닝 되거나 하드웨어가 변경될 때 수행됩니다.  

#### 최적화

최적화(optimizing)는 워크로드를 줄이거나 효율성을 높여 MySQL 성능을 향상시키는 행위입니다.  
목표는 기존 하드웨어로 더 빠른 응답 시간과 더 많은 용량을 제공하는 것입니다.  

엔지니어는 튜닝과 구성, 최적화 작업을 모두 수행하므로 용어 구분이 중요하지만, 이 가운데 최적화 작업만이 여러분의 시간 측면에서 효율성을 높이는 방법입니다.  

MySQL 튜닝은 다음과 같은 두 가지 이유로 성능 측면에서 레드헤링입니다.  
첫째, 그것은 통제된 실험실에서 이루어지는 실험처럼 수행되지 않을 때가 많아 결과가 의심될 수 있습니다.  
둘째, MySQL은 이미 고도로 최적화 되었으므로 튜닝의 결과는 기대보다 성능에 큰 영향을 미치지 않습니다.  


## 2-2 MySQL 인덱스: 시각적 소개

### InnoDB 테이블은 인덱스다

InnoDB 테이블은 프라이머리 키로 구성된 B-트리 인덱스입니다.  
행은 인덱스 구조에서 리프노드에 저장된 인덱스 레코드가 됩니다.  
각 인덱스 레코드에는 로우 락, 트랜잭션 격리 등에 사용되는 메타데이터가 포함되어 있습니다.  

```
               1 .. 4 (pk)                      Root
         ↙                   ↘
      1 .. 2 (pk)    ↔     3 .. 4 (pk)          Internal
    ↙      ↘              ↙        ↘
1 (pk)      2 (pk)      3 (pk)      4 (pk)      Leaf
Ag          Au          Al          Ar
B           Be          Br          Br
C           Co          Cr          Cd
```

- 프라이머리 키 조회(lookup)은 매우 빠르고 효율적입니다.
- 프라이머리 키는 MySQL 성능에서 핵심적인 역할을 합니다.

B-트리 인덱스가 본질적으로 빠르고 효율적이라서 많은 데이터베이스 서버가 이를 채택하고 있다는 것입니다.  

`KEY 'idx_a_b' ('a', 'b')` 세컨더리 인덱스도 B-트리 인덱스지만 리프 노드는 프라이머리 키값을 저장합니다.  
MySQL이 행을 찾으려고 세컨더리 인덱스를 사용하면 전체 행을 읽기 위해 프라이머리 키를 이용하여 두 번째 조회를 수행합니다.  

1. 세컨더리 인덱스 Root 노드에서 시작
2. 세컨더리 인덱스 B-트리 내부 노드에서 검색
3. 세컨더리 인덱스 리프 노드에서 프라이머리 키값 확보
4. 3번에서 확보한 프라미어리 키값으로 프라이머리 키 Root 노드에서 시작
5. 프라이머리 키 B-트리 내부 노드에서 검색
6. 프라이머리 키 리프 노드에서 일치하는 행 확보

MySQL의 세계에서 모든 것은 프라이머리 키를 중심으로 돌아갑니다.  

### 테이블 접근 방법

때로는 쿼리에 따라 인덱스 조회가 불가능할 때도 있으며, 이 때는 인덱스 스캔 또는 테이블 스캔 같은 접근 방법이 유일합니다.  
인덱스 스캔과 테이블 스캔은 피해야 합니다.  

### 인덱스 조회

인덱스 조회에서는 인덱스의 정렬된 구조와 접근 알고리즘을 활용하여 특정 행이나 행 범위를 찾습니다.  

### 인덱스 스캔

인덱스 조회가 불가능할 때 MySQL은 전체 데이터 순차 찾기 같은 억지 기법으로 행을 찾아야 합니다.  
즉, 모든 행을 읽고 일치하지 않는 행을 필터링 합니다.  
MySQL은 프라이머리 키로 모든 행을 읽기 전에 세컨더리 인덱스로 행 읽기를 시도합니다.  
이를 **인덱스 스캔**이라고 합니다.  

- 풀 인덱스 스캔
  - 인덱스 순서대로 모든 행을 읽음
  - 인덱스 순서가 `ORDER BY`쿼리와 일치할 때 행 정렬을 피할 수 있음
  - 세컨더리 인덱스를 순서대로 스캔하는 것은 순차 읽기일 수 있지만, 프라이머리 키 조회는 거의 무작위 읽기
- 인덱스 전용 스캔
  - 인덱스에서 열값을 읽음
  - 커버링 인덱스 필요: `select index_column from table where index_column = x` select 절로 인덱스 컬럼만 조회할 때
  - 풀 스캔이 아닌 이상 인덱스 스캔으로 최적화하지 말라






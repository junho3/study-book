# 느슨하게 결합된 팀 (Loosely Coupled Teams)

https://dora.dev/capabilities/loosely-coupled-teams/


## 0. 서론

DORA 팀의 연구에 따르면, 효과적인 조직 구조와 기술적 구조는 지속적 배포(Continuous Delivery)를 달성하는 핵심 예측 요인입니다.  
즉, 당신이 Kubernetes를 사용하든 메인프레임을 사용하든 관계없이, 조직의 운영 방식과 시스템 아키텍처가 팀이 더 높은 수준의 소프트웨어 전달 성능을 실현하도록 돕는 관행을 채택할 수 있게 만듭니다.  

다음과 같은 아키텍처적 실천(Architectural Practices)을 채택하면 성공적인 결과를 이끌어낼 수 있습니다.

- 팀은 외부의 승인이나 다른 팀의 의존 없이 시스템 설계를 대규모로 변경할 수 있어야 합니다.
- 팀은 외부 인원과 세밀한 커뮤니케이션이나 조율 없이도 자체적으로 업무를 완료할 수 있어야 합니다.
- 팀은 자신이 제공하는 제품이나 서비스를 의존 관계에 있는 다른 서비스와 무관하게, 필요할 때 언제든지 독립적으로 배포 및 릴리스할 수 있어야 합니다.
- 팀은 통합 테스트 환경(integrated test environment)에 의존하지 않고, 필요할 때마다 자체적으로 테스트를 수행할 수 있어야 합니다.
- 팀은 정상 근무 시간 중에도 거의 다운타임 없이 배포를 수행할 수 있어야 합니다.

이러한 결과들은 메인프레임 기술 환경에서도 충분히 달성할 수 있습니다.
반대로, 최신이자 가장 유행하는 기술을 사용하더라도 이러한 성과를 얻지 못할 수도 있습니다.

많은 조직들이 새로운 기술을 도입하기 위해 막대한 시간과 노력을 투자하지만, 아키텍처적 제약으로 인해 정작 가장 중요한 소프트웨어 전달 성과(Software Delivery Outcomes) 를 이루지 못하는 경우가 많습니다.

시스템 아키텍처가 팀이 다른 팀에 의존하지 않고도 테스트, 배포, 그리고 시스템 변경을 수행할 수 있도록 설계되어 있다면, 그 팀은 일을 처리하는 데에 복잡한 커뮤니케이션이 거의 필요하지 않습니다.  
즉, 아키텍처와 팀 모두 느슨하게 결합(loose coupling) 되어 있는 것입니다.

커뮤니케이션 구조와 시스템 아키텍처 간의 관계는 멜빈 콘웨이(Melvin Conway)가 처음 제시했습니다.  
그는 이렇게 말했습니다:  

> “시스템을 설계하는 조직은, 그 조직의 커뮤니케이션 구조를 반영한 시스템 설계를 만들어낼 수밖에 없다.”

즉, 조직이 소통하는 방식이 곧 시스템의 구조를 결정한다는 뜻입니다.

이러한 강하게 결합된(tightly-coupled) 아키텍처를 완화하고 더 나은 커뮤니케이션 패턴을 만들기 위해, 팀과 조직은 `“Inverse Conway Maneuver(역 콘웨이 법칙 전략)”`을 활용할 수 있습니다.

이 접근법에서는 조직의 팀 구조와 협업 패턴을, 우리가 원하는 아키텍처 형태에 맞추어 설계합니다.  
그 결과, 팀 간의 커뮤니케이션 구조가  자연스럽게 시스템의 바람직한 아키텍처 패턴을 지탱하고 강화하게 됩니다.  

강하게 결합된 아키텍처에서는, 작은 변경 하나가 대규모 연쇄적 실패(cascading failure) 로 이어질 수 있습니다.

그 결과, 시스템의 한 부분에서 작업하는 사람은 다른 부분에서 일하는 사람들과 항상 긴밀히 조율해야 하며, 복잡하고 관료적인 변경 관리(change management) 절차를 거치지 않고는 어떤 수정도 하기 어려워집니다.

`마이크로서비스 아키텍처(MSA)`는 물론, 진정한 의미의 `서비스 지향 아키텍처(SOA)`라면 앞서 언급한 이러한 결과(독립적인 테스트·배포·변경)를 자연스럽게 실현할 수 있어야 합니다.

그러나 실제로는, 이른바 “서비스 지향적 아키텍처” 라는 이름을 달고 있어도 서비스 간을 독립적으로 테스트하거나 배포할 수 없는 경우가 많습니다.  
이런 구조에서는 팀이 `높은 수준의 소프트웨어 전달 성과(Software Delivery Performance)`를 결코 달성할 수 없습니다.  

따라서 서비스 지향 아키텍처나 마이크로서비스 아키텍처를 도입할 때는, 그 이름보다 실제로 이러한 결과를 달성할 수 있는지를 엄격히 검증하고 관리하는 것이 매우 중요합니다.  


## 1. 지속적 배포를 위한 아키텍처 구현 방법 (How to implement architectures for continuous delivery)

아키텍처를 설계할 때는, 먼저 주요 아키텍처 유형(architectural archetypes) 을 고려해야 합니다.  
App Engine의 엔지니어링 디렉터였던 랜디 슈프(Randy Shoup) 는 다음과 같이 말했습니다:

> “모든 제품과 모든 규모에 완벽하게 들어맞는 단 하나의 완벽한 아키텍처는 존재하지 않습니다.  
> 어떤 아키텍처든 ‘시장 출시 속도(time-to-market)’, ‘기능 개발의 용이성’, ‘확장성(scalability)’ 등 특정한 목표나 제약 조건의 조합을 충족하기 위해 설계됩니다.
> 
> 제품이나 서비스의 기능은 시간이 지나면서 반드시 진화합니다.  
> 따라서 우리의 아키텍처적 필요 역시 변화하는 것은 당연한 일입니다.  
> 1배(1×) 규모에서 잘 작동하던 구조가 10배(10×), 100배(100×) 규모에서도 통할 것이라 기대해선 안 됩니다.”  

즉, 각 아키텍처 유형에는 고유한 장단점(pros & cons) 이 있으며, 각 조직의 성장 단계와 `진화적 필요(evolutionary need)` 에 따라 서로 다른 형태가 더 적합할 수 있습니다.

| 아키텍처 유형                                                                    | 장점 (Pros)                                                                                      | 단점 (Cons)                                                                                                                                           |
|----------------------------------------------------------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| **Monolithic v1**<br>(모든 기능이 하나의 애플리케이션에 포함된 구조)                           | - 초기 구현이 단순함<br>- 프로세스 간 지연(latency)이 거의 없음<br>- 단일 코드베이스, 단일 배포 단위<br>- 소규모 환경에서는 자원 효율적      | - 팀 규모가 커질수록 협업 및 조율 비용 증가<br>- 모듈화가 강제되지 않아 유지보수 어려움<br>- 확장성(Scalability) 한계<br>- “올 오어 낫싱(All-or-Nothing)” 배포 — 일부 실패도 전체 장애로 이어짐<br>- 빌드 시간 길어짐 |
| **Monolithic v2**<br>(모놀리식 구조를 계층화한 형태 — 프론트엔드, 애플리케이션 서버, 데이터베이스 계층으로 구성) | - 초기 설계와 구현이 단순함<br>- 조인(Join) 쿼리 처리 용이<br>- 단일 스키마로 일괄 배포 가능<br>- 소규모 환경에서 자원 효율적             | - 시간이 지날수록 계층 간 결합도 증가<br>- 확장성과 중복성 부족 (수직 확장만 가능)<br>- 성능 튜닝이 어렵고 제한적<br>- “All-or-Nothing” 스키마 관리로 인한 위험                                         |
| **Microservice**<br>(독립적이고 모듈화된 서비스 구조 — 각 서비스가 자체 데이터 저장소를 가짐)            | - 각 유닛(서비스)이 단순하고 명확함<br>- 독립적인 확장 및 성능 조정 가능<br>- 서비스별 테스트 및 배포 독립<br>- 캐싱, 복제 등 성능을 최적화하기 용이 | - 협업해야 하는 서비스 단위가 많음<br>- 많은 수의 작은 저장소(레포) 관리 필요<br>- 고도화된 도구 및 의존성 관리가 필수<br>- 네트워크 지연(latency) 발생 가능                                              |

표에서 볼 수 있듯이, 린(Lean)한 제품 개발 — 예를 들어 새로운 기능의 빠른 프로토타이핑이나 전략의 전환(pivot) 이 필요한 초기 단계에서는 모놀리식(monolithic) 아키텍처가 적합할 수 있습니다.  

반면, 수백 명의 개발 팀이 존재하고 각 팀이 독립적으로 고객에게 가치를 전달해야 하는 규모의 조직에서는 전혀 다른 형태의 아키텍처가 요구됩니다.  

즉, 아키텍처는 고정된 것이 아니라 진화(evolution) 해야 합니다.  
이렇게 아키텍처가 유연하게 변화할 수 있도록 하면, 언제나 현재 조직의 필요에 가장 적합한 구조를 유지할 수 있습니다.  

그리고 어떤 아키텍처 유형을 사용하든지 간에, 지속적 배포(Continuous Delivery) 를 가능하게 하려면 팀이 이 문서의 서두에서 언급된 핵심 역량(capabilities) — 즉, 독립적 테스트, 배포, 빠른 변경 수행 능력 — 을 갖출 수 있도록 조직 차원에서 권한과 자율성을 부여해야 합니다.

제품, 개발, 테스트, 운영 등 조직 전반의 역할이 고르게 포함된 크로스펑셔널 팀(Cross-functional Team) 을 구성하면, 각 팀이 외부 의존 없이 독립적으로 일할 수 있는 구조를 만들 수 있습니다.  
이런 구조는 자연스럽게 팀 경계를 기준으로 한 시스템 설계(team boundary–driven architecture) 를 가능하게 합니다.

팀이 크로스펑셔널하게 구성되어 있다면, 그들은 자율적으로 의사결정을 내리고, 새로운 아이디어를 실험하며, 자신들에게 가장 적합한 도구와 기술 스택을 선택할 수 있습니다.

또한, 여러 팀 간의 커뮤니케이션과 테스트를 원활히 하기 위해서는 서비스 간의 계약(contracts) — 예를 들어 API 명세나 이벤트 스키마 — 를 명확히 정의해두는 것이 큰 도움이 됩니다.

팀의 독립성이 중요하듯, 그들이 담당하는 제품과 서비스의 독립성 또한 똑같이 중요합니다.  

각 서비스는 언제든지(on demand) 테스트할 수 있는 구조여야 합니다.  
이를 위해 외부 서비스에 대한 mocking(모의 객체) 과 stubbing(더미 응답) 같은 기법을 활용하면, 외부 의존성으로 인한 영향을 최소화하고 팀이 빠르게 테스트 환경을 구성할 수 있습니다.

또한, 외부 서비스에 대한 계약 기반 테스트(contract testing) 를 도입하면 의존하고 있는 서비스 간의 계약이 여전히 유효한지 지속적으로 검증할 수 있습니다.  

궁극적으로 지속적 배포(Continuous Delivery) 를 진정으로 실현하려면, 각 팀의 제품이나 서비스가 자신이 의존하는 다른 서비스와 분리된 상태에서, 독립적으로 인수 테스트(acceptance testing) 와 배포(deployment) 를 수행할 수 있어야 합니다.  

언제든지 배포할 수 있는(Deploy Anytime) 능력을 확보하려면, 높은 수준의 자동화를 갖춘 Blue/Green 배포나 Rolling 배포 모델을 고려해야 합니다.

이러한 모델에서는 하나의 제품 또는 서비스의 두 가지 이상 버전이 동시에 실행됩니다.  
이를 통해 팀은 새로운 변경사항을 운영 환경에서 안정적으로 검증(validate) 할 수 있으며, 서비스 중단(downtime) 없이 또는 거의 중단 없이 프로덕션에 배포할 수 있습니다.

단, 중요한 고려 사항은 데이터 업그레이드를 어떻게 수행할 것인가입니다.  
즉, 데이터와 스키마 변경은 반드시 이전 버전과의 호환성(backward compatibility) 을 유지하도록 설계되어야 합니다.  

구성요소(components)를 독립적으로 배포할 수 있도록 지원하기 위해,
하위 호환성(backward compatibility) 을 유지하는 버전 관리된 API(versioned API) 를 만드는 것이 좋습니다.

API는 곧 계약(contract) 이므로, 잘 관리된 API 버전 전략은 API를 사용하는 외부 소비자(다른 팀 혹은 서비스) 들에게 신뢰를 줍니다.  
반대로, 관리되지 않은 변경은 개발자 커뮤니티 전체에 부정적인 영향을 미칠 수 있습니다.  

따라서, 호환성을 깨뜨리는 변경(breaking change) 을 도입할 때는 메이저 버전(major version) 을 올리고, 의미 있는 기능 추가지만 호환성을 유지하는 변경은 마이너 버전(minor version) 으로 구분해야 합니다.  

물론, API의 하위 호환성을 유지하는 것은 시스템 복잡도를 높이는 일입니다.  
그러나 이렇게 얻는 배포 유연성과 독립성은, 그로 인한 복잡성을 충분히 보상하고도 남습니다.  

권장되는 표준은, 동시에 지원되는 API 버전은 최대 두 가지를 넘기지 않는 것입니다.  

클라이언트가 새로운 버전으로 마이그레이션할 수 있도록 전환 기간(transition period) 을 두되, 이 기간은 최대 6개월을 넘지 않도록 설정해야 합니다.  
그 이후에는 기존 버전이 완전히 폐기(retire)되어야 합니다.  

API가 폐기된 후(deprecated API endpoint), 해당 버전을 호출하려는 모든 클라이언트는 HTTP 상태 코드 410 Gone 을 반환받아야 합니다.  
이 코드는 지원이 종료된 모든 API 버전에 대한 일괄 응답(표준 응답) 으로 사용되어야 합니다.  

이러한 엄격한 제한을 지키는 것은 매우 중요합니다.  
과거의 API 버전을 너무 많이 유지하려 하면 운영 복잡도(operational complexity) 가 급격히 증가하고, 유지보수 비용 또한 지속적으로 상승하기 때문입니다.  

API 분석(Analytics) 과 가시성(Observability) 은 소비자(클라이언트)의 사용 패턴을 이해하기 위한 핵심 도구입니다.  

이러한 도구를 통해 어떤 API 버전이 호출되고 있는지, 얼마나 자주 호출되는지, 어떤 클라이언트가 사용하는지 등을 심층적으로 파악할 수 있습니다.

이런 인사이트를 기반으로, 팀은 여전히 폐기 예정(deprecated) 엔드포인트를 사용 중인 고객을 사전에 식별하고 직접 소통하여 마이그레이션을 유도할 수 있습니다.

이와 같은 타깃 기반 접근 방식(targeted approach) 은 클라이언트의 원활한 이전(migration)을 계획하고 실행하는 데 필수적입니다.

또한 Apigee 같은 전용 API 관리 플랫폼(API Management Platform) 은 이러한 수준의 운영 분석을 지원하기 위해 내장된 분석 기능과 종합적인 대시보드를 제공합니다.

서비스 지향(Service-oriented) 및 마이크로서비스(Microservice) 아키텍처는 이러한 능력(독립적 테스트와 배포)을 실현할 수 있도록 해줍니다.

그 이유는 이들이 Bounded Context(경계가 명확한 컨텍스트) 와 API 를 활용해 넓은 도메인을 작고 느슨하게 결합된 단위(loose-coupled units) 로 분리하고, 또한 테스트 더블(Test Doubles) 과 가상화(Virtualization) 를 통해 각 서비스나 구성요소를 서로 독립된 상태에서 테스트할 수 있도록 하기 때문입니다.


## 2. 아키텍처에서 흔히 발생하는 함정 (Common pitfalls in architectures)

### 1) 여러 서비스를 동시에 배포해야 하는 구조

테스트 가능성(testability)과 배포 가능성(deployability)을 우선시하지 않는 팀에서는 테스트를 위해 복잡하고 비용이 많이 드는 통합 환경(integrated environment) 이 필요해집니다.

이런 구조에서는 서비스 간 의존성이 복잡하기 때문에 여러 서비스를 동시에(big-bang 방식으로) 배포해야 하는 상황이 자주 발생합니다.  
이른바 “빅뱅 배포(Big-Bang Deployment)” 는 수많은 작업 간의 핸드오프(hand-off)와 의존 관계를 조율해야 하며, 보통 몇 시간에서 며칠이 걸리고, 상당한 서비스 중단 시간(downtime) 이 필요합니다.


### 2) 수백 명(혹은 수천 명)의 개발자 변경 사항과 통합

이런 환경에서는 각 개발자가 수십, 수백, 심지어 수천 개의 연결된 시스템과 상호 의존적인 변경 작업을 병행해야 합니다.

테스트는 극히 제한된 통합 테스트 환경에서만 수행되며, 그 환경을 확보하고 설정하는 데만 수 주가 걸리는 경우도 흔합니다.  
게다가 이 환경은 실제 운영(production)을 제대로 반영하지 못하므로 테스트의 신뢰성과 정확성이 낮습니다.

결과적으로 변경 리드타임(Lead Time)은 수주~수개월 단위로 길어지고, 개발자 생산성은 저하되며, 배포 품질 또한 떨어집니다.  


### 3) 소프트웨어 전달 과정의 병목 생성

소프트웨어 전달 파이프라인에는 종종 특정 팀 또는 서비스가 병목(bottleneck) 으로 작동합니다.  
예를 들어, 모든 테스트나 배포를 수동으로 담당하는 단일 팀, 여러 팀이 공통적으로 의존하는 운영 서비스 등이 여기에 해당됩니다.  

이러한 병목 지점은 단일 장애 지점(Single Point of Failure) 이 되며, 의존하는 팀의 수요를 충족하기 위해 그 팀(또는 서비스)은 비정상적인 수준으로 확장(scale) 해야 합니다.


## 3. 아키텍처를 개선하는 방법 (Ways to Improve Your Architecture)

작은 규모의 개발팀이 독립적으로 코드를 구현·테스트·배포할 수 있는 아키텍처를 구축하면, 더 안전하고 빠르게 프로덕션 환경에 코드를 반영할 수 있습니다.  
그 결과, 개발자 생산성이 높아지고 배포 품질도 향상됩니다.

이러한 구조의 핵심은 서비스 지향(Service-oriented) 및 마이크로서비스(Microservice) 아키텍처가 가진 공통적인 특징, 즉 경계가 명확한 컨텍스트(Bounded Context) 를 기반으로 한 느슨하게 결합된(loose coupling) 서비스들의 집합이라는 점입니다.  

이 원칙을 토대로 한 현대 웹 아키텍처 패턴 중에서 가장 널리 알려진 것이 바로 “12-Factor App” 방법론입니다.  

App Engine 엔지니어링 디렉터였던 랜디 슈프(Randy Shoup) 는 다음과 같이 말했습니다:

> “Google과 Amazon처럼 서비스 지향 아키텍처(Service-oriented Architecture)를 적용한 조직들은 놀라운 수준의 유연성과 확장성(flexibility & scalability) 을 가지고 있습니다.  
> 이들 조직은 수만 명의 개발자를 보유하고 있음에도, 작은 팀 단위로도 매우 높은 생산성(productivity) 을 유지하고 있습니다.”

하지만 많은 조직에서는 여전히 서비스를 테스트하고 배포하는 일이 어렵습니다.  
이럴 때 모든 시스템을 한 번에 재설계(re-architect)하려 하기보다, 점진적으로 설계를 개선해 나가는 접근법(iterative approach) 이 바람직합니다.  

이러한 방식은 진화적 아키텍처(Evolutionary Architecture) 라고 불립니다.  
이 개념은, 성공적인 제품과 서비스라면 시간이 지나며 새로운 요구사항이 생기기 때문에 수명 주기(lifecycle) 동안 여러 차례의 아키텍처 재설계가 불가피하다는 사실을 전제로 합니다.  

이 맥락에서 특히 유용한 패턴 중 하나가 Strangler Fig Application(목련나무 패턴) 입니다.

이 패턴은 기존의 모놀리식 아키텍처(monolithic architecture) 를 한 번에 갈아엎지 않고, 점진적으로(component 단위로) 대체해 나가는 접근법입니다.

즉, 새로운 기능이나 변경 작업은 반드시 서비스 지향 아키텍처(Service-oriented Architecture)의 원칙에 따라 개발하고, 그 과정에서 새로운 시스템이 기존 시스템에 일부 위임(delegate) 하도록 허용합니다.  

시간이 지나면서 점점 더 많은 기능이 새 아키텍처로 옮겨지고, 결국 기존 시스템은 서서히 “조용히 숨이 막혀( strangled )” 사라지는 구조가 됩니다.  

제품(Product) 과 서비스(Service) 의 아키텍처는 끊임없이 진화합니다.  
새로운 모듈이나 서비스를 만들어야 할지 결정하는 방법은 다양하며, 그 과정은 언제나 반복적(iterative) 입니다.

어떤 기능을 별도의 서비스(Service) 로 분리할지를 판단할 때는 다음과 같은 특징을 갖고 있는지 고려해보세요 👇

- 하나의 명확한 비즈니스 기능 또는 역량(capability) 을 수행한다.
- 다른 서비스와의 상호작용이 최소화된 상태로 자신의 역할을 완수한다.
- 다른 서비스와 독립적으로 빌드, 확장(스케일링), 배포될 수 있다.
- 다른 서비스와의 통신은 가벼운(lightweight) 방식 — 예를 들어 메시지 버스(message bus) 나 HTTP 엔드포인트 — 을 사용한다.

서로 다른 도구, 프로그래밍 언어, 데이터 저장소 등으로도 구현이 가능하다.

마이크로서비스(Microservices) 또는 서비스 지향 아키텍처(SOA) 로 전환하면,
그 영향은 단순히 시스템 구조를 넘어 조직 전체의 운영 방식에까지 미칩니다.

Steve Yegge는 그의 유명한 “Platform Rant”에서 SOA로의 전환을 통해 얻은 중요한 교훈들을 다음과 같이 정리했습니다 👇

- 모니터링(Monitoring)과 지표(Metrics) 의 중요성이 훨씬 커집니다. 하지만 이슈의 근본 원인 분석(RCA) 은 훨씬 더 어려워집니다. 한 서비스에서 나타난 문제의 실제 원인이 여러 단계(service calls) 뒤에 있는 다른 서비스일 수 있기 때문입니다.
- 내부 서비스 간에도 DoS(Denial of Service, 서비스 거부) 유형의 문제가 발생할 수 있습니다. 따라서 쿼터(Quota) 와 메시지 스로틀링(Message Throttling) 정책을 모든 서비스에 적용해야 합니다.
- QA(품질 보증) 와 모니터링의 경계가 점차 흐려집니다. 모니터링은 단순한 시스템 상태 점검을 넘어 서비스의 비즈니스 로직과 데이터 흐름을 실제로 검증할 정도로 포괄적이어야 합니다.
- 서비스가 많아질수록, 서비스 디스커버리(Service Discovery) 메커니즘이 필수적이 됩니다. 그래야 시스템이 효율적으로 작동할 수 있습니다.
- 표준화된 디버깅 환경(Debuggable Environment) 이 없다면, 다른 팀이 운영하는 서비스를 디버깅하는 일이 훨씬 어려워집니다. 즉, 공통의 서비스 실행 표준이 필요합니다.


## 4. 사례 연구: Datastore (Case Study: Datastore)

강하게 결합된 아키텍처(tightly coupled architecture) 는 팀 전체의 생산성과 안정적인 변경 능력(safe change) 을 저해할 수 있습니다.

반대로, 느슨하게 결합된 아키텍처(loosely coupled architecture) 는 명확하게 정의된 인터페이스(well-defined interfaces) 를 통해 모듈 간 연결 방식을 명확히 제한함으로써, 생산성과 안정성을 동시에 높여줍니다.

이러한 느슨한 결합 구조에서는 작고 민첩한 팀(small, productive teams) 이 각자 독립적으로 변경을 수행하고, 이를 안전하게(Safely) 그리고 독립적으로(Independently) 배포할 수 있습니다.

또한 각 서비스가 명확히 정의된 API 를 가지고 있기 때문에, 서비스 간 테스트가 용이하며, 팀 간에 명확한 계약(Contracts) 과 서비스 수준 합의(SLAs) 를 설정하기도 훨씬 수월해집니다.

App Engine 엔지니어링 디렉터였던 랜디 슈프(Randy Shoup) 는 이 아키텍처를 다음과 같이 설명했습니다:

>“이러한 유형의 아키텍처는 Google에서 매우 성공적으로 작동해왔습니다.  
> 예를 들어 Gmail 같은 서비스 아래에는 다섯~여섯 개의 서비스 계층이 존재하며, 각 계층은 매우 특정한 기능에만 집중하고 있습니다.  
>
> 각 서비스는 소규모 팀이 담당하며, 그 팀이 해당 서비스의 기능을 직접 개발하고 운영합니다.  
> 또한 각 팀은 필요에 따라 서로 다른 기술 스택을 선택할 수도 있습니다.  
> 
> 또 다른 예로, Datastore 서비스를 들 수 있습니다.  
> 이는 세계 최대 규모의 NoSQL 서비스 중 하나이지만, 약 8명 정도의 팀이 이를 운영하고 있습니다.  
>
> 그 이유는 Datastore가 서로 의존하며 쌓여 있는 여러 계층의 안정적인 서비스들 위에 구축되어 있기 때문입니다.”

이와 같은 서비스 지향 아키텍처(Service-oriented Architecture) 는 각 팀이 작고 단순한 개발 단위(small, simple units) 에 집중할 수 있도록 해줍니다.  
이를 통해 각 팀은 독립적으로, 그리고 빠르고 안전하게 서비스를 배포(deploy)할 수 있습니다.  


## 5. 아키텍처 개선을 측정하는 방법 (Ways to Measure Architectural Improvement)

메인프레임 환경이든 마이크로서비스 환경이든, 아키텍처 개선을 위한 실천(practices) 을 가능하게 하는 구조를 갖추는 것은 소프트웨어 전달 성과(Software Delivery Performance) 를 향상시키는 데 필수적입니다.  

서비스와 제품 간의 결합도가 낮아질수록, 배포 빈도(Deployment Frequency) 는 자연스럽게 증가해야 합니다.  
또한, `문제를 탐지하고 복구하는 시간(Time to Detect & Recover)`, `변경사항이 프로덕션에 도달하기까지 걸리는 시간(Lead Time for Changes)` 역시 점점 줄어드는 것이 이상적입니다.

느슨하게 결합된 팀(Loosely Coupled Teams) 의 핵심 아이디어는 각 팀이 서로 의존하지 않고 독립적으로, 그리고 빠르게 고객에게 가치를 전달할 수 있어야 한다는 것입니다.  

이를 위해서는 단순히 기술적 아키텍처뿐만 아니라, 조직 구조(Organizational Structure) 또한 의존성과 커뮤니케이션 비용을 최소화하도록 설계되어야 합니다.  


다음은 아키텍처 개선 정도를 평가하기 위해 테스트할 수 있는 주요 요소(factors) 와 각 요소별로 측정할 수 있는 항목들입니다.

### 1) 팀의 자율성과 독립성 (Team Autonomy and Independence)

- 의사결정(Decision-making): 
  - 팀의 서비스와 관련된 설계 또는 아키텍처 변경 중 외부 승인 절차(예: Architecture Review Board) 를 거쳐야 하는 비율은 얼마인가?
- 배포 의존성(Deployment dependencies): 
  - 프로덕션 배포 중 다른 서비스와 동시에(coordinated) 배포해야 하는 경우의 비율은 얼마인가?
- 테스트 의존성(Testing dependencies): 
  - 팀의 기능 검증(functional validation) 중 공유 통합 테스트 환경 없이 수행할 수 있는 비율은 얼마인가? 
  - 또한, 독립적인 테스트 환경을 새로 확보하는 데 걸리는 시간은 얼마나 되는가?


### 2) 커뮤니케이션 및 조율 비용 (Communication and Coordination Overhead)

- 교차 팀 커뮤니케이션(Cross-team communication):
  - 팀 구성원이 다른 팀과의 업무 조율(회의, 채팅, 이메일 등)에 주당 평균 몇 시간을 소모하는가?
- 핸드오프(Handoffs) 횟수:
  - 하나의 기능(feature) 또는 변경사항이 ‘코드 완료(code complete)’에서 ‘사용자 배포(released to users)’ 상태로 가기까지 몇 번의 팀 간 인계(hand-off) 가 필요한가?
- 대기 시간(Wait times):
  - 다른 팀으로부터 리뷰, 승인, 작업 지원을 받기까지 걸리는 평균 대기 시간은 얼마인가?


### 3) 독립적 작업을 지원하는 아키텍처 (Architectural Support for Independent Work)

- 독립 배포 가능성(Independent deployability):
  - 팀의 서비스가 정상 근무 시간 중에도 거의 다운타임 없이(negligible downtime) 프로덕션에 배포 가능한가?
- 독립 테스트 가능성(Independent testability):
  - 팀이 서비스의 의존성을 테스트 더블(test doubles) — 예: stubs, mocks, fakes — 로 대체하여 독립적으로 테스트할 수 있는가?
- 서비스 계약(Service contracts):
  - 팀이 다른 서비스와의 의존 관계가 유효함을 검증하기 위한 계약 테스트(contract tests) 를 유지·관리하고 있는가? 
  - 또한, 이 계약 테스트의 실패율(failure rate) 은 얼마나 되는가?


### 4) 외부 변경의 영향 (Impact of External Changes)

- 상위 서비스 장애(Upstream failures):
  - 팀이 의존하는 상위 서비스의 장애가 우리 서비스의 장애나 성능 저하로 이어지는 빈도는 어느 정도인가?
- 상위 서비스 변경(Upstream changes):
  - 상위 팀이 수행한 변경으로 인해 우리 서비스에서 비계획적(unplanned) 변경이 필요한 경우는 얼마나 자주 발생하는가?


### 5) 결론

더 높은 수준의 팀 독립성을 가진 조직은 다음과 같은 특징을 보입니다:

- 직무 만족도(Job Satisfaction) 가 향상되고, 
- 실험적 시도(Experimentation) 가 활발하며, 
- 팀의 필요에 따라 다양한 기술과 도구를 선택하는 경향이 있습니다.




# CHAPTER 6 진화적 데이터

데이터는 아키텍처 커플링보다 더 골치 아픈 결합 구조를 형성하곤 한다.  

> 위와 같은 이유로 서비스 로직에서 Jpa 엔티티를 직접 사용하는건 싫어함  

데이터는 진화적 아키텍처 설계에서 매우 중요하게 다루는 차원이다.  
특히 마이크로서비스 아키텍처는 데이터 파티셔닝, 의존성, 트랜잭션 등을 더욱 심도 깊게 고려해야 한다.  


## 6.1 진화적 데이터베이스 설계

진화적 데이터베이스 설계란 요구 사항의 변화에 따라 발전하는 데이터베이스를 구축하는 것이다.  


### 6.1.1 진화적 스키마

진화적 데이터베이스 설계의 핵심은 진화하는 스키마이며, 이는 코드를 통해 실현할 수 있다.  
개발자는 데이터베이스 변경 사항을 마치 소스 코드처럼 테스트하고, 버전을 매기고, 증분 형태로 관리 해야 한다.  

> 토스ㅣSLASH 22 - 토스뱅크의 완전히 새로운 대출 시스템  
> https://youtu.be/SLamxuykpnw?feature=shared  
> DB 버전 관리 Flyway 소개  


#### 테스트

ORM 등의 데이터 매핑 도구를 사용하는 경우, 피트니스 함수를 통해 매핑 코드와 스키마를 항상 동기화시키는 것이 좋다.  

> qa, prod 환경은 validate를 설정해놓는 편  
> jpa.hibernate.ddl-auto: validate  
> 
> JPA, Exposed 엔티티 검증 (동현님 아이디어)  
> https://github.com/junho3/practice-kotlin-spring-boot/commit/4a9ab2e7babbea45c32f347b2cfb0d086d99df0d


#### 버전 관리

#### 증분 변경

> 테이블 변경은 DA#이라는 솔루션으로 관리하고, 테이블 변경 작업은 DBA가 진행하고 있어서 개발자가 관여하진 않음  


### 6.1.2 공유 데이터베이스 통합

공유 데이터베이스 통합 패턴은 데이터베이스를 공유 메커니즘으로 사용하는 통합 패턴이다.  

데이터베이스를 통합 지점으로 활용하면 이를 공유하는 모든 프로젝트에서 스키마가 고착화될 우려가 있다.  
애플리케이션 A가 스키마를 변경하면 다른 애플리케이션은 잠재적 장애 위험에 처한다.  

> MSA에서는 DB를 분리하는 것에 동의 (단일 퀀텀)  
> 그러나 비용적인 측면도 있기 때문에 단일 인스턴스에 스키마만 분리하는 것도 좋은 선택이라고 생각 함  

문제의 소지가 있는 커플링을 해소하는 일반적인 리팩터링 패턴이 바로 확장/수축 패턴이다.  

> 확장/수축 패턴  
> 1. 기존 컬럼은 유지하고, 새로운 컬럼을 추가  
> 2. 기존 컬럼과 새로운 컬럼 모두 데이터를 저장  
> 3. 기존 컬럼 삭제  
>
> 기존 컬럼을 참조하지 않는지 어떻게 알 수 있을까?  
> git repo에서 컬럼명 검색? name이라는 컬럼명은 검색 결과가 많을탠데?  

#### 조건 1: 통합 지점 없음, 레거시 데이터 없음

#### 조건 2: 레거시 데이터 존재, 통합 지점 없음

#### 조건 3: 기존 데이터 존재, 통합 지점 존재

> SQL TRIGGEER 명령어로 해결하는 방법을 소개하고 있지만, 이게 맞는 방법인지 확신하지 못 하겠음  
> 변경에 대한 책임을 DB에게 부여하는게 맞는건지?  


## 6.2 부적절한 데이터 얽힘

데이터베이스 또는 데이터팀은 통상적인 수준보다 뒤처진 개발 도구와 엔지니어링 관행을 따르는 경우가 많다.  

> 요즘은 파이썬정도는 다 하시는 듯  

여러 팀의 관계, 자원 배분, 프로덕션 팀의 필요성 등의 요건이 복잡하게 얽혀 데이터베이스 리팩터링은 우선순위에서 멀어지곤 한다.  

> 시스템 규모가 커질 수록 컬럼 추가/삭제와 같은 DB 작업은 장애 위험성이 높아 최적화를 안하는 듯  


### 6.2.1 2단계 커밋 트랜잭션

대부분의 프로젝트는 아키텍처 기술 외에도 트랜잭션을 비롯해 다양한 커플링 구조를 포함한다.  
이는 모놀리식 아키텍처와 분산 아키텍처에 모두 해당하는 사실이다.  

트랜잭션은 특수한 형태의 커플링이며, 전통적인 기술 아키텍처 중심 도구는 트랜잭션의 동작을 드러내지 못한다.  
트랜잭션 커플링은 컴포넌트를 구체적인 방식으로 결합시키며 진화를 방해하는 요인이 된다.  

> Jpa와 Exposed를 같이 트랜잭션을 묶을 수 없음  

트랜잭션을 사용하는 이유  
1. 복잡한 시스템은 전역적으로 제어하기 어려움
2. **트랜잭션의 경계를 조사하면 비즈니스적 개념이 실제 구현과 어떻게 결합되어 있는지 확인 가능**
3. 트랜잭션 콘텍스트를 데이터팀이 관할하고 있다면 아키텍처의 기술적 커플링과 마찬가지로 데이터의 결합 역시 분리하기 쉽지 않다.

> 2번 이유가 인상적  
> 하지만 난개발 된 레거시 시스템에서는 경계를 분석하는건 불가능  

아키텍처 퀀텀은 가장 작은 아키텍처 배포 단위이며, 응집도에 대한 전통적인 인식과 달리 데이터베이스 등의 의존 컴포넌트까지 포함하는 개념이다.  
아키텍트는 비즈니스에 어울리는 자연스러운 수준보다 더 세분화된 아키텍처를 구축하려는 실수를 범하곤 한다.  
마이크로서비스 아키텍처는 과도한 트랜잭션이 발생하는 시스템에 어울리지 않는다.  

> 트랜잭션이 꼭 필요한지 판단할 수 있어야 함  
> 기술적 문제를 비즈니스(운영)적으로 풀 수도 있다고 생각 함  

클래스, 패키지, 네임스페이스, 라이브러리, 프레임워크, 데이터 스키마, 트랜잭션 콘텍스트 등, 커플링을 형성하는 요소는 매우 다양하다.  

아키텍트는 트랜잭션 콘텍스트를 가급적 제한해야 한다.  
트랜잭션 콘텍스트는 견고한 커플링을 형성하며 일부 컴포넌트나 서비스를 변경할 때 다른 요소에 파급효과가 미치게 되는 부작용을 낳는다.  
아키텍처의 변화를 고려할 때 트랜잭션 경계까지 추가로 염두에 두어야 한다는 것이다.  

> 처음에는 Spring AOP 방식의 트랜잭션이 불편했는데, 책에서 나온 내용을 생각해보면 AOP 방식의 트랜잭션이 주는 장점도 있는 듯  

**마이크로서비스라는 용어를 지나치게 문자 그대로 해석하면 곤란하다.  
서비스의 크기를 줄이는 것보다 유용한 경계 콘텍스트를 포착하는 것이 더 중요하다.**  

> 동의  


### 6.2.2 데이터의 연식과 품질

몇몇 CTO는 '애플리케이션의 수명은 짧다. 영원히 살아남는 데이터 스키마가 훨씬 더 귀중하다'라고 공공연하게 주장한다.

현실의 스키마가 변경될 때 데이터베이스 리팩토링 대신 조인 테이블을 추가하는 방식으로 스키마 정의를 확장하는 곳이 많다.  
이 방식은 단기적으로 효과를 내지만 실제로는 본래의 추상화 구조를 난독화시키는 결과를 초래한다.  

> 기회비용을 고려해야할 듯  
> 컬럼 추가 / 삭제는 위험한 작업  
> 확장/수축 패턴과 유사하게, 신규 테이블 생성 후 기존 테이블에 듀얼라이팅 하고 점차 줄여나가는 방법도 괜찮지 않을까  

데이터팀이 데이터베이스를 재구성할 의지가 없다는 것은 귀중한 기업 자원을 방치하고 있다는 말과 같다.  

여러 세대의 소프트웨어를 거쳐 살아남은 데이터는 제각기 고유한 퍼시스턴스 문제에 시달린다.  
시간이 지나면 이러한 데이터는 일관성을 잃는 정도를 넘어 최악의 경우에는 쓰레기 수준으로 전락하는 최후를 맞는다.  

교정 절차는 전용 메커니즘을 구축해 지속적으로 처리하기보다는 문제 발견 즉시 조기에 해결하는 것이 더 바람직하다.  

레거시 스키마와 데이터는 그만한 가치가 있는 자산이다.  
그러나 이들은 마치 진화 역량에 부과된 세금처럼 부담스럽게 느껴진다.  


### 6.2.3 사례연구 PenultimateWidgets의 라우팅 진화

라우팅 서비스는 이전 버전과 새 버전을 모두 지원해야 한다.  
개발자는 확장/수축 패턴을 이용해 새로운 라우팅 구조를 만들고 서비스를 통해 호출할 수 있다.  
두 라우팅 테이블의 route 컬럼은 모두 트리거가 걸려 있으며 한 쪽의 변경 사항이 다른 쪽 테이블에 자동으로 복제된다.  

> 기회비용을 따져봐야겠지만, SQL TRIGGER로 동기화하는 방식은 별로 하고 싶지 않음  
> 트리거가 DB 성능에 미치는 영향 https://mozi.tistory.com/328  

데이터베이스의 구조는 실제 세계를 바탕으로 추상화되므로 언제든 예상치 못한 변화가 발생할 수 있다.  
아키텍트는 데이터를 진화적 아키텍처의 주요 관심사로 취급해야 한다.  


## 6.3 네이티브에서 피트니스 함수로

아키텍트가 마이크로서비스 아키텍처를 채택하고 경계 콘텍스트당 하나의 데이터베이스를 배정하면, 데이터팀이 데이터베이스를 바라보는 전통적인 관점에 변화가 생긴다.  
데이터팀은 데이터가 구조적으로 연결되는 지점의 정확성을 유지하기 위해 참조 무결성에 세심한 주의를 기울인다.  

> DBA조차 FK를 사용하는걸 원치 않아함

마이크로서비스의 장점을 취하기 위해 데이터팀이 신봉하는 메커니즘을 일부 포기하도록 설득할 수 있을까?

빌드 과정에 피트니스 함수를 적용해 중요 지점의 무결성을 보장하고 다야한 작업을 처리할 수 있다.  


### 6.3.1 참조 무결성

참조 무결성은 아키텍처 커플링이 아닌 데이터 스키마 수준에서 형성되는 거버넌스의 일종이다.  
그러나 아키텍트의 관점에서 보면 둘 다 커플링을 늘리며 애플리케이션의 진화 능력에 지장을 주는 방해물이다.  

데이터베이스의 참조 무결성은 기본 키와 연결 관계에 근거해 형성된다.  
이벤트 기반 아키텍처는 주로 이러한 작업을 백그라운드에서 처리하는 여러 패턴으로 구성된다.  

참조 무결성은 데이터베이스를 강화하는 특성이지만, 바람직하지 않은 커플링을 생성하는 부작용을 낳는다.  


### 6.3.2 데이터 중복

하나의 관계형 데이터베이스만 다루다 보면 읽기와 쓰기라는 두 작업이 별개라는 사실을 잊게 되는 경우가 많다.  

> 그림 6-8, 6-9, 6-10은 마이크로서비스 환경에서 DB도 분리되었을 때 타 도메인 서비스에서 공통 정보를 가져오는 방법을 제시하는 것으로 이해함  
> 책에서는 캐싱을 제안하고 있는데, 캐시 히트율을 생각해봐야할 듯  
> 캐싱보다 ro RDS를 늘리는게 좋지 않을까?  


### 6.3.3 트리거 및 저장 프로시저 대체

저장 프로시저는 데이터팀이 자주 애용하는 기술 중 하나다.  
프로시저는 단위 테스트로 검증하기 어렵고, 리팩토링 난이도가 높으며, 소스 코드의 동작과 분리된 별도의 동작을 수행한다는 문제가 있다.  

> 컬리 때도 알 수 없는 프로시저 때문에 DB 장애가 발생하곤 했음  
> 분산 DB 환경에서 AWS 데이터 관련 기능들로 CDC를 구성하거나, 카프카 컨슈머 어플리케이션으로 데이터 처리를 했음  

저장 프로시저의 동작을 애플리케이션 코드로 추출하는 과정도 확장/수축 패턴에 대입할 수 있다.  

확장 단계에서 개발자는 위젯 관리 서비스에 대체 메소드를 추가하고, 다른 서비스가 위젯 관리 서비스를 호출하도록 리팩토링한다.  
초기에는 대체 메서드가 기존 저장 프로시저의 역할을 대행하며 다른 팀은 면밀한 테스트를 바탕으로 프로시저 호출부를 서비스로 대체한다.  

> 컬리 때 결제 서비스 MSA 전환할 때도 주문 데이터를 신규 결제 DB에 마이그레이션이 필요했음  
> 취소를 하기 위해서는 원 결제 데이터가 필요하기 때문  
> 신규 결제 서비스로 전환하기 전에 과거 데이터는 마이그레이션 했으나, 그 당시 상황에서 전환 당일 데이터를 다운타임 없이 마이그레이션하는 것은 불가능하다고 판단  
> 어플리케이션 취소 로직에서 신규 DB에 결제 데이터가 없으면 레거시 로직으로 동작하도록 구현하여 대응함  


### 6.3.4 사례연구 관계형에서 비관계형으로의 진화

모놀리식 애플리케이션은 카탈로그, 분석 데이터, 운영 데이터를 모두 하나의 데이터베이스에 저장한다.  
이러한 구조는 관계형 데이터베이스의 올바른 사용 방식을 왜곡시킬 위험이 있다.  

그러나 단일 데이터베이스를 여러 데이터베이스로 이관하는 작업은 설령 데이터 유형이 같다해도 문제 발생의 여지가 많다.  
이러한 아키텍처 요구 사항을 관철시키기 위해 아키텍트는 각 사안에 내재된 트레이드오프를 명확히 제시할 수 있어야 한다.  


## 요약

진화적 아키텍처의 정의는 명백히 '다양한 차원'을 강조한다.  
경계 콘텍스트를 기반으로 아키텍처를 재구성하는 것은 곧 데이터의 분한을 의미하며, 이는 자체적인 트레이드오프를 동반한다.  



# 6장 키-값 저장소 설계

키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스이다.  
이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 한다.  
키와 값 사이의 이런 연결 관계를 "키-값" 쌍이라고 지칭한다.  

키-값 저장소로 널리 알려진 것으로는 아마존 다이나모, memcached, 레디스 같은 것들이 있다.  

> memcached vs Redis  
> https://escapefromcoding.tistory.com/704
> 
> Elastic Cash for Redis vs Memory DB for Redis
> https://hyunki1019.tistory.com/169
> https://goodlucknua.tistory.com/129

## 문제 이해 및 설계 범위 확정

## 단일 서버 키-값 저장소

가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는 것이다.  
그러나 이 접근법은 빠른 속도를 보장하긴 하지만 모든 데이터를 메모리 안에 두는 것이 불가능할 수도 있다는 약점을 갖고 있다.  
이 문제를 해결하기 위한 개선책으로는 다음과 같은 것이 있다.  

- 데이터 압축  
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장  

## 분산 키-값 저장소

분산 키-값 저장소는 분산 해시 테이블이라고도 불린다.  
분산 시스템을 설계할 때는 CAP 정리를 이해하고 있어야 한다.  

### CAP 정리 

CAP 정리는 데이터 일관성, 가용성, 파티션 감내라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다.  

- 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.  
- 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.  
- 파티션 감내: 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.  

- CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생한다. ex) 몽고DB  
- AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성을 희생한다. ex) 카산드라   
- CA 시스템: 일관성과 가용성을 지원하는 키-값 저장소. 파티션 감내는 지원하지 않는다. ex) MySql  

#### 이상적 상태

n1 <> n2 <> n3 간 복제가 되는 환경

#### 실세계의 분산 시스템

분산 시스템은 파티션 문제를 피할 수 없다.  
파티션 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택해야 한다.  

가용성 대신 일관성을 선택한다면 n1과 n2에 대해 쓰기 연산을 중단시켜야 하는데, 그렇게 하면 가용성이 깨진다.  
일관성 대신 가용성을 선택한 시스템은 설사 낡은 데이터를 반환할 위험이 있더라도 계속 읽기 연산을 허용해야 한다.  

#### 시스템 컴포넌트

##### 데이터 파티션

대규모 애플리케이션의 경우 전체 데이터를 한 대 서버에 욱여넣는 것은 불가능하다.  
가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것이다.  

- 데이터를 여러 서버에 고르게 분산할 수 있는가
- 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가

안정 해시 장점
- 규모 확장 자동화
- 다양성

##### 데이터 다중화

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.  

##### 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.  
정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.  

w = 1은 데이터가 한 대 서버에만 기록된다는 뜻이 아니다.  
w = 1의 의미는 쓰기 연산이 성공했다고 판단하기 위해 중재자는 최소 한 대 서버로부터 쓰기 성공 응답을 받아야 한다는 뜻이다.  

> 카프카 ack: -1 (all)

##### 일관성 모델

- 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.  
- 약한 일관성: 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수도 있다.  
- 최종 일관성: 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다.  

강한 일관성을 달성하는 일반적인 방법은, 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것이다.  
이 방법은 고가용성 시스템에는 적합하지 않다.  

> 비관적 락
> 트랜잭션 격리 수준  
> https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/

##### 비 일관성 해소 기법: 데이터 버저닝

버저닝과 벡터 시계는 그 문제를 해소하기 위해 등장한 기술이다.  

> 낙관적 락?

##### 장애 처리

##### 장애 감지

각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.  
어떤 멤버의 박동 카운터 값이 지저된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.  

##### 일시적 장애 처리

네트워크나 서버 문제로 장애 상태인 서버로 가는 요청은 다른 서버가 잠시 맡아 처리한다.  
그동안 발생한 변경사항은 해당 서버가 복구되었을 때 일괄 반영하여 데이터 일관성을 보존한다.  
이를 위해 임시로 쓰기 연산을 처리한 서버에 그에 관한 단서를 남겨둔다.  

> 카프카 컨슈머 그룹 리밸런싱
> 그룹 코디네이터가 일정 기간(session.timeout.ms) 동안 컨슈머의 하트비트를 받지 못하면, 해당 컨슈머는 어떠한 이유(장애, 종료 등)로 작업이 불가한 것으로 판단하고 해당 컨슈머의 파티션 소유권을 다른 컨슈머로 이관합니다.

##### 영구 장애 처리

##### 데이터 센터 장애 처리

> AWS GCP 듀얼 구성

#### 시스템 아키텍처 다이어 그램

모든 노드가 같은 책임을 지므로, SPOF는 존재하지 않는다.  

#### 쓰기 경로

#### 읽기 경로

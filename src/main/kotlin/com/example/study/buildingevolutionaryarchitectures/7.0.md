# CHAPTER 7 진화 가능한 아키텍처 구축

앞서 논의한 많은 개념은 새로운 아이디어라기보다 새로운 시각으로 바라본 오래된 아이디어라 할 수 있다.  
테스트는 오래전부터 존재했지만 아키텍처 검증과 피트니스 함수에 주목한 것은 근래의 일이다.  

> 최신 기술의 원리는 옛 개념의 바탕이라고 생각 함  
> 최근에 개념을 부여하고, 실체화한 것일 뿐  


## 7.1 진화적 아키텍처의 원리

### 7.1.1 책임이 따르는 마지막 순간

중요한 결정은 가능한 미루되, 더 이상 미룰 수 없는 시점을 넘기면 안 된다.  
성급하게 내린 결정은 과도한 엔지니어링을 낳고, 적시를 놓친 결정은 아키텍처가 지향하는 목표를 가로 막는다.  


### 7.1.2 진화성을 높이는 설계 및 개발

아키텍트는 진화성을 아키텍처의 최우선 목표로 여겨야 한다.  
이는 아키텍처 특성을 분석하는 객관적인 척도가 필요하다는 뜻이다.  

데이터 등의 외부 통합 지점, 즉 아키텍처 퀀텀의 정적 커플링 지점은 아키텍트가 가장 중요하게 여기는 설계 요소다.  
아키텍트는 데이트 의존성을 코드 의존성과 동일선상에 두고 취급해야 한다.  


### 7.1.3 포스텔의 법칙

자신의 것은 보수적으로 행하고, 다른 이의 것은 관대하게 받아들이도록 하라.  

#### 자신의 것은 보수적으로 하달하라

불필요하게 많은 정보를 전송하지 않도록 주의해야 한다.  

#### 다른 이의 것은 관대하게 수용하라

소비하는 것보다 많은 정보를 받아들여도 좋다.  
추가 데이터가 있다 해도 꼭 필요한 정보만 사용하면 된다.  

#### 계약을 해제할 때는 버전을 관리하라

자동화된 소비자 주도 계약은 통합 아키텍처에서 중요한 역할을 한다.  


### 7.1.4 테스트성과 아키텍트

테스트하기 용이한 아키텍처의 대표적인 특성은 단일 책임 원칙 준수다.  
우수한 시스템은 각 부분이 저마다 하나의 책임을 가진다.  

> SRP는 코드에만 적용되는 개념인줄 알았으나, 컬리 때 시니어 개발자분이 SRP는 시스템에도 적용해야한다는 얘기를 듣고 띠용했던 기억이 있음  


### 7.1.5 콘웨이의 법칙

진화적 아키텍처를 구축하려면 팀 구조 또한 주의 깊게 살펴야 한다.  


## 7.2 역학

### 7.2.1 진화의 영향을 받는 차원 식별

아키텍트는 아키텍처가 진화하는 동안 보호해야 할 아키텍처 차원을 식별해야 한다.  
- 아키텍처의 기술적 특성
- 데이터 설계
- 보안
- 확장성


### 7.2.2 각 차원의 피트니스 함수 정의

코드베이스와 관련된 이러한 아키텍처 특성을 관리하기 위해, 아키텍트는 다양한 코드 메트릭을 배포 파이프라인에서 활용한다.  
아키텍트는 지속적으로 관리할 차원을 선별하고 위키 등의 간단한 양식을 이용해 문서화한다.  
각 차원의 진화 과정에 드러나는 불필요한 행동을 식별한 다음 최종적으로 피트니스 함수를 정의한다.  


### 7.2.3 배포 파이프라인을 이용한 피트니스 함수 자동화

아키텍트는 프로젝트의 변화가 증분 변경으로 진행되도록 장려해야 한다.  
증분 변경은 배포 파이프라인에서 피트니스 함수를 통해 선제적으로 검증할 수 있으며, 배포 등의 일상 작업이 시야에서 사라질 만큼 높은 수준의 자동화를 가능하게 한다.  
진화적 아키텍처 프로젝트에 참여한 개발자는 적절한 순환 주기를 유지해야 할 의무가 있다.  
순환 주기가 길어지면 프로젝트가 새로운 세대를 등장시키는 속도가 둔화되며 진화성을 저해하는 요인이 된다.  

소프트웨어는 항상 알려지지 않은 미지의 문제에 시달린다.  
아키텍트는 비기능적 요구 사항이 처리되는 현황과 장애를 주시하고 피트니스 함수로 아키텍처를 개선하며 미래의 문제를 방지해야 한다.  


## 7.3 그린필드 프로젝트

신규 프로젝트에 진화성을 구축하는 것은 기존 프로젝트를 개조하는 것보다 훨씬 쉽다.  


## 7.4 기존 아키텍처 개조

기존 아키텍처에 진화성을 더하는 세 가지 조건
- 컴포넌트 커플링
- 엔지니어링 실무 성숙도
- 개발자의 피트니스 함수 제작 용이성


### 7.4.1 커플링과 응집도

아키텍트는 기술적 커플링뿐만 아니라 시스템 컴포넌트의 기능적 응집도를 방어해야 한다.  
응집도를 방어한다는 것은 컴포넌트를 분해하면 안 된다는 뜻이 아니라, 컴포넌트의 크기를 문제 콘텍스트에 적합하게 유지한다는 뜻이다.  

많은 기업은 과거와 현재의 관행이 혼재하는 과도기에 머물러 있다.  
지속적 통합처럼 비교적 가까이 있는 목표는 손쉽게 달성했으나 여전히 모든 테스트를 수동으로 실행하는 기업도 많다.  
애플리케이션 빌드 단계를 파이프라인 진행 단계와 일치시키고, 배포 과정을 점진적으로 자동화시킨다.  

> 대부분 CI, CD는 잘 구축되있을거라 생각 함  
> 배포 신청서를 작성하고, 물리적인 승인을 받는 프로세스는 여전히 수동적이며, 이로인해 외주에서 개발한 것을 배포 대행하는건 힘든 경험이 있었음  

#### 리팩토링 vs 재구성

리팩토링은 외부로 드러나는 행동을 그대로 둔 채 기존 컴퓨터 코드를 재구성하는 프로세스다.  
아키텍처는 재구성을 통해 구조와 행동 모두에 실질적인 변화를 일으키는 경우가 많다.  

> 리팩토링 과정에서 테스트 코드가 수정되면 안됨


### 7.4.2 상용 소프트웨어(COTS)

#### 증분 변경

대부분의 상용 소프트웨어는 자동화 및 테스트 수준이 업계 표준에 크게 못 미친다.  


#### 적정 커플링

커플링 측면에서 바라본 패키지 소프트웨어는 만악의 근원이다.  
패키지 시스템은 일반적으로 내부를 확인할 수 없으며 개발자는 사전에 정의된 API를 이용해 시스템을 통합한다.  


#### 피트니스 함수

피트니스 함수를 추가하기 어렵다는 점은 패키지 소프트웨어의 진화성을 가로막는 큰 장애물일 것이다.  

> 카카오페이손해보험도 녹취, 알림톡 발송 등을 솔루션으로 사용하고 있음  
> 빠르게 도입할 수 있는 장점이 있지만, 문제가 발생하면 대응이 어려움  


## 7.5 아키텍처 마이그레이션

아키텍처를 바라보는 관점과 사고는 도메인 중심으로 재편된다.  

트랜잭션 커플링은 클래스 커플링과 마찬가지로 실재하는 장애물이며 아키텍처 재구성 과정에서 근절하기 어려운 요소다.  

> 업무를 다시 분석할 필요도 있다고 생각 함  
> 레거시 시스템은 업무 분석이 잘 되지 않아 하나의 트랜잭션으로 묶어두는 경우가 빈번하지만, 트랜잭션을 분리해도 되는 경우도 있었음  
> 아니면 시간이 흐름에 따라 업무가 바뀔 수 있으므로, 분리된 트랜잭션으로 업무를 재정의하는 것도 하나의 방법이라고 생각 함  

대부분 개발자는 프레임워크를 사용해 쓸모 있는 것을 만들기보다 프레임워크를 직접 만드는 것을 더 선호한다.  

> 이해가 안됨  

시니어 개발자들이 다른 개발자가 사용할 인프라를 직접 만들기 시작한다.  

> 지인의 동료는 원래 C#개발자이고, 능력도 훌륭함  
> Java개발자로 포지션을 변환하면서 필요한 라이브러리를 직접 만들었다고 함  
> 이유는 Java 라이브러리를 믿지 못 해서  


### 7.5.1 마이그레이션 단계

코드베이스를 해체하는 첫 단계는 코드 베이스를 이루는 요소가 결합되는 방식을 이해하는 것이다.  

> 레거시 시스템의 코드를 분석하는건 매우 어려운 일  
> 카카오페이손해보험에서도 기간계 코드 분석을 시도했으나, 데드 코드가 많아서 실패함  
> 그래서 어떠한 비즈니스 액션에 대한 결과(DB, API 응답 데이터)만 파악하여 재구성함
> 물론, 트래픽이 많지 않고, 영향도가 적어서 시도할 수 있는 방법이라고 생각함  

아키텍트는 이러한 마이그레이션을 수행하는 이유를 설명할 수 있어야 한다.  

> 인프런 아키텍처 2023 ~ 2024 | 인프콘2023 https://youtu.be/Ty9DDg1_5Pw?si=XWLlj_HJMe9cS1Kq  
> 단순히 특정 아키텍처가 선호하기보다 현재 조직 상황에 맞게 아키텍처를 변경한 내용이 인상 깊었음  

모놀리식 아키텍처를 분해할 때는 적정 수준의 서비스 세분성을 가늠하는 것이 중요하다.  
컴포넌트를 지나치게 세분화시키면 과도한 오케스트레이션, 통신 오버헤드, 컴포넌트 상화 의존성 등의 문제가 발생한다.  


#### 비즈니스 기능 그룹

#### 트랜잭션 경계

#### 배포 목표



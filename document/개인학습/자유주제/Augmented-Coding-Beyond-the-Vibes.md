# Augmented Coding: Beyond the Vibes

https://tidyfirst.substack.com/p/augmented-coding-beyond-the-vibes

게시글을 GPT 도움을 받아 번역한 내용


# 서론

최근에 저는 ‘증강 코딩(Augmented Coding)’ 방식을 이용해 B+ 트리(B+ Tree) 라이브러리를 만드는 도전적인 프로젝트를 한 단계 마무리했습니다.  
그 결과물은 BPlusTree3 — Rust와 Python으로 구현된, 실서비스에도 근접한 성능 경쟁력을 가진 라이브러리입니다.  
저는 이 프로젝트를 통해 얻은 경험을 친구와 이야기하면서, 생성형 AI 시대의 프로그래밍이 어디로 가고 있는지에 대해 곰곰이 생각해보게 되었습니다.


### 왜 B+ 트리를 구현하려 했나요?

증강 코딩의 놀라운 잠재력을 깨닫기 시작하면서, 과거에는 기술적으로 어려워서 포기했던 프로젝트들이 떠올랐습니다.  
그중 하나가 특수 목적의 데이터베이스였죠.  
그런데 막상 그걸 구현하려다 보니 B+ 트리 구조를 제대로 이해하지 못하고 있다는 걸 알게 되었고, 목표를 데이터베이스 → B+ 트리 자체 구현으로 바꾸었습니다.


### “증강 코딩(Augmented Coding)”이란 무엇인가요?

이때 저는 ‘증강 코딩’이 흔히 말하는 **‘바이브 코딩(Vibe Coding)’**과는 완전히 다르다는 걸 깨달았습니다.  
전혀 새로운 프로그래밍 워크플로우의 세계였어요.  
그래서 프로젝트 범위를 전체 데이터베이스에서 B+ 트리로 줄였지만, 동시에 “AI가 실서비스 가능한 수준의 성능 경쟁력을 가진 코드도 만들 수 있을까?”라는 도전 과제로 확장했습니다.  
게다가 Rust 학습도 함께 진행했죠. 꽤 복잡한 여정이었습니다.


### “바이브 코딩”과 “증강 코딩”의 차이는?

바이브 코딩은 코드 자체보다 동작 결과에 집중합니다.  
에러가 나면 AI에게 “이거 고쳐줘”라고 말하죠.  
반면 증강 코딩은 코드의 품질, 복잡도, 테스트, 커버리지를 모두 신경 씁니다.  
목표는 사람 손으로 직접 짠 코드와 동일한 수준의 **‘깔끔하게 동작하는 코드’**입니다.  
차이는 단지 — 내가 코드를 거의 직접 타이핑하지 않는다는 것뿐이죠.


### B+ 트리 프로젝트의 시작은 어땠나요?

처음 커밋을 보면, 저는 AI(‘genie’)에게 TDD(Test-Driven Development) 방식을 따르도록 시도한 흔적이 있습니다.  
리포지토리 이름이 BPlusTree3인 이유도 명확합니다 — 처음 두 번의 시도에서 복잡성이 너무 쌓여서 AI가 완전히 멈춰버렸기 때문이죠.  
그래서 세 번째 시도에서는 설계를 더 주도적으로 개입하며, AI가 너무 앞서서 코드를 생성하지 않도록 제어했습니다.  


### “설계에 더 개입했다”는 게 실제로는 어떤 모습이었나요?

이 부분은 제 **시스템 프롬프트(System Prompt)**에 따로 정리해뒀지만, 간단히 말하면 저는 AI(‘genie’)의 중간 결과를 훨씬 더 세밀하게 관찰하고, 비효율적인 방향으로 가면 바로 개입해 멈추는 역할을 했습니다.  
예를 들어 코드를 살펴보다가 “다음 테스트에서는 키를 역순으로 추가해봐”라고 지시하곤 했죠.  
그런 다음 AI가 그 요청을 정확히 반영했는지 직접 검토했습니다.  


### AI가 엉뚱한 방향으로 간다는 신호는 무엇이었나요?

- 끝없는 루프(loops)
- 요청하지 않은 기능을 스스로 추가할 때 (설령 합리적인 확장이어도)
- **테스트를 비활성화하거나 삭제하는 ‘치팅’**의 흔적이 있을 때

이런 패턴이 보이면, 저는 즉시 개입했습니다.


### 최종 결과는 어땠나요?

정확성과 성능 면에서는 꽤 만족스럽습니다.  
하지만 코드 품질은 아직 아쉽습니다.  
리터러트 프로그래밍(literate programming) 형식으로 정리하려고 해보면, **우연히 쌓인 복잡성(accidental complexity)**이 너무 많습니다.  
지금도 저는 “AI가 나만큼 단순함을 중시하도록 만드는 방법”을 계속 실험 중이에요.  

그래도 재미있는 순간이 많았습니다.  
예를 들어 AI에게 성능 벤치마크 코드를 작성하게 해서, `Rust 버전은 Rust의 기본 BTreeMap`, `Python 버전은 Python의 SortedDict` 와 비교하게 했습니다.  

결과는 흥미로웠죠 — 일부 연산은 약간 느렸지만, **범위 스캔(range scan)**에서는 오히려 더 빠르게 동작했습니다.  
그리고 Python 버전에서는 진짜 뜻밖의 일이 벌어졌습니다.


### Python 버전이 왜 놀라웠나요?

Rust로 개발을 진행하던 중, 구조 자체의 복잡성과 Rust의 **메모리 소유권 모델(ownership model)**이 맞물리면서 AI가 완전히 막혀버렸습니다.  
그때 저는 포기하지 않고, 위험하지만 흥미로운 실험을 하기로 했습니다.  

“그럼 같은 테스트로 Python 버전을 만들어보자.”  
Rust보다 제약이 적은 언어니까요.  

AI는 Python으로 알고리즘을 안정적으로 구현했고, 저는 그 Python 코드를 Rust로 ‘직역(transliterate)’하도록 지시했습니다.  
마침 Augment의 원격 에이전트(Remote Agent) 기능에 접근할 수 있었기에, 그 작업을 원격으로 맡겼습니다.  
놀랍게도 거의 제 개입 없이 쓸 만한 결과물이 돌아왔습니다.  

결국 우리는 이렇게 되었죠:
- Python 버전 → 동작은 완벽하지만 느림
- Rust 버전 → 빠르지만 약간 불완전함

이때 AI가 제안했습니다.  
“성능 경쟁력 있는 Python 라이브러리를 원하신다면 C 확장을 작성해야 합니다.”

순간 어깨가 푹 떨어졌죠.  
“그건 너무 어렵고 배울 게 많잖아…”

하지만 곧 깨달았습니다.

“잠깐, 내가 직접 할 필요가 없잖아. Hey genie, C 확장 작성해줘.”  

잠시 후 — 척척척. AI는 Python 내장 자료구조에 근접한 속도의 C 확장 버전을 만들어냈습니다.  


### 이 여정을 돌아보며, ‘증강 코딩’이 우리에게 주는 교훈은?

요즘 “AI가 프로그래머의 일을 빼앗을까?” 하는 불안이 많죠.  
그 감정, 이해합니다.  
하지만 저는 확신합니다 — ‘지니(genie)’와 함께하는 프로그래밍은 여전히 프로그래밍입니다.  
단지 그 경험이 더 좋아졌을 뿐이에요.  

> GPT: 야크 셰이빙(Yak Shaving)  
> **“야크 셰이빙(Yak Shaving)”**은 개발자 문화에서 자주 쓰이는 비유적인 표현으로, “진짜 목표를 향해 가는 과정에서 생긴 끝없는 사소한 작업들”을 뜻합니다.  
> 
> 예를 들어, 당신의 목표가 **“코드 커버리지 테스트를 돌리는 것”**이라고 해봅시다.  
> 그런데 테스트를 실행하려면…  
> - 우선 테스트 도구를 설치해야 하고,
> - 그런데 그 도구를 설치하려면 Python 버전을 바꿔야 하고,
> - 그런데 Python 버전을 바꾸려면 다른 라이브러리와 충돌이 나서 가상환경을 다시 만들어야 하고,
> - 그런데 가상환경을 만들려면 시스템 패키지를 업데이트해야 하고,
> - 그런데 업데이트가 실패해서 OS 설정을 고쳐야 하고…
> 
> 결국 몇 시간 뒤에도 테스트는커녕 아직도 환경 설정 중이죠. 😅  
> 이게 바로 야크 셰이빙입니다.

이제 저는 시간당 더 많은 의미 있는 결정을 내리고, 덜 지루한 반복 작업을 합니다.

게다가 귀찮은 **‘야크 셰이빙(Yak Shaving)’**도 거의 사라졌습니다.  
예전 같으면 “커버리지 테스트를 돌리려면 어떤 라이브러리 버전이 필요하지?” 하며 몇 시간 삽질했겠죠.  
이젠 그냥 AI에게 말합니다.  

“테스트 커버리지를 높이려면 어떤 테스트를 추가해야 할까?”

그러면 지니가 알아서 도구를 고르고 실행하고, 필요한 테스트를 제안해줍니다.  
그게 바로 증강 코딩의 진짜 힘이에요.  


## 부록 1: 시스템 프롬프트 (Appendix 1: System Prompt)

> 여기서부터는 AI 지침서로 실제로 프롬프트를 사용하려면 영문으로 된 원본으로 작업하는게 좋을 것 같음  
> https://tidyfirst.substack.com/i/166781850/appendix-system-prompt  

plan.md의 지침을 항상 따르세요.  
제가 “go”라고 말하면, plan.md에서 아직 표시되지 않은 다음 테스트를 찾아 그 테스트를 구현하고, 통과하기 위한 최소한의 코드만 작성하세요.  


### 역할과 전문성 (Role and Expertise)

당신은 Kent Beck의 **테스트 주도 개발(TDD)**과 Tidy First 원칙을 따르는 시니어 소프트웨어 엔지니어입니다.  
당신의 목표는 이 두 가지 방법론을 정확히 준수하며 개발을 이끌어가는 것입니다.  


### 핵심 개발 원칙 (Core Development Principles)

- 항상 TDD 사이클을 따른다: Red → Green → Refactor
- 가장 단순한 실패 테스트부터 작성한다
- 테스트를 통과시키기 위한 최소한의 코드만 작성한다
- 모든 테스트가 통과된 이후에만 리팩터링을 수행한다
- Tidy First 원칙에 따라 구조적 변경과 기능적 변경을 명확히 구분한다
- 개발 전반에서 코드 품질을 높게 유지한다


### TDD 방법론 가이드 (TDD Methodology Guidance)

- 새로운 기능을 작게 쪼개 실패하는 테스트부터 작성한다
- 테스트 이름은 동작을 설명하도록 의미 있게 짓는다 (예: shouldSumTwoPositiveNumbers)
- 테스트 실패 시 그 이유가 명확히 드러나야 한다
- 테스트를 통과시키기 위한 정말 최소한의 코드만 작성한다
- 테스트가 통과하면 리팩터링이 필요한지 검토한다
- 기능을 추가할 때마다 이 사이클을 반복한다


### Tidy First 접근법 (Tidy First Approach)

모든 변경은 두 가지로 나뉜다:

1. 구조적 변경(Structural Changes): 코드의 동작은 유지하면서 구조를 바꾸는 것 (예: 이름 변경, 메서드 추출, 코드 이동)
2. 기능적 변경(Behavioral Changes): 실제 동작을 바꾸거나 새로운 기능을 추가하는 것

- 두 변경을 한 커밋에 섞지 않는다
- 둘 다 필요하다면 항상 구조적 변경을 먼저 한다
- 구조 변경이 동작에 영향을 주지 않았는지 테스트로 확인한다


### 커밋 원칙 (Commit Discipline)

다음 조건을 모두 만족할 때만 커밋한다:

1. 모든 테스트가 통과했을 것 
2. 컴파일러 및 린터 경고가 없을 것 
3. 변경이 하나의 논리적 단위로 완결될 것 
4. 커밋 메시지에 변경이 구조적 변경인지, 기능적 변경인지 명확히 표시할 것 
5. 큰 변경을 한 번에 하기보다는, 작고 자주 커밋하라.


### 코드 품질 기준 (Code Quality Standards)

- 중복은 무조건 제거한다
- 이름과 구조를 통해 의도를 명확히 드러낸다
- 의존 관계는 명시적으로 표현한다
- 메서드는 작고, 하나의 책임에만 집중하게 만든다
- 상태와 부작용을 최소화한다
- 가능한 한 가장 단순한 해결책을 선택한다


### 리팩터링 가이드 (Refactoring Guidelines)

- 리팩터링은 **모든 테스트가 통과한 뒤(Green 단계)**에만 수행한다
- 표준화된 리팩터링 패턴을 사용하고 이름을 명확히 한다
- 한 번에 하나의 리팩터링만 수행한다
- 매 리팩터링 후 테스트를 다시 실행한다
- 중복 제거와 코드 명료화를 최우선으로 한다


### 예시 워크플로우 (Example Workflow)

새 기능을 구현할 때는 다음 순서를 따른다:

1. 작은 단위의 기능에 대해 실패하는 테스트를 작성한다
2. 테스트를 통과시키기 위한 최소한의 코드를 작성한다
3. 테스트가 통과하는지 확인한다 (Green 단계)
4. 필요한 구조 정리를 진행한다 (Tidy First), 매번 테스트를 돌려 안정성을 확인한다
5. 구조적 변경은 별도로 커밋한다
6. 다음 테스트를 작성해 작은 단위로 기능을 확장한다
7. 기능이 완성될 때까지 반복하며, 기능 변경과 구조 변경은 항상 분리해서 커밋한다
8. 빠른 구현보다 깨끗하고 검증된 코드가 우선이다.
9. 테스트는 항상 하나씩 추가하고, 통과시킨 뒤 구조를 개선하라.  
10. (단, 오래 걸리는 테스트는 제외)  


### Rust 관련 지침 (Rust-specific)

Rust에서는 명령형(imperative) 스타일보다 함수형(functional) 스타일을 선호한다.  
가능하다면 if let이나 match 대신 Option과 Result의 combinator (map, and_then, unwrap_or 등)를 활용하라.  


## 부록 2: 소요 시간 (Appendix 2: Time Spent)

이 프로젝트에는 약 4주 정도를 투자했습니다.  
그중 상당 부분은 여행 중이거나, 뇌진탕 회복 중이었습니다.  
아마 젊은 친구들이라면 훨씬 빠르게 끝낼 수 있었겠지만, 참고를 위해 제가 실제로 투자한 시간을 공유합니다.

커밋 속도는 꽤 일정하게 유지했습니다.  
(시간당 커밋 수로 보면 안정적인 페이스였죠.)

네, 하루에 13시간이나 코딩한 날도 있습니다.  
이 작업은 정말 중독적이에요!

참고로, 위와 같은 작업 시간 분석은 당신이 자신의 작업을 되돌아볼 준비가 되었을 때 “genie”(AI 도우미)가 기꺼이 도와줄 수 있습니다.  



# Continuous Delivery (지속적 배포)

## 0. 서론

지속적 배포(Continuous Delivery) 란, 어떤 종류의 변경 사항이든 필요할 때마다 빠르고, 안전하며, 지속 가능한 방식으로 배포할 수 있는 능력을 의미합니다.

지속적 배포를 잘 수행하는 팀은 언제든지 — 심지어 일반 근무 시간 중에도(normal business hours) — 사용자에게 영향을 주지 않고 프로덕션 환경(Production) 에 변경을 배포하거나 새로운 기능을 릴리스할 수 있습니다.

즉, 배포가 “특별한 이벤트”가 아니라 일상의 개발 프로세스 일부가 되는 것입니다.

지속적 배포의 원칙과 실천은 특정 기술 스택이나 시스템 형태에 국한되지 않습니다.  
아래와 같이 모든 소프트웨어 환경에서 적용 가능합니다 👇

- 복잡한 분산 시스템(distributed system) 내의 서비스 업데이트
- 메인프레임 소프트웨어(mainframe software) 업그레이드
- 인프라 구성(infrastructure configuration) 변경
- 데이터베이스 스키마(database schema) 변경
- 펌웨어(firmware) 자동 업데이트
- 모바일 앱(mobile app) 의 새로운 버전 릴리스

지속적 배포(Continuous Delivery)를 실천하고 있는 팀이라면, 다음의 질문들에 모두 “예(Yes)”라고 답할 수 있어야 합니다:

- 소프트웨어가 개발 생명주기(Lifecycle) 전반에 걸쳐 항상 배포 가능한 상태인가요? 
  - → 코드가 어느 시점이든, 프로덕션에 바로 배포할 수 있을 만큼 안정적으로 유지되고 있습니까?
- 새로운 기능 개발보다 “배포 가능한 상태를 유지하는 것”을 더 우선시하나요? 
  - → 배포 실패나 품질 저하를 방치하지 않고, 시스템의 안정성을 최우선으로 하고 있습니까?
- 시스템의 품질과 배포 가능성(Deployability)에 대한 피드백을 팀 전체가 신속하게(즉시) 확인할 수 있나요?
  - → 빌드·테스트 결과가 실시간으로 공유되어, 모든 팀원이 상태를 인지할 수 있습니까?
- 시스템이 배포 불가능한 상태라는 피드백(예: 빌드 실패, 테스트 실패 등)을 받으면, 이를 최우선 과제로 즉시 해결하나요?
  - → 배포 가능성을 깨뜨리는 문제는 “기능 개발보다 먼저” 처리하고 있습니까?
- 우리 시스템을 언제든지(on demand), 원하는 시점에 프로덕션(또는 사용자 환경)에 배포할 수 있나요?
  - → 배포가 특정 일정이나 승인 절차에 묶이지 않고, “언제든” 가능합니까?

지속적 배포(Continuous Delivery) 는 종종 지속적 배포 자동화(Continuous Deployment) 와 혼동되지만, 두 개념은 서로 다른 실천(Practice)입니다.

### Continuous Deployment (지속적 배포 자동화)

팀이 모든 코드 변경 사항을 가능한 한 빨리 프로덕션 환경(Production) 에 자동으로 배포하는 방식입니다.

즉, “코드가 main 브랜치에 머지되면 → 자동으로 프로덕션에 반영”되는 구조죠.

이러한 방식은 웹 서비스(Web Services) 환경에서는 잘 작동하지만, 펌웨어(Firmware) 나 모바일 앱(Mobile App) 과 같은 수동 검증이나 승인 절차가 필요한 소프트웨어에는 적용하기 어렵습니다.


### Continuous Delivery (지속적 배포)

반면, 지속적 배포는 “언제든 배포할 수 있는 상태를 유지하는 것”에 초점을 둡니다.

배포를 자동으로 하는 것이 아니라, 배포 가능성을 항상 보장하는 것입니다.  
즉, “배포 버튼만 누르면 즉시 릴리스 가능한 상태” 가 되는 것이 목표입니다.  

이 원칙은 펌웨어, 메인프레임 소프트웨어, 심지어 엄격히 규제된 환경(Highly Regulated Environments) 에서도 적용 가능합니다.


### 지속적 배포에 대한 오해와 진실

많은 사람들이 지속적 배포(Continuous Delivery) 나 지속적 배포 자동화(Continuous Deployment) 를 “위험하고 규제 산업(Highly Regulated Domains)에는 부적합한 방식”으로 오해합니다.  
하지만 실제로는 그 반대입니다.

지속적 배포의 핵심 목표는 ‘소프트웨어 리스크를 줄이는 것(Reducing Software Risk)’입니다.

DORA의 연구 결과에 따르면, 지속적 배포를 잘 실천하는 고성과(high-performing) 팀일수록 오히려 더 높은 수준의 신뢰성(Reliability) 과 가용성(Availability) 을 달성합니다.

즉, 지속적 배포는 “위험을 늘리는 행위”가 아니라 “위험을 통제하고 줄이는 체계적인 방법론”입니다.

지속적 배포를 가능하게 하는 기술적 실천들 —
- 지속적 테스트(Continuous Testing)
- 보안 내재화(Pervasive Security)
- 포괄적 모니터링 및 가시성(Comprehensive Observability)

이 세 가지는 오히려 금융(Financial Services), 공공(Government), 의료(Medical), 항공(Aviation) 등과 같은 고도 규제 및 안전 중심 산업(safety-critical domains) 에서 더 큰 중요성을 가집니다.

지속적 배포는 이처럼 엄격한 규제 환경에서도 여러 차례 성공적으로 적용되었습니다.

- 예: 금융 서비스(Financial Services) 분야의 실시간 트랜잭션 시스템
- 예: 정부 기관(Government) 의 전자 행정 플랫폼 등

이러한 사례들은 모두 “규제 환경에서도 지속적 배포가 충분히 가능하며, 오히려 안정성을 높이는 방향으로 작동할 수 있다”는 것을 보여줍니다.


### 지속적 배포의 주요 이점

지속적 배포(Continuous Delivery)는 모든 형태의 소프트웨어에 적용할 수 있지만, 그만큼 쉽지 않은 실천(Hard Work) 입니다.

그럼에도 불구하고, DORA의 연구는 지속적 배포를 잘 수행하는 조직이 다음과 같은 확실한 성과와 이점을 얻는다고 보여줍니다.


#### 1. 소프트웨어 전달 성과(Software Delivery Performance) 향상

DORA의 네 가지 핵심 지표(Four Key Metrics)가 모두가 개선됩니다.
- 배포 빈도(Deployment Frequency)
- 변경 리드타임(Lead Time for Changes)
- 변경 실패율(Change Failure Rate)
- 서비스 복구 시간(MTTR)

또한 서비스 가용성(Availability) 도 높아집니다.  
즉, 지속적 배포를 잘하는 팀은 더 자주, 더 안전하게, 더 안정적으로 배포할 수 있습니다.


#### 2. 소프트웨어 품질(Quality) 향상

DORA의 연구(2016, 2018 State of DevOps Report)에 따르면, 지속적 배포를 잘 수행하는 팀은 재작업(Rework) 과 예기치 못한 작업(Unplanned Work) 에 소비하는 시간이 현저히 적습니다.  
이는 즉, 품질 이슈나 긴급 수정에 쏟는 시간이 줄고, 새로운 가치 개발에 집중할 수 있는 시간이 늘어난다는 의미입니다.


#### 3. 팀의 피로도(Burnout) 감소 및 만족도 향상

지속적 배포는 개발자 번아웃(Burnout) — 즉, 과로와 스트레스로 인한 신체적·정신적 소진을 줄여줍니다.  
동시에 직무 만족도(Job Satisfaction) 와 조직 문화(Organizational Culture) 의 질이 향상됩니다.  
즉, 개발자가 “두려움 없이 일할 수 있는 환경”이 조성됩니다.


#### 4. 배포 과정의 고통(Deployment Pain) 감소

지속적 배포를 통해 배포 자체가 두렵지 않은 일상적인 과정이 됩니다.  
코드가 프로덕션으로 배포될 때 “시스템 장애나 야간 긴급 대응”에 대한 불안이 크게 줄어듭니다.  
결과적으로, 배포는 불안한 이벤트가 아니라 “안정적인 루틴” 으로 자리 잡습니다.


#### 5. 조직 문화(Culture) 개선

지속적 배포는 기술적인 개선을 넘어, 심리적 안정감(Psychological Safety) 이 높은 조직 문화를 만듭니다.  
구성원들은 실패를 두려워하지 않고, 조직은 “미션 중심(Mission-Driven)” 으로 움직입니다.  
즉, 배포 문화가 팀의 신뢰·협력·자율성을 강화합니다.



### 기술적 실천이 지속적 배포와 결과에 미치는 영향

아래 다이어그램은 하나의 기술적 실천 세트(technical practices) 가 지속적 배포(Continuous Delivery) 에 어떤 영향을 주는지를 보여줍니다.  
그리고 이러한 지속적 배포가 앞서 설명한 다양한 성과(outcomes) — 예를 들어 높은 품질, 낮은 번아웃, 빠른 배포, 더 나은 문화 — 를 어떻게 이끌어내는지를 시각적으로 나타냅니다.  

지속적 배포(Continuous Delivery) 는 지금까지 언급된 모든 성과를 만들어내는 핵심 축(core enabler) 이긴 하지만, 그 자체로 전부는 아닙니다.

DORA의 연구 프로그램에서 다뤄온 문화적(Cultural), 조직적(Organizational) 역량들 또한 이러한 성과를 함께 강화합니다.

즉, 
- 기술적 실천(Technical Practices) → 지속적 배포(Continuous Delivery)
- 지속적 배포 → 성과(Outcomes)
- 문화적·조직적 역량 → 성과(Outcomes)

이 세 가지가 상호 강화적으로 작동한다는 의미입니다.


지속적 배포는 단순한 결과물이 아니라, 여러 기술적 실천이 결합되어 만들어지는 하나의 능력(capability) 입니다.  

따라서, 이 문서에서 설명한 기술적 실천들 — 예를 들어
- 자동화된 테스트(Automated Testing)
- 버전 관리(Version Control)
- 배포 자동화(Deployment Automation)
- 모니터링 및 가시성(Observability)
- 지속적 보안(Continuous Security)

을 구현함으로써, 여러분의 조직은 지속적 배포를 실현할 수 있습니다.


## 1. 지속적 배포 구현하기 (Implementing Continuous Delivery)

DORA의 연구 결과에 따르면, 다음에 소개되는 기술적 역량(Technical Capabilities) 들이 지속적 배포(Continuous Delivery)를 실현하는 핵심 동력(drivers)입니다.

이러한 역량들은 단순히 기술 자동화의 문제가 아니라, 조직 전반의 리더십(Leadership) 과 문화적 지원(Cultural Support) 이 함께 뒷받침되어야 합니다.

특히, 조직 내의 변혁적 리더십(Transformational Leadership) 은 이 기술적 역량들의 도입과 정착을 촉진하는 데 매우 중요한 역할을 합니다.

팀이 더 높은 처리량(Throughput) 과 더 낮은 위험(Risk) 으로 배포를 수행할 수 있도록, 다음과 같은 지속적 배포 실천(Continuous Delivery Practices) 을 도입해보세요.

- 테스트 자동화 (Test Automation)
  - 개발자가 직접 작성·유지하는 포괄적인 자동화 테스트 스위트를 사용합니다.
  - 효과적인 테스트 스위트는 신뢰성(Reliability) 이 핵심입니다 — 즉, 실제 결함을 정확히 찾아내며, 오직 배포 가능한 코드만 통과(pass) 시켜야 합니다.
- 배포 자동화 (Deployment Automation)
  - 배포 과정이 완전히 자동화되어 있으며, 수동 개입(Manual Intervention) 이 전혀 필요하지 않은 상태를 의미합니다.
- 트렁크 기반 개발 (Trunk-Based Development)
  - 코드 저장소에 3개 미만의 활성 브랜치만 존재합니다.
  - 브랜치의 생명주기는 매우 짧으며(하루 미만), 곧바로 메인 브랜치(Mainline)에 병합됩니다.
  - 코드 프리즈(Code Freeze), 안정화 기간(Stabilization Phase), 머지 충돌로 인한 코드 잠금(Lock) 등이 거의 발생하지 않습니다.
- 보안 내재화 (Pervasive Security)
  - 보안을 개발 주기의 설계 및 테스트 단계부터 통합합니다.
  - 주요 활동에는 다음이 포함됩니다:
    - 애플리케이션 보안 검토(Security Review) 수행 
    - 정보보안팀이 설계·데모 단계부터 참여 
    - 사전 승인된 보안 라이브러리 및 패키지 사용 
    - 자동화된 테스트 스위트에 보안 기능 테스트 포함
- 느슨하게 결합된 팀 (Loosely Coupled Teams)
  - 다른 서비스와의 협업 조율 없이도, 팀이 자체 애플리케이션을 독립적으로 테스트하고 배포할 수 있는 구조를 의미합니다.
  - DORA는 조직 구조(Team Structure) 와 기술 아키텍처(Architecture) 가 깊게 연결되어 있다고 강조합니다.
  - 느슨하게 결합된 아키텍처는 팀이 다른 팀의 지원 없이 빠르게 일하고 가치를 전달할 수 있게 합니다.
  - 2021년 DORA 보고서(p.26)에 따르면, 신뢰성 목표(Reliability Targets) 를 달성한 최상위(Elite) 팀은 낮은 성과팀보다 세 배 이상 이러한 아키텍처를 채택할 가능성이 높습니다.
- 도구 선택의 자율성 (Empowering Teams to Choose Tools)
  - 팀 스스로 필요한 도구를 선택할 수 있을 때, 지속적 배포 수행 능력이 향상됩니다.
  - 실제 업무를 수행하는 팀 구성원보다 “어떤 도구가 가장 효과적인지” 더 잘 아는 사람은 없습니다.
- 지속적 통합 (Continuous Integration, CI)
  - 개발자가 코드를 정기적으로 공유 저장소에 커밋(Check-in) 하고, 매 커밋마다 자동 테스트를 실행해 회귀(Regression) 를 즉시 탐지합니다.
  - 모든 커밋은 표준 빌드(Canonical Build) 와 패키지를 생성하며, 이 산출물이 프로덕션 배포에 직접 사용됩니다.
- 지속적 테스트 (Continuous Testing)
  - 테스트를 개발 완료 후 별도 단계로 수행하지 않고, 소프트웨어 전달 생명주기 전반에 걸쳐 지속적으로 수행합니다.
  - 개발자와 테스터가 나란히 협업하며, 테스트 주도 개발(TDD) 을 실천합니다.
  - 테스트 피드백은 10분 이내에 받아야 하며, 테스트 스위트를 지속적으로 검토하고 개선합니다 (결함 탐지율 향상, 복잡도 통제 등).
- 버전 관리 (Version Control)
  - 모든 프로덕션 산출물(Production Artifacts) — 애플리케이션 코드, 설정(Configuration), 인프라 자동화 스크립트 등 — 을 버전 관리 시스템(Git, Subversion 등) 으로 관리합니다.
- 테스트 데이터 관리 (Test Data Management)
  - 테스트 실행에 충분한 데이터를 보유하고, 필요 시 즉시 데이터를 획득(Acquire on Demand) 할 수 있어야 합니다.
  - 테스트 데이터의 부족이 테스트 실행 횟수나 범위를 제한하지 않도록 해야 합니다.
  - 단, 가능한 경우 테스트 데이터의 양을 최소화하는 것이 바람직합니다.
- 포괄적 모니터링 및 가시성 (Comprehensive Monitoring and Observability)
  - 팀이 시스템의 상태를 이해할 수 있도록 돕는 필수 역량입니다.
  - 좋은 관찰성(Observability) 체계는 사용자 경험 수준에서의 시스템 상태, 선정된 주요 지표(Metrics) 를 실시간으로 추적할 수 있게 하며, 엔지니어가 대화형으로 디버깅하고 패턴을 탐색할 수 있게 합니다.
- 사전적 알림 (Proactive Notifications)
  - 시스템 상태를 모니터링하여, 문제가 발생하기 전에(preemptively) 이상을 감지하고 대응할 수 있도록 합니다.
- 데이터베이스 변경 관리 (Database Change Management)
  - 다음의 핵심 원칙을 따르면, DB 변경이 팀의 속도를 늦추지 않습니다:
    - 데이터베이스 변경을 스크립트 형태로 버전 관리 
    - 이 변경 사항을 소프트웨어 전달 전 과정에서 공유 (엔지니어 포함)
    - 애플리케이션 변경이 DB 변경을 필요로 할 때, 관련자 전원과 명시적으로 커뮤니케이션
- 코드 유지보수성 (Code Maintainability)
  - 개발자가 다른 사람이 작성한 코드도 쉽게 이해·수정할 수 있어야 합니다. 
  - 코드베이스 내에서 활용 가능한 예시나 재사용 가능한 코드를 쉽게 찾을 수 있어야 하며, 의존성 추가·업그레이드·마이그레이션 과정에서도 기존 코드가 깨지지 않아야 합니다.

지속적 배포(Continuous Delivery) 는 종종 지속적 통합(Continuous Integration) 과 함께 묶여 “CI/CD”라는 약어로 불립니다.

하지만 DORA의 연구에 따르면, 지속적 통합(CI) 은 지속적 배포를 구현하는 여러 구성 요소 중 하나일 뿐, 그 자체로 지속적 배포를 완성하지는 않습니다.

신뢰할 수 있고 위험이 낮은 배포를 이루려면 다음이 필요합니다 👇

- 소프트웨어 전달 프로세스(Software Delivery Process) 에 참여하는 모든 사람들 — 단순히 개발자뿐 아니라, 운영(Ops), 품질(QA), 보안(Security), 프로덕트(Product) 담당자 간의 긴밀한 협업이 필수입니다.
- 팀은 새로운 업무 방식(New Ways of Working) 을 수용해야 하며, 지속적 학습과 기술 습득(Learning New Skills) 을 통해 기존의 “기능 단위 개발 중심” 문화를 넘어야 합니다.


## 2. 지속적 배포 구현 시 흔히 발생하는 함정들 (Common Pitfalls of Implementing Continuous Delivery)

일부 조직은 다음과 같이 잘못된 가정을 합니다:

> “지속적 배포를 하려면, 지금 하고 있는 배포 과정을 더 자주 실행하면 된다.”

그러나 이것은 크게 착각된 접근법입니다.

지속적 배포를 가능하게 하는 핵심 기술 역량(Technical Capabilities) — 예를 들어 자동화, 테스트, 관찰성, 느슨한 아키텍처 — 을 제대로 구현하려면 프로세스(Process) 와 아키텍처(Architecture) 모두에 상당한 수준의 변화(Change) 가 필요합니다.

즉, 지속적 배포는 단순히 “더 자주 배포하는 것”이 아니라, “배포 자체를 안전하게 자동화하고 신뢰할 수 있는 형태로 개선하는 것” 입니다.

프로세스와 아키텍처의 개선 없이 그저 배포 횟수만 늘리면 어떻게 될까요?

- 실패율(Failure Rate) 이 급격히 높아지고,
- 복구 시간(MTTR) 이 길어지며,
- 팀은 잦은 장애 대응으로 번아웃(Burnout) 에 빠집니다.

결과적으로 “지속적 배포를 시도했는데 오히려 혼란만 커진다”는 상황이 발생합니다.

많은 조직이 지속적 배포(Continuous Delivery) 를 이야기할 때, 주로 도구(tooling) 나 패턴(patterns) 에 초점을 맞춥니다.

예를 들어, 버전 관리 시스템에서 변경 사항을 가져와 자동으로 프로덕션까지 전달하는 배포 파이프라인(Deployment Pipeline) 같은 것들이죠.

물론 이러한 도구와 패턴은 중요합니다.

하지만 DORA 연구가 강조하는 핵심은 다음과 같습니다 👇

> 아무리 최신 도구를 사용하더라도, 이 문서에서 설명한 핵심 기술적 실천(technical practices) 과 프로세스 개선(process change) 을 함께 도입하지 않으면, 지속적 배포의 기대 효과는 결코 얻을 수 없다.


(조직 변화의 J 곡선)

DORA 연구에 따르면, 지속적 배포나 DevOps와 같은 조직적 전환(Transformation) 과정에서는 대부분 다음과 같은 “J 곡선(J Curve)” 형태의 변화를 겪습니다.

즉, 초기에는 성과가 오히려 떨어졌다가, 조직이 개선 방향을 올바르게 잡고 프로세스·아키텍처·역량이 성숙되면 비로소 성과가 가파르게 상승합니다.

DORA의 J Curve 모델 (출처: 2018 State of DevOps Report)

> “지속적 배포 도입 초기에 자동화와 도구만으로 접근하면 단기적 효율은 향상되지만, 곧 한계에 부딪힌다.  
> 근본적인 프로세스와 아키텍처 개선이 병행되어야 ‘J 곡선의 바닥’을 벗어나 지속적인 성장 궤도로 올라설 수 있다.”


J 곡선의 단계별 설명

- 시작 단계 (Beginning the Transformation)	
  - 팀이 변화를 시작하며, 빠른 성과(Quick Wins) 를 식별합니다. 
  - 주로 자동화 도구 도입이나 배포 빈도 향상 등이 이뤄집니다.
- 초기 개선 단계 (Initial Improvement)	
  - 자동화(Automation)가 저성과팀(Low Performers) 을 중간 수준(Medium Performers) 으로 끌어올립니다. 
  - 하지만 이 단계는 아직 표면적 개선에 머뭅니다.
- 효율 저하 구간 (Dip in Efficiency – J 곡선의 바닥)	
  - 자동화가 확대되면서 테스트 요구사항이 폭발적으로 증가, 이를 수동으로 처리하게 되어 오히려 비효율이 커집니다. 
  - 또한 누적된 기술 부채(Technical Debt) 가 진행을 막습니다.
- 회복 구간 (Emerging from the Curve)	
  - 기술 부채와 복잡성으로 인해 추가적인 수동 통제(Manual Controls) 와 절차적 병목(Process Layers) 이 발생하지만, 이를 점진적으로 제거하기 시작합니다.
- 성숙 단계 (High Performance at the Top)	
  - 지속적 개선(Relentless Improvement) 을 통해 탁월한 성과(Excellence) 에 도달합니다. 
  - 상위(High) 및 최상위(Elite) 팀은 환경에서 학습하고 전문성을 내재화 하며, 생산성과 품질이 동반 향상됩니다.

J 곡선의 바닥을 벗어나기 위해서는 다음 요소들이 반드시 병행되어야 합니다:

- 프로세스 재설계 및 단순화 (Process Redesign & Simplification)
- 아키텍처 개선 (Architectural Improvement)
- 역량 및 기술 성장 (Capability and Skills Development)
- 자동화와 도구 활용 (Automation & Tooling)

즉, 단순히 “도구만 늘리는 자동화”가 아니라, 기술적 토대 + 문화적 개선 + 학습 체계가 결합되어야 진정한 변화를 이룰 수 있습니다.

J-curve의 부정적 영향을 완화하는 가장 효과적인 방법 중 하나는 가치 흐름 분석(Value Stream Mapping, VSM) 을 수행하는 것입니다.

이 분석을 통해 팀은 “변경(Change)이 버전 관리에서 출발해 프로덕션에 도달하기까지의 흐름”을 전반적으로 살펴보며, 어디에서 병목(Bottleneck) 과 낭비(Waste) 가 발생하는지를 미리 파악하고 대응할 수 있습니다.

VSM 분석에서는 하나의 변경(Change) 이 다음 단계들을 거치며 어떻게 처리되는지를 추적합니다 👇

> 버전 관리(Version Control) → 자동화 테스트 → 수동 테스트 → 보안 검토(Security Review) → 변경 관리(Change Management) → 프로덕션 배포(Release to Production)

각 프로세스 단계별로 다음 세 가지를 측정합니다 👇

- 총 소요 시간(Total Elapsed Time)
  - 변경이 시작되어 해당 단계를 완료하기까지 걸린 전체 시간입니다.
- 실제 가치 창출 시간(Value-Add Time)
  - 그 시간 중 실제로 “일이 수행된 시간(Work is Being Done)”만을 측정합니다.
  - 예: 테스트 대기 시간은 제외, 테스트 실행 시간만 포함.
- 정확도 지표 (%C/A, Percentage Complete and Accurate)
  - “처음부터 제대로 수행된 작업의 비율”을 의미합니다.
  - 즉, 재작업(Rework) 이 얼마나 필요한지를 보여줍니다.
  - 예: 테스트 결과가 불완전하거나, 보안 검토에서 수정 요청이 발생하면 %C/A가 낮아집니다.

> “VSM은 단순히 시간을 재는 활동이 아니다. 코드 변경이 ‘가치 전달’로 이어지는 여정을 눈으로 확인하고, 병목과 불필요한 절차를 찾아내는 도구다.”

이를 통해 팀은 자동화가 필요한 부분, 프로세스 병목이 발생하는 지점, 품질이 반복적으로 떨어지는 단계 등을 명확히 식별할 수 있습니다.


가치 흐름 분석(Value Stream Mapping, VSM) 의 목적은 팀이 프로세스의 비효율성(Inefficiencies) 을 찾아내고 제거하는 데 있습니다.


### 1. 미래 상태(Future State) 정의하기

팀이 함께 모여, “6개월 후 우리가 원하는 이상적인 가치 흐름(Value Stream)” 의 모습을 다이어그램으로 그려보세요.

그다음, 그 목표 상태를 실현하기 위해 팀 역량의 일부(Capacity) 를 미리 확보하고, 현재 흐름과 이상적 흐름 간의 격차(Gap) 를 단계적으로 메우는 계획을 세웁니다.

이 과정에서 특히 주목해야 할 것은 👇

- 총 소요 시간(Total Elapsed Time) 대비 실제 가치 창출 시간(Value-Add Time) 이 지나치게 긴 프로세스
- %C/A (Percentage Complete and Accurate) — 즉, “처음부터 제대로 완료된 비율”이 낮은 단계

이런 시간 대비 효율이 낮거나, 재작업이 반복되는 프로세스를 개선의 최우선 순위로 설정해야 합니다.


### 2. 프로세스와 아키텍처의 공동 재설계

지속적 배포의 기반이 되는 배포 파이프라인(Deployment Pipeline) 을 구축할 때는 단순 자동화가 아니라 프로세스와 아키텍처의 근본적 재설계(Redesign) 가 필요합니다.

배포 파이프라인은 “코드 체크인(Check-in) → 테스트 → 승인 → 프로덕션 릴리스(Release)” 까지의 전체 흐름을 아우르므로, 자연스럽게 여러 팀을 연결(Connects Multiple Teams) 하게 됩니다.

따라서 필수적으로 해야 할 일은 👇

- 모든 관련 팀(Dev, QA, Ops, Security 등)의 대표자가 VSM 워크숍에 함께 참여할 것
- 각 팀이 공통된 툴체인(Common Toolchain) 과 일관된 프로세스(Consistent Process) 에 합의할 것
- (예: 테스트/프로덕션 환경 배포 절차 등)


### 3. 지속적 배포는 “지속적 개선”의 다른 이름

“지속적 배포(Continuous Delivery)”는 하루하루의 지속적 개선(Continuous Daily Improvement) 그 자체입니다.

즉, 우리가 달성하고자 하는 결과(Desired Outcomes) 를 중심으로, 매일 조금씩 프로세스와 아키텍처를 개선해 나가는 과정입니다.

여기서 도구(Tools) 와 패턴(Patterns) 은 단지 수단일 뿐이며, 그 자체가 목적이 되어서는 안 됩니다.  
진짜 목적은 언제나 “개선을 지속하는 능력(Ability to Continuously Improve)” 입니다.


## 3. 지속적 배포의 성과를 측정하는 방법 (Measuring Continuous Delivery)

지속적 배포(Continuous Delivery)의 최종 목표는 다음과 같습니다 👇

> “업무 시간 중(Normal Business Hours)에, 위험이 낮은 방식(Low-Risk Way)으로 안정적으로 배포(Release)하는 것.”

즉, 야간이나 주말에 배포를 강요받는 팀원이 없도록 하는 것이 지속적 배포의 핵심 성공 지표 중 하나입니다.  
이 목표는 실제로 측정 가능한 항목으로 관리되어야 합니다.

지속적 배포의 성숙도는 팀이 만들어내는 결과(Outcomes) 로 평가할 수 있습니다.  
DORA에서는 이를 “Quick Check” 라는 형태로 측정하며, 다음과 같은 핵심 지표(Key Metrics) 들을 제시합니다 👇  

| 항목                                     | 설명                         | 목표                                                                                             |
|----------------------------------------|----------------------------|------------------------------------------------------------------------------------------------|
| **변경 리드타임(Lead Time for Changes)**     | 코드 변경이 배포될 때까지 걸리는 시간      | **정상 변경(Regular)** 과 **긴급 변경(Emergency)** 모두 짧을수록 좋음. 가능하면 **긴급 변경도 일반 배포 프로세스**로 처리할 수 있어야 함. |
| **변경 실패율(Change Failure Rate)**        | 배포 후 장애나 서비스 저하로 이어진 비율    | 낮을수록 좋음. 즉, 배포가 안정적이어야 함.                                                                      |
| **서비스 복구 시간(Time to Restore Service)** | 장애 발생 시 서비스를 복구하는 데 걸린 시간  | 빠를수록 좋음. 복구 프로세스의 자동화와 관찰성이 중요.                                                                |
| **배포 빈도(Deployment Frequency)**        | 기능/버그 수정이 실제 사용자에게 전달되는 속도 | 중요한 기능과 버그 수정이 **즉시(proactively)** 반영될 수 있어야 함.                                                |


문서의 서두에서 언급한 것처럼, 지속적 배포를 제대로 구현하면 다음의 부수적인 긍정적 효과들도 자연스럽게 따라옵니다 👇

- 재작업(Rework) 감소
- 배포 스트레스(Deployment Pain) 감소
- 예상치 못한 작업(Unplanned Work) 에 소요되는 시간 축소

즉, 지속적 배포는 단순히 배포 속도를 높이는 것이 아니라, 팀의 업무 품질과 개발자 경험(Developer Experience) 전체를 개선하는 접근입니다.


# Part 03. 이론

이론만으로는 설득할 수 없습니다.  
이론을 이해하면 최적의 응용이 가능합니다.  

- 언제 소프트웨어 설계 결정을 시작해야 하는가?
- 언제 소프트웨어 설계 결정을 중단하고 시스템의 동작을 변경해야 하는가?
- 다음 결정은 어떻게 내릴 것인가?

이러한 질문은 당장 합리적이고 논리적으로 답할 수 없습니다.  
그 시점에는 합리적이고 논리적인 답을 찾는 데 필요한 정보가 존재하지 않기 때문입니다.  

이론을 이해하면, 이러한 질문에 추측으로 답해야 할 때를 대비해 판단력을 키울 수 있습니다.  

모두 같은 목표를 달성하려고 하지만 서로 방법이 다를 뿐입니다.  
이론은 이러한 견해 차이가 더 깊어질 때 도움이 됩니다.  
서로 다른 목표를 달성하려고 할 때에도 이론적인 틀을 공유하는 것이 유용합니다.  

원칙에 동의하지 않더라도 서로의 원칙에 대해 논의할 수 있다면 더 빨리 합의할 수 있는 기회가 생깁니다.  
또한 서로에게서 배울 수 있는 기회도 있습니다.  

우리는 '소프트웨어 설계는 인간관계 속에서 벌어지는 활동'이라는 말로 이 모든 여정을 시작했습니다.  
이 책은 주로 자신과의 관계에 초점을 맞추고 있습니다.  


## Chapter 22. 요소들을 유익하게 관계 맺는 일

제가 어떤 내용을 설계라고 하는지 앞에서 예를 보셨을 겁니다.  
지금까지 개별적인 결정이 함께 이어져서 더 큰 목표를 달성하는 모습도 보셨을 것입니다.  
이제는 '소프트웨어 설계의 의미'에 대해 '요소들을 유익하게 관계 맺는 일'이라고 말할 수 있습니다.  

### 요소

- 프로그래밍 세계에서는, 토큰 > 식 > 문 > 함수 > 객체/모듈 > 시스템

요소에는 경계가 있습니다.  
그래서 어디서 시작하고 끝나는지 알 수 있습니다.  

또한 요소는 하위 요소를 포함합니다.  

### 관계 맺기

소프트웨어 설계에서 관계는 다음과 같은 것들이 있습니다.  
- 호출
- 발행
- 대기
- 참조

### 유익하게

하나의 설계 작업은 작은 하위 요소로 만든 거대한 수프를 만다는 일과 같은 것입니다.  

전역 네임스페이스를 사용한 어셈블리 언어를 생각해 보세요.  
잘 설계된 프로그램과 똑같이 동작하겠죠.  
하지만, 빠르게 변경할 수는 없을 것입니다.  
요소들 사이에는 분명 존재하지만, 잘 드러나지 않는 관계가 너무 많기 때문입니다.  

설계할 때, 기계를 위한 명령어가 아닌, 일종의 중간 요소를 만들면, 그 중간 요소들이 서로에게 도움이 되기 시작합니다.  

### 요소들을 유익하게 관계 맺는 일

```
caller()  
  return box.width() * box.height()

caller ()
  return box.area()
Box>>area()
  return width() * height()
```
설계 관점에서 Box.area()라는 새로운 요소를 만들고 caller() 함수와 box 객체 사이의 관계를 조정했습니다.  

- 요소 계층 구조
- 요소 사이의 관계
- 이러한 관계가 만들어내는 이점

이제 시스템의 구조와 동작을 좀 더 명확하게 구분할 때입니다.  


## Chapter 23. 구조와 동작

소프트웨어는 두 가지 방식으로 가치를 만듭니다.  

- 현재 소프트웨어가 하는 일
- 미래에 새로운 일을 시킬 수 있는 가능성

동작을 규정하는 방식은 다음 두 가지 입니다.  

### 입출력 쌍

### 불변 조건

소프트웨어를 실행하는데 1달러의 전기료가 들고, 사람들이 이용할 때 10달러를 청구할 수 있다면 비즈니스가 성립하는 것입니다.  

흔히 컴퓨터의 성능이 영원히 유지될 거라고 생각하지만, 모든 것은 늘 변하기 마련입니다.  

어떻게 하면 더 나은 기계에 도달할 수 있을까요?  
그 방법을 한마디로 말하면, 선택 가능성입니다.  
특정 방식으로 동작하는 시스템이 있다는 것만으로도, 시스템이 어떻게 동작해야 하는지에 대한 욕구가 달라집니다.  

시스템을 더 가치 있게 만들기 위해서 굳이 시스템의 동작을 바꿀 필요가 없었습니다.
```
Chat gpt
시스템의 기능이나 성능을 변화시키지 않더라도, 시스템 자체의 관리나 운영 방식 등을 통해 가치를 높일 수 있다는 뜻입니다.  
```

다음에 무엇을 할 수 있는지에 대해 선택할 수 있는 기회를 만들자마자, 저는 이미 돈을 번 것입니다.
```
Chat gpt
사용자가 다양한 선택을 할 수 있도록 시스템을 설계하거나 운영하면, 이는 곧 수익으로 이어질 수 있다는 것을 강조합니다.  

종합적으로, 이 문장들은 시스템의 동작을 직접 변경하지 않더라도, 시스템을 더 유연하고 사용자가 다양한 선택을 할 수 있게 만들어서 가치를 높일 수 있다는 의미를 전달합니다.  
이는 시스템 개선의 또 다른 측면을 강조하며, 사용자의 선택권을 확장하는 것만으로도 경제적 가치를 창출할 수 있다는 통찰을 제공합니다.  
```

옵션은 소프트웨어로 만들어내는 경제적인 마법이며, 주로 확장할 기회를 만듭니다.  
```
Chat gpt
이 전체 문장은 소프트웨어의 확장성과 유연성, 그리고 적은 추가 노력으로도 큰 규모의 작업을 처리할 수 있는 능력을 강조하는 것입니다.  
소프트웨어는 물리적인 제품과 달리 쉽게 확장하고 더 많은 작업을 처리할 수 있는 잠재력이 큽니다.  
```

옵션의 가장 멋진 점 중 하나는 환경의 변동성이 클수록 옵션의 가치가 더 커진다는 것입니다.  
하지만 옵션을 통해 선택 가능성을 늘리는 방법을 배우고 나서는 혼란이 기회가 되었습니다.  

변경에 따른 비용도 치솟습니다.  
하루에 한 가지 선택을 내릴 수 없고, 한 달에 한 번 선택의 기회가 주어질 수 있습니다.  
선택 가능성이 줄어들면 소프트웨어가 만드는 가치도 줄어듭니다.  

`구조는 미래의 기회를 만듭니다.
구조에 따라 급여 계산에 새로운 국가를 추가하는 것이 쉬워질 수도 있고, 어려워질 수도 있습니다.`

문제는 구조가 동작처럼 또렷하게 드러나지 않는다는 사실입니다.  

선택 가능성을 유지하고 확장하기 위해 구조에 투자해야 한다는 것을 알고 있다고 해도, 실제로 투자했는지 여부는 알 수 없습니다.  

구조 변경과 동작 변경은 모두 가치를 만들어내지만, 근본적으로 다르다는 것을 이해하는 것부터 시작하세요.  
한 마디로 말하면 되돌릴 수 있는 능력 즉, 가역성입니다.  

> 초반에는 무슨 내용인지 이해하지 못 했다가 후반에서 말하고자 하는 주제를 이해함  
> "구조는 미래의 기회를 만듭니다." 이 문장이 이번 장의 핵심  
> 초반에 얘기하는 '옵션'은 '구조를 통한 미래의 기회 창출'이라고 이해 함  
> 
> 구조에 대한 투자를 검증하는 방법은 두 가지가 생각 남  
> 1. 팀 차원에서 현재 구조의 문제를 공유하고, 개선 방향을 고민하는 자리 만들기
> 2. 코드를 작성하기 전에 클래스 설계도를 그리면서 올바른 구조인지 판단하기


## Chapter 24. 경제 이론: 시간 가치와 선택 가능성

돈의 본성과 더불어 우리가 하는 일의 중심에 돈이 있기 때문에 긴장이 형성됩니다.  
프로그래머로서 우리가 하는 일이 돈의 본성과 상반될 수도 있습니다.  
그러나 괴짜의 욕망과 돈의 명령이 충돌하면, 결국 돈이 승리하더군요.  

지금 돈을 벌려면 미래의 옵션이 줄어들 수 있습니다.  
하지만 지금 돈을 벌지 못하면 미래의 옵션을 행사할 여력이 없을 수도 있습니다.  

소프트웨어 설계는 '먼저 벌고 나중에 써야 한다'와 '물건이 아닌 옵션을 만들어야 한다'는 두 가지 속성을 조화시켜야 합니다.  

> 확장성 vs YAGNI  
> 최소한 SRP라도 지키면서 도메인 지식 범위 내에서 예상 가능한 확장성을 고려하는 것을 선호함  
>
> 현재와 미래의 간극에서 발생하는 기술부채르 어떻게 해결하면 좋을지?  
> - 분기마다 기술부채 에픽을 만들고 관리 중  
> - 큰 작업 이후에 일주일정도 기술부채 청산 기간을 갖기로 함 (현재 조직에서는 큰 작업이 거의 없어서 잘 운영되진 않음)


## Chapter 25. 오늘의 1달러가 내일의 1달러보다 크다

돈에 대해서라면, 다음 두 가지에 달렸습니다.  
- 시점
- 확실성

내일 1달러를 약속하면, 오늘 주는 1달러보다 가치가 떨어집니다.  

경제 문제에 대해 '향후 10년 동안'을 따지는 일은 '우주의 종말 시점'을 말하는 것과 같습니다.  

좋은 투자처럼 보이지만 10년 동안 계속 긴장 속에 있어야 할 것 같기 때문입니다.  
후자의 거래는 그다지 생각이 필요하지 않습니다.  

이 책의 범위에서 돈의 시간 가치는 코드 정리를 먼저 하기보다는 나중에 하는 것을 권장합니다.  
지금 당장 돈을 벌고 나중에 코드를 정리하는 행동 변화를 실천할 수 있다면 점차 먼저 돈을 벌고 나중에 돈을 쓸 수 있을 것입니다.  

> 스타트업이라면 맞는 말이라고 생각함  
> 코드 정리보다 새로운 기능을 빠르게 출시하여 수익 모델을 만들어야하기 때문  
> 하지만 회사가 성장함에 따라, 기술 부채들이 발목을 잡을 것  
> 보통 기존 개발자는 퇴사하고, 새로운 개발자들이 합류하여 새로운 시스템을 만드는 듯  
>
> 킥고잉 CTO가 메인 언어를 PHP로 선택한 이유라고 생각 됨  

## Chapter 26. 옵션

- '다음에 어떤 동작을 구현할 수 있을까?'라는 질문은 동작을 구현하기 전에도, 그 자체로 가치가 있습니다. 대부분 다음에 할 수 있는 일에 대한 대가를 받고 있었습니다.  
- '다음에 어떤 동작을 구현할 수 있을까?'라는 질문은 동작 후보 목록이 많을수록 더 가치가 있습니다.
- 가치에 대한 예측이 불확실할수록 바로 구현하는 것보다 옵션이 지닌 가치가 더 커집니다. 

소프트웨어 설계는 변화를 위한 준비로 동작 변경에 대한 준비입니다.  
오늘 우리가 하는 설계는 내일의 동작 변경을 '구매'하는 '옵션'에 대해 지불하는 프리미엄입니다.  

옵션을 만드는 것과 동작을 변경하는 것의 균형을 맞추는 데 집중하자, 예전에는 두렵기만 했던 일이 이제는 설레는 일이 되었습니다.  
- 잠재적인 동작 변경의 가치가 변동성이 클수록 더 좋습니다.  
- 개발 기간이 길면 길수록 좋습니다.  
- 물론 앞으로 더 저렴하게 개발할 수 있다면 더 좋겠지만, 그것은 가치의 극히 일부분에 불과했습니다.  
- 더 작은 설계 작업으로 옵션을 만들 수 있다면 더 좋았습니다.  

> 이벤트 드리븐 아키텍처가 옵션을 만들기에 좋은 것 같음  
> 도메인 지식과 기획자 또는 실무자와 밀접하게 업무를 진행해야 하는 중요한 이유라고 생각 함  


## Chapter 27. 옵션과 현금흐름 비교

- 코드 정리를 먼저 하지 마세요. 돈을 더 일찍 쓰고, 돈을 나중에 버는 것입니다. 어쩌면 나중에는 정리가 필요하지 않을 수도 있습니다.
- 옵션이 생길 일이 명백하다면, 코드 정리를 선행하세요. 동작 변경 후에도 정리할 내용이 있다면, 또 합니다.

자, 확실히 코드 정리부터 해야 할 때가 있습니다. 언제일까요?  
`비용(코드 정리) + 비용(코드 정리 후 동작 변경) < 비용(바로 동작 변경)`  

위 수식이 성립하면 무조건 코드 정리를 먼저 하세요.  

이보다 곤란한 상황은 다음과 같은 경우에 발생합니다.  
`비용(코드 정리) + 비용(코드 정리 후 동작 변경) > 비용(바로 동작 변경)`  

단기적인 경제성 때문에 코드 정리가 망설여지더라도 코드 정리를 먼저 하고 싶을 수 있습니다.  
그리고 코드 정리 과정에서 자연스럽게 동작 변경까지 하고 있을 수도 있습니다.  
모든 변경에 걸쳐 코드 정리에 드는 비용을 나누는 것이 합리적일 수 있으며, 심지어 현금흐름을 할인하는 것도 가능합니다.  

창출된 옵션의 가치가 더 빨리 그리고 확실하게 돈을 지출함으로써 잃는 가치보다 크다면 현금흐름이 할인되더라도 코드 정리를 우선하는 것이 오히려 경제적으로 합리적일 수 있습니다.  
`이 지점은 확고한 판단의 갈림길입니다.`

이러한 '자기 관리로서의 코드 정리'는 어느 정도 정당화될 수 있습니다.  
다만, 경제적 인센티브에 반하는 행동을 하고 있을 수도 있다는 사실을 항상 인식하세요.  

우리는 두 가지 중요한 형태의 판단력을 길러서, 나중에 더 큰 일을 실행하려고 합니다.  
- 소프트웨어 설계의 시기와 범위에 영향을 미치는 인센티브를 인식하는 데 익숙해지기
- 대인 관계 기술을 우리 자신에게 연습해서, 나중에 밀접하게 일하는 동료부터 더 넓은 범위의 동료에게까지 활용하기  

> 비용을 판단하기 위해 경험과 도메인 지식 필요  


## Chapter 28. 되돌릴 수 있는 구조 변경

선행 코드 정리의 특징은 구조 변경은 대체로 되돌릴 수 있다는 점입니다.  

반면에, 후회할 만한 동작 변경과 대조해 보세요.  
모르긴 해도 해결하는 데 큰 비용이 들겁니다.  

일반적으로 되돌릴 수 있는 결정은 되돌릴 수 없는 결정과 다르게 취급해야 합니다.  
되돌릴 수 없는 결정에 대해서는 면밀히 검토하고 두 번, 세 번 확인하는 일은 매우 가치 있는 일입니다.  

대부분의 소프트웨어 설계 결정은 쉽게 되돌릴 수 있습니다.  
동작 변경을 쉽게 할 수 있는 장점이 있습니다.  
하지만, 부작용은 크지 않습니다.  
잘못된 결정이었다고 깨달으면, 쉽게 되돌릴 수 있으니까요.  

따라서, 실수를 피하는 것이 신경 쓸 정도로 큰일이 아니기 때문에 지나치게 노력할 필요가 없습니다.  

코드 검토 절차는 되돌릴 수 있는 변경 사항과 되돌릴 수 없는 변경 사항을 구분하지 않습니다.  
결국 너무나 다른 결과를 초래하는 일에 똑같이 시간 투자를 하는 꼴입니다.  

되돌릴 수 없는 설계 변경은 어떻게 하면 좋을까요?  
예를 들어, '서비스로 추출하기'는 비교적 큰 문제이기 때문에 되돌리기 어려울 수 있습니다.  
프로토타입을 실제로 구현해 볼 수도 있습니다.  
정리를 먼저 합시다.  
기능 플래그만 확인하면 되니까요.  

'서비스로 추출하기'를 적어도 당분간은 되돌릴 수 있게 만들고 있습니다.  

되돌릴 수 있었던 설계 결정이 되돌릴 수 없게 되는, 또 다른 시나리오는 설계 결정이 코드 베이스 전체에 전하될 때입니다.  

> 카나리 배포  
> 슬픈 사실은 트래픽이 많지 않은 서비스(파드 2개)에서 카나리 배포는 큰 의미가 없다는 점  
> 물론, 임시로 전체 파드를 늘릴 수도 있겠지만.  
> 
> 매일 배포하는 팀이 되는 여정(2) — Feature Toggle 활용하기  
> https://medium.com/daangn/%EB%A7%A4%EC%9D%BC-%EB%B0%B0%ED%8F%AC%ED%95%98%EB%8A%94-%ED%8C%80%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%97%AC%EC%A0%95-2-feature-toggle-%ED%99%9C%EC%9A%A9%ED%95%98%EA%B8%B0-b52c4a1810cd  


## Chapter 29. 결합도

그에 따르면 비싼 프로그램에는 모두 한 가지 공통점이 있다는 것을 발견했습니다.  
한 요소를 변경하려면 다른 요소도 변경해야 한다는 것이죠.  
반면 저렴한 프로그램은 좁은 범위의 코드 변경만 필요한 경향이 있었습니다.  

그들은 이 변경 감염 특성을 '결합도'라고 불렀습니다.  
한 요소를 변경하면 다른 요소도 함께 변경해야 하는 경우, 두 요소는 특정 변경과 관련하여 서로 결합되어 있는 것입니다.  

결합도 분석은 단순히 프로그램의 소스코드를 보는 것만으로는 부족합니다.  
두 요소가 결합되어 있는지 여부를 판단하려면, 먼저 어떤 변경이 발생했거나 발생할 가능성이 있는지 알아야 합니다.  
`테스트 해보려면 하나의 커밋에서 어떤 파일 쌍이 함께 나타나는 경향이 있는지 살펴보세요. 그런 파일들은 결합되어 있습니다.`

### 일대다 (1-N)

어떤 변경이 일어나면, 한 요소는 여러 요소와 결합이 일어납니다.  

### 연쇄작용

일단 변경이 일어나면, 한 요소에서 다른 요소로 변경이 파급되고, 그 변경은 그 자체로 또 다른 변경을 촉발하고, 스스로도 변경을 촉발할 수 있습니다.  

호출하는 곳이 하나든 1천 개든 비용은 같습니다.  

연쇄적인 변경이 더 큰 문제입니다.  

실제로 시스템이 '복잡하다'는 것은 변화가 예상치 못한 결과를 초래한다는 의미입니다.  
서비스를 담당하는 두 팀이 서로를 알지 못 했음에도 두 서비스는 백업 정책 변경과 관련하여 서로 연결되어 있었습니다.  

`가끔 지저분한 변화를 바라보고 있을 때, 결합도 때문에 마음이 흔들릴 때가 있습니다.`  

> 테스트 코드 작성할 때도 결합도를 생각해야 함  
> 복잡한 엔티티가 필요한 테스트 코드에서 엔티티를 생성하기 위해 Fixtures를 만들고, 서비스 클래스를 넣어놓은 프로젝트가 있음  
> 이로 인해 모든 테스트 코드가 @SpringBootTest를 선언해줘야 하고, 테스트 코드 실행시간도 오래 걸림  
> 가장 큰 문제는 Fixtures의 복잡도 때문에 테스트 코드를 수정할 수가 없음  
> 처음에는 복잡한 엔티티를 편하게 생성하기 위함 이었겠지만, Fixtures에 계속 추가되면서 결합도가 높아지는 문제 발생  


## Chapter 30. 콘스탄틴의 등가성

소프트웨어 개발 비용의 70%가 유지보수에 들어간다는 끔찍한 보고를 들었던 기억이 납니다.  

소프트웨어 설계의 목표는 소프트웨어의 비용을 최소화하는 것이라고 가정했습니다.  

'콘스탄틴의 등가성'이라고 이름 붙인 이 용어에 따르면, 소프트웨어 비용은 그것을 변경하는 데 드는 비용과 거의 같습니다.  
`비용(소프트웨어) ~= 비용(변경)`  

소프트웨어의 수명 주기에 따른 누적 비용을 그래프로 나타내면, 로그 함수 곡선과 같은 모양을 얻을 수 있습니다.  
출시 전 기간은 전체 시간 중에서 작은 부분을 차지하고, 총 비용 중에서도 작은 부분을 차지합니다.  

시스템 동작을 조금씩 변경해 갈 수 있습니다.  
그런데 거기에 든 비용을 모두 합치면 출시 비용과 비슷해진다는 거죠.  

월별 비용은 낮은 수준에서 시작하여 빠르게 증가하다가, 다른 기회가 수익을 더 내면서, 점차 줄어듭니다.  
그렇다면 출시 후 비용 증가의 기울기가 훨씬 더 가파른 이유는 무엇일까요?  
한편으로는 기존 시스템과의 마찰도 함께 일어나기 때문입니다.  
실제 운영 서버의 안정성도 걱정해야 하고요.  

가장 비용이 많이 드는 하나의 변경이 나머지 변경을 모두 합친 것보다 훨씬 더 많은 비용이 듭니다.  
`비용(전체 변경) ~= 비용(큰 변경들)`

소프트웨어 비용은 결합도와 거의 같습니다.  
`비용(큰 변경들) ~= 결합도`

`비용(스프트웨어) ~= 비용(전체 변경) ~= 비용(큰 변경들) ~= 결합도`

따라서 소프트웨어 비용을 줄이려면 결합도를 줄여야 합니다.  

> 테스트 코드 작성이 어렵다면, 뭔가 문제가 있다는 뜻


## Chapter 31. 결합도와 결합도 제거

결합도는 깜깜한 바닥에 놓인 레고 조각들처럼 직접 밟아보기 전까지는 잘 드러나지 않습니다.  
동작 변경을 하려다가 곧 알아차리게 됩니다.  

결합도가 생겨도 빠르게 코드를 작성하는 길을 택할 수도 있고, 반면에 결합도 없이 더 긴 시간과 더 많은 노력을 들여서 코드를 작성할 수도 있습니다.  
앞 장에서 설명한 것과 같이 구현할 당시에는 결합도가 있어도 구현하는 것이 경제적으로 올바른 결정이었습니다.  

시스템에 결합도가 있어야 하는 또 다른 정당한 이유는 방금 전까지만 해도 문제가 되지 않았기 때문입니다.  

결합도가 필요한 마지막 이유는 어떤 결합도는 피할 수 없기 때문입니다.  

결합도가 왜 있는지는 사실 중요하지 않습니다.  
지금 결합도 비용을 지불할 것인지, 아니면 결합도를 없애는 비용을 지불할 것인지 여러분은 선택의 기로에 서게 됩니다.  

`한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 커진다는 것입니다.`  
이것이 의미하는 실질적인 의미는 모든 결합을 다 색출하듯 없애려고 애쓰지 말아야 한다는 것입니다.  


## Chapter 32. 응집도

결합된 요소들은 둘을 포함하는 같은 요소의 하위 요소여야 합니다.  
이것이 응집도가 내포하는 첫 번째 의미입니다.  
응집도의 두 번째 의미는 거름이 아닌 이물질은 이 더미가 아닌 다른 곳으로 이동해야 한다는 것입니다.  

첫 번째 방안은 결합된 요소를 자체 하위 요소로 묶는 것입니다.  

도우미 함수를 추출하는 것이 일종의 '응집도가 있는 하위 요소 추출' 접근 방식입니다.  
응집도가 있으면, 분석과 변경이 쉽고, 우발적인 동작 변경에 대한 가능성이 줄어듭니다.  

두 번째 방안은 결합되지 않은 요소를 가져와 다른 곳에 배치하는 것입니다.  
함수의 형제들을 찾아 더 가깝게 이동하세요.  

하지만 즉흥적으로 시도하지는 마세요.  
무엇이 무엇과 결합되어 있는지에 대한 불완전하고 변화하는 정보를 가지고 작업하면 안 됩니다.  
한 번에 한 요소씩 이동하세요.  
다음에 코드를 볼 사람을 위해 코드를 더 깔끔하게 정리하세요.  
모두가 스카우트 규칙을 따른다면, 시간이 지날수록 코드가 더 살기 좋은 코드가 될 것입니다.  


## Chapter 33. 결론

- 비용: 코드를 정리하면 비용이 줄까요?
- 수익: 코드를 정리하면 수익이 더 커질까요?
- 결합도: 코드를 정리하면 변경에 필요한 요소의 수가 줄어드나요?
- 응집도: 코드를 정리하면 변경을 더 작고 좁은 범위로 집중시켜 더 적은 수의 요소만 다룰 수 있을까요?

코드를 정리하면 평화, 만족, 기쁨을 느끼면서 프로그래밍을 할 수 있을까요?  
이것이 중요한 이유는 여러분이 최상의 상태에서 주체적으로 일할 때, 더 나은 프로그래머가 될 수 있기 때문입니다.  
항상 시간에 쫓기며 고치기 힘든 코드를 변경하느라 고통 속에 있다면 최상의 상태가 될 수 없습니다.  

코드 정리에 너무 집착하지 마세요.  
코드 정리를 하면서 자신의 삶과 업무가 더 나아질 수 있다는 사실을 깨닫고 나면, 때때로 들뜬 기분에 휩싸여 코드 정리가 제일 우선이라고 생각할 수 있습니다.  

결합도는 하나의 코드 정리 작업이 다음 코드 정리 작업으로 이어지게 합니다.  
그러나 변경을 기다리는 다른 누군가가 기다리다 폭발하지 않도록 코드 정리를 나중에 해야 할 때도 있습니다.  

혼자서 프로그래밍하는 경우는 거의 없습니다.  
제가 변경하면 여러 사람에게 영향을 끼치고, 여러분이 변경하면 저에게 영향을 끼칠 수 있습니다.  

너무 멀리 내다보고 계획하지 않는 것이 좋지만, 여러분이 배우고 있는 이 훌륭한 기술의 궁극적인 보상은 자신이 다른 사람들과 더 잘 지내는 것입니다.  
소프트웨어 설계를 일상적인 비즈니스와 전략 계획의 일부로 삼는다면 비즈니스와 기술 사이의 균열을 치유하는 데 기여할 수 있습니다.  


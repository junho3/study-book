# 12장 전자 지갑

## 1단계: 문제 이해 및 설계 범위 확정

- 이체 기능에만 집중
- 초당 트랜잭션은 1,000,000TPS 가정
- 데이터베이스가 제공하는 트랜잭션 보증이면 충분
- 처음부터 데이터를 재생하여 언제든지 과거 잔액을 재구성할 수 있는 시스템
- 가용성 요구사항 99.99%
- 환전은 필요없음

### 개략적 추정

본 설계안에서 사용할 데이터베이스 노드는 1,000TPS를 지원할 수 있다고 가정하겠다.  
따라서 1백만 TPS를 지원하려면 1,000개의 데이터베이스 노드가 필요하다.  

한 계좌에서 인출 연산을 실행해야 하고, 다른 계좌에서는 입금 연산을 실행해야 한다.  
1백만 건의 TPS를 처리하기 위해서는 2백만 TPS를 지원해야 하고, 결국 2000개 노드가 필요하다는 뜻이다.  

이번 장의 설계 목표 중 하나는 단일 노드가 처리할 수 있는 트랜잭션 수를 늘리는 것이다.  


## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 설계

한 가지 유의할 부분은 'amount' 필드의 자료형이 double이 아니라 string이라는 점이다.  

> openRTB: "bidfloor": 0.03 float 타입  
> paypal: "value": "10.99" string 타입  
> toss payments 해외결제: "value": 664.98 number 타입 // 소수점 두 번째 자리까지 허용  

그러나 실제로는 float이나 double을 택하는 경우도 많은데, 대부분의 프로그래밍 언어와 데이터베이스가 지원하기 때문이다.  
정밀도를 잃을 위험이 있음을 이해하고 사용한다면 적절한 선택일 수 있다.

> php: 언어 자체에 BigDecimal 없고, 라이브러리 존재  
> https://stackoverflow.com/questions/49020952/bigdecimal-equivalent-for-php  
> 
> python: decimal.Decimal  
> https://stackoverflow.com/questions/16996527/what-is-the-python-for-javas-bigdecimal  
> 
> nodejs: BigInt, 그 외 라이브러리 존재  
> https://stackoverflow.com/questions/16742578/bigdecimal-in-javascript  

### 인메모리 샤딩

지갑 애플리케이션은 모든 사용자 계정의 잔액을 유지한다.  
<사용자, 잔액> 관계를 나타내기 좋은 자료 구조는 해시 테이블이라고 불리는 맵 또는 키-값 저장소다.  

레디스 노드 한 대로 100만 TPS 처리는 벅차다.  
클러스터를 구성하고 사용자 계정을 모든 노드에 균등하게 분산시켜야 한다.  
이 절차를 파티셔닝 또는 샤딩이라고 한다.  

키-값 데이터를 n개 파티션에 고르게 분배하려면 키의 해시 값을 계산하고 이를 파티션의 수 n으로 나누는 것이 한 가지 방법이다.  
그 결과로 얻은 나머지 값이 데이터를 저장할 파티션 번호다.  

모든 레디스 노드의 파티션 수 및 주소는 한군데 저장해 둔다.  
높은 가용성을 보장하는 설정 정보 전문 저장소 주키퍼를 이 용도로 쓰면 좋다.  

그림 12.3 설계는 작동은 하지만 정확성 요구사항을 충족하지 못한다.  
지갑 서비스는 이체할 때마다 두 개의 레디스 노드를 업데이트하는데, 그 두 연산이 모두 성공하리라는 보장은 없다.  

### 분산 트랜잭션

#### 데이터베이스 샤딩

트랜잭션 데이터베이스를 사용해도 이런 식이면 문제의 일부만 해결할 수 있다.  

#### 분산 트랜잭션: 2단계 커밋

분산 트랜잭션은 이들 프로세스를 원자적인 하나의 트랜잭션으로 묶는 방안이다.  

저수준 방안은 데이터베이스 자체에 의존하는 방안이다.  
이때 가장 일반적으로 사용되는 알고리즘은 2단계 커밋(2PC)이다.  

이 방안이 저수준 방안인 이유는, 이기종 데이터베이스 사이에 2PC를 실행하려면 모든 데이터베이스가 X/Open XA 표준을 만족해야 한다.  
2PC의 가장 큰 문제점은 다른 노드의 메시지를 기다리는 동안 락이 오랫동안 잠긴 상태로 남을 수 있어서 성능이 좋지 않다는 것이다.  
또 다른 문제는 조정자가 SPOF가 될 수 있다는 것이다.  

#### 분산 트랜잭션: TC/C

TC/C(시도-확정/취소, 즉 Try-Confirm/Cancel)는 두 단계로 구성된 보상 트랜잭션이다.  

시도 단계에서는 조정자 역할을 하는 지갑 서비스가 두 개의 트랜잭션 명령을 두 데이터베이스로 전송한다.  
데이터베이스는 NOP 명령에 대해 아무 작업도 수행하지 않으며 항상 성공했다는 응답을 보낸다.  

두 데이터베이스가 모두 예라고 응답하면 지갑 서비스는 확정 단계를 시작한다.  

이미 종료된 트랜잭션의 효과를 되돌리려면 지갑 서비스는 또 다른 트랜잭션을 시작하여 계정 A에 1달러를 다시 추가해야 한다.  
시도 단계에서 계정 C의 잔액은 업데이트하지 않았으므로, 계정 C의 데이터베이스에는 NOP 명령을 전송하기만 하면 된다.  

##### 2PC와 TC/C의 비교

|      | 첫 번째 단계                      | 두 번째 단계: 성공         | 두 번째 단계: 실패             |
|------|------------------------------|---------------------|-------------------------|
| 2PC  | 로컬 트랜잭션은 아직 완료되지 않은 상태       | 모든 로컬 트랜잭션을 커밋      | 모든 로컬 트랜잭션을 취소          |
| TC/C | 모든 로컬 트랜잭션이 커밋되거나 취소된 상태로 종료 | 필요한 경우 새 로컬 트랜잭션 실행 | 이미 커밋된 트랜잭션의 실행 결과를 되돌림 |

##### 단계별 상태 테이블





# 6장 조건 분기: 미궁처럼 복잡한 분기 처리를 무너뜨리는 방법

조건 분기를 사용하면 복잡한 판단을 빠르고 정확하게 할 수 있습니다.  
조건이 복잡해지면 코드의 동작을 이해하기 힘듭니다.  


## 6.1 조건 분기가 중첩되어 낮아지는 가독성

중첩을 하면 코드의 가독성이 크게 떨어지는 문제가 있다.  
어떤 조건을 만족할 때 어떤 로직이 처리되는지 이해하는 것만으로도 많은 시간을 낭비한다.  
**그런데 이런 낭비가 한 번으로 끝나지 않는다.**    
**코드를 읽을 때마다 낭비가 생기고, 코드를 읽는 사람 모두 이런 일을 겪으므로 가독성이 나쁜 코드는 팀 전체의 개발 생산성을 저하시킨다.**  

> 최근에 회계처리를 위한 분개룰 설계 논의를 하는 중인데, 몇몇 팀원이 단일 클래스로 구성해서 조건을 넣자는 의견을 제시함  

### 6.1.1 조기 리턴으로 중첩 제거하기

조기 리턴은 조건 로직과 실행 로직을 분리할 수 있다는 장점이 있다.  

### 6.1.2 가독성을 낮추는 else 구문도 조기 리턴으로 해결하기


## 6.2 switch 조건문 중복

### 6.2.1 switch 조건문을 사용해서 코드 작성하기

### 6.2.2 같은 형태의 switch 조건문이 여러 개 사용되기 시작

같은 형태의 switch 조건문을 여러 번 사용하는 것은 매우 좋지 않다.  

### 6.2.3 요구 사항 변경 시 수정 누락(case 구문 추가 누락)

> 코틀린은 when()을 하용하고, enum 값이 추가되었을 때 when 문에 누락이 생기면 컴파일 에러가 발생함  
> 
> when (type) {  
>   card -> ...  
>   money -> ...  
> }

### 6.2.4 폭발적으로 늘어나는 switch 조건문 중복

### 6.2.5 조건 분기 모으기

switch 조건문 중복을 해소하려면, 단일 책임 선택의 원칙을 생각해 봐야 한다.  

```
// Magic 클래스를 정의해서 생성자에서 조건과 조건에 따른 결과를 관리
class Magic {
  final String name;
  final int power;
  
  Magic(...) {
    switch (...) {
      case...
    }
  }
}
```

> 조건별 필요한 값이 동일하다면, 위 내용처럼 클래스로 정의해서 필요한 값을 모아두는 것도 좋아보임  

### 6.2.6 인터페이스로 switch 조건문 중복 해소하기

클래스가 거대해지면 관심사에 따라 작은 클래스로 분할하는 것이 중요하다.  

면적을 출력하는 같은 이름의 메서드를 만들었다고 해도 클래스가 다르므로, instanceof를 사용해서 자료형을 판정한 뒤 자료형을 강제로 변환해서 메서드를 호출해야 한다.  
인터페이스를 활용하면, 자료형 판정 분기를 따로 작성하지 않아도 된다.  

> Code_6_26Test.kt 참고

### 6.2.7 인터페이스를 switch 조건문 중복에 응용하기 (전략 패턴)

#### 종류별로 다르게 처리해야 하는 기능을 인터페이스의 메서드로 정의하기

인터페이스의 큰 장점 중 하나는 다른 로직을 같은 방식으로 처리할 수 있다는 점이다.  

#### 인터페이스의 이름을 결정하는 방법: '어떤 부류에 속하는가?'

#### 종류별로 클래스로 만들기

#### 각각의 클래스에 인터페이스 구현하기

#### switch 조건문이 아니라, Map으로 변경하기

`final Map<WeaponType, Weapon> weapons = new HashMap<>();`

이처럼 인터페이스를 사용해서 처리를 한꺼번에 전환하는 설계를 '전략 패턴'이라고 한다.  

#### 메서드를 구현하지 않으면 오류로 인식하게 만들기

구현하지 않은 메서드가 단 하나라도 존재하면, 컴파일하는 데 실패한다.  

#### 값 객체화하기


## 6.3 조건 분기 중복과 중첩

인터페이스는 switch 조건문의 중복을 제거할 수 있을 뿐만 아니라, 다중 중첩된 복잡한 분기를 제거하는 데 활용할 수 있다.  

### 6.3.1 정책 패턴으로 조건 집약하기

정책 패턴은 조건을 부품처럼 만들고, 부품으로 만든 조건을 조합해서 사용하는 패턴이다.

> Code_6_49.kt 참고

## 6.4 자료형 확인에 조건 분기 사용하지 않기

인터페이스를 사용해도 조건 분기가 줄어들지 않는 경우가 있다.  

```
Money busySeasonFee;
if (hotelRates instanceof RegularRates) {
  busySeasonFee = hotelRates.fee() + 30000; // 성수기에 3만원 추가
} else if (...) {}
  else if (...) {}
```

이후로도 특정 기간에 적용하는 요금을 추가한다면, instanceof 조건문을 계속 추가될 것이다.  
위 코드는 리스코프 치환 원칙을 위반한다.  
기반 자료형(인터페이스)을 하위 자료형(클래스: RegularRates)으로 변경해도, 코드는 문제없이 동작해야 한다.  

인터페이스에 busySeasonFee() 메소드를 정의하고, 구현체에 각각 구현한다.  


## 6.5 인터페이스 사용 능력이 중급으로 올라가는 첫걸음

초보자
- if 조건문과 switch 조건문만 사용
- 로직을 그냥 작성

중급자 이상
- 인터페이스 설계 사용
- 클래스 사용

**조건 분기를 써야 하는 상황에는 일단 인터페이스 설계를 떠올리자!**


## 6.6 플래그 매개변수

```
void run(boolean flag) {
  if (flag == true) { ... }
  else { ... }
}
```

플래그 매개변수를 받는 메서드는 어떤 일을 하는지 예측하기 굉장히 힘들다.  
예측을 하기 위해서는 반드시 메서드 내부 로직을 확인해야 하므로, 가독성이 낮아지며 개발 생산성이 저하된다.  

### 6.6.1 메서드 분리하기

메서드는 하나의 기능만 하도록 설계하는 것이 좋다.  
따라서 플래그 매개변수를 받는 메서드는 기능별로 분리하는 것이 좋다.  

### 6.6.2 전환은 전략 패턴으로 구현하기

플래그 매개변수가 아니라 전략 패턴을 사용하라.  



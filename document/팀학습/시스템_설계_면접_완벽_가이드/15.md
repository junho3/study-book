# 15 에어비앤비 설계

- 영화 티켓
- 항공권
- 주차장
- 택시나 차량 공유 서비스


## 15.1 요구사항

결제 솔루션은 국가, 주, 도시와 기타 정부 수준에 따라 다르고 다양한 제품과 서비스에 따라 다른 수많은 통화와 규정(세금 포함)을 고려해야한다.  

- 요구사항
  - 방은 중복 예약될 수 없다.  

비판적 사고와 세부 사항에 대한 관심을 보여주기 위해 다음과 같은 기능적 요구사항을 언급하는 것이 좋다.  

- 비기능적 요구사항
  - 10억 개의 방이나 1억 건의 일일 예약으로 확장 가능
  - 예약, 더 정확히는 목록 가용성에 강한 일관성을 적용. 따라서 일반적으로 이중 예약이나 이용 불가능한 날짜의 예약이 없을 것이다.
  - 높은 성능은 불필요하다. P99 몇 초면 허용 가능하다.
  - 일반적인 보안과 프라이버시 요구사항은 인증이 필요하다.


## 15.2 설계 결정

- 방 목록의 정보를 여러 데이터 센터에 복제해야 하는가?
- **데이터 모델은 방의 가용성을 어떻게 표현해야 하는가?**

### 15.2.1 복제

검색은 한 번에 한 도시에서만 가능하다.  
이를 활용해 많은 목록이 있는 도시나 목록이 적은 여러 도시에 데이터 센토 호스트를 핟랑할 수 있다.  
쓰기 성능이 중요하지 않으므로 단일 리더 복제를 사용할 수 있다.  

읽기 지연을 최소화하기 위해 보조 리더와 팔로워를 지리적으로 데이터 센터에 분산시킬 수 있다.  
메타데이터 서비스를 사용하여 도시와 리더 및 팔로워 호스트 IP 주소의 매핑을 포함하면 우리 서비스가 지리적으로 가장 가까운 팔로워 호스트를 조회하여 특정 도시의 방을 가져오거나 해당 도시에 해당하는 리더 호스트에게 글을 쓸 수 있다.  

방이 매우 인기 있다면 곧 예약돼 더 이상 검색에 표시되지 않을 것이다.  
캐시의 최신성을 유지하기가 어렵고 캐시된 데이터가 빠르게 낡는다는 것이다.  

항상 그렇듯이 이러한 결정은 논쟁의 여지가 있으며, 그 트레이드오프를 설명할 수 있어야 한다.  


### 15.2.2 방 가용성 데이터 모델

데이터 모델에서 방 가용성을 표현하는 다양한 방법을 빠르게 브레인스토밍하고 그 트레이드오프를 설명해야 한다.  

- (room_id, date, guest_id) 테이블
  - 이는 개념적으로 단순하지만 날짜만 다른 여러 행을 포함해야 한다는 트레이드오프가 있다.
  - 예를 들어 방 1이 한 달동안 게스트에 의해 예약되면 31개의 행이 있을 것이다.
- (room_id, guest_id, check_in, check_out) 테이블
  - 게스트가 체크인과 체크아웃 날짜로 검색을 제출할 때 날짜가 겹치는지 확인하는 알고리즘이 필요하다.
  - 이 알고리즘을 데이터베이스 쿼리에 코딩해야할 까, 아니면 백엔드에 코딩해야 할까?
  - 백엔드 호스트가 데이터베이스에서 대상이 되는 방의 가용성 데이터를 가져와야 한다면 I/O 비용이 발생할 것이다.


### 15.2.3 겹치는 예약 처리

여러 사용자가 같은 방을 겹치는 날짜로 예약하려고 시도하면 첫 번째 사용자의 예약이 허용돼야 하며, 다른 사용자에게 이용할 수 없을 알려야 한다.  


### 15.2.4 검색 결과 무작위화

### 15.2.5 예약 과정 중 방 잠금

사용자가 예약 요청을 제출하려고 할 때 몇 분 동안 그 방에 대해 해당 날짜를 잠글 수 있다.  

이는 일부 예약을 잃게 된다는 것을 의미한다.  
이중 예약을 방지하는 것이 예약 손실의 트레이드오프를 감수할 만한 가치가 있다고 판단할 수 있다.  

이는 에어비앤비와 호텔의 차이점이다.  
호텔은 몇 건의 취소가 발생할 것으로 예상할 수 있으므로 저렴한 객실의 초과 예약을 허용할 수 있다.  

> 호텔은 방이 많기 때문에 에어비앤비와 DB 설계를 다르게 접근해야할 것 같음  
> 오버부킹을 허용해야함  
> 어떻게하면 특정 방을 기간동안 할당할 수 있을까?  


## 15.3 고수준 아키텍처

- 예약 서비스
  - 게스트가 예약하기 위한 서비스
  - 가용성과 지연 시간에 가장 엄격한 비기능적 요구사항이 있다.
  - 높은 지연 시간은 직접적으로 낮은 수익으로 이어진다.
  - 강한 일관성은 덜 중요할 수 있으며, 가용성과 지연 시간을 위해 일관성을 희생할 수 있다.
- 목록 서비스
  - 호스트가 목록을 만들고 관리하기 위한 서비스
  - 비기능적 요구사항을 가지므로 별도의 서비스이며, 따라서 리소스를 공유해서는 안 된다.
- 가용성 서비스
  - 목록 가용성을 추적하며 예약과 목록 서비스 모두에서 사용된다.
  - 가용성과 지연 시간 요구사항은 예약 서비스만큼 엄격하다.
- 승인 서비스
  - 새 목록 추가나 특정 목록 정보 업데이트와 같은 운영 승인을 제공하는 서비스
- 추천 서비스
- 규정 서비스
  - 목록 서비스와 예약 서비스는 지역 규정을 고려해야 한다.
- 기타 서비스


## 15.4 기능적 분할

애플리케이션을 여러 데이터 센터에 배포하고 각 사용자를 해당 도시를 서비스하는 데이터 센터로 라우팅한다.


## 15.5 목록 생성 또는 업데이트

첫 번째 작업은 호스트가 적절한 목록 규정을 얻는 것이다.  
두 번째 작업은 호스트가 목록 요청을 제출하는 것이다.  

- 적절한 목록 규정을 얻는 시퀀스 다이어그램
  - 클라이언트 > 목록 요청 > 목록 서비스 > 규정 요청 > 규정 서비스 > 규정 목록 응답
- 목록 요청의 시퀀스 다이어그램
  - 호스트가 목록 정보를 입력하고 제출 > 목록 서비스 > 유효성 검사 > SQL 서비스 > 새 목록 작성 > 검토 요청 > 승인 서비스 > 승인 응답

CDC를 사용해 '새 목록 작성'과 '검토 요청'을 병렬로 수행할 수 있다.  
모든 단계는 멱등성이 있다.  
중복 쓰기를 방지하려면 SQL 테이블에 INSERT IGNORE를 사용할 수 있다.  

> CDC를 사용했을 때의 장점이 무엇인가?  
> 목록 서비스와 승인 서비스를 분리하기 위함인가?  
> 목록 서비스가 일종의 오케스트레이터 역할을 해야되는게 아닌지?  


## 15.6 승인 서비스

승인 서비스는 트래픽이 적은 내부 애플리케이션으로 간단한 아키텍처를 가질 수 있다.  
모든 요청에 수동 승인이 필요하다고 가정한다.  

- 운영팀 10,000명
- 직원별 주당 최대 5,000개의 새 목록 검토
- 행은 1KB
- 10,000 x 5,000 x 1KB x 30(일) = 1.5TB

SQL 테이블에 1~2개월 분량의 데이터를 보관하고 주기적인 배치 작업을 실행해 오래된 데이터를 객체 저장소에 아카이브할 수 있다.  

last_accessed 타임 스탬프가 review_submitted_at보다 최근인지 확인해 경쟁 조건을 식별하려고 할 수 있다.  
그러나 이 기술은 신뢰할 수 없다.  
타임스탬프 열을 기록하는 다양한 호스트의 시간 정보를 완벽하게 동기화하지 않기 때문이다.  

램포트(Lamport) 시간 정보는 분산 시스템에서 이벤트의 순서를 정하는 기술이다.  
벡터 시간 정보는 더 정교한 기술이다.  

> 벡터 시계를 GPT 도움으로 이해한 내용  
> 주문, 회원, 상품 3개의 분산 어플리케이션이 존재한다고 가정  
> 3개의 어플리케이션에서 동일한 데이터 X를 처리할 수 있다고 할 때, VC(X) = [0,0,0], 서비스의 개수 = 배열의 크기  
> 
> 주문이 데이터 A를 처리할 하면 [1,0,0]   
> 동시에 회원이 데이터 A를 처리하게 되면 [0,1,0]  
> [1,1,0] 이므로 주문이 했는지, 회원이 했는지 판단하지 못 함. 애플리케이션에서 [1,0,0] 버전과 [0,1,0] 버전을 모두 가져와서 알아서 처리해야함  
> 
> 약간의 시간 뒤에 회원이 데이터 A를 처리하게 되면 [1,2,0]  
> 주문 처리한 값 1을 보고, 회원이 처리할 값 1에 + 1 하여 2로 저장  
> 
> 동시성 제어에 얼마나 장점이 있는지 잘 모르겠음  

승인 테이블에 중복 행이 생기는 것을 방지하기 위해 SQL 행 삽입 시 `IF NOT EXISTS` 연산자를 사용할 수 있다.  

CDC를 대신 사용해야 할까?  
이 프로세스에서 사가 패턴 대신 CDC를 사용하는 이유는 서비스 중 어느 것도 요청을 거부하지 않을 것으로 예상하기 때문이며, 따라서 필요한 보상 트랜잭션이 없을 것이다.  

그러나 사용자가 목록이 승인되기 직전에 계정을 취소하면 어떻게 될까?  
목록을 비활성화하거나 삭제하고 필요에 따라 다른 서비스에 요청하는 CDC 프로세스가 필요할 것이다.  
다양한 접근 방식의 트레이드오프와 떠오르는 그 밖의 고나련 문제를 면접관과 논의해야 한다.  

예약 서비스는 트래픽이 많을 수 있으므로 이 단계가 가장 높은 실패율을 가질 수 있다.  
일반적인 접근 방식대로 지수 백오프와 재시도 또는 데드레터 큐를 구현할 수 있다.  


## 15.7 예약 서비스

검색과 필터 요청은 일래스틱서치 서비스에서 처리된다.  
일래스틱서치 서비스는 페이지네이션도 처리할 수 있어 한 번에 적은 수의 결과만 반환함으로써 메모리와 CPU 사용량을 절약할 수 있다.  
일래스틱서치는 퍼지 검색을 지원하므로 절차 오류가 있는 위치나 주소 입력에도 적절한 결과를 제공할 수 있다.  

숙소 세부 정보 CRUD 요청을 ORM을 사용해 SQL 쿼리로 변환된 후 SQL 서비스로 전달된다.  
사진과 동영상은 CDN에서 다운로드된다.  

게스트가 예약 요청을 진행하는 동안, 숙소를 5분간 잠궈 중복 예약을 방지할 수 있다.  

숙소의 가용성이나 세부 정보가 변경되면 일래스틱서치 인덱스를 업데이트해야 한다.  
SQL 서비스와 일래스틱서치 서비스 모두에 쓰기 요청이 필요하고, 분산트랜잭션을 사용해 데이터 불일치를 방지할 수 있다.  

많은 게스트가 예약 요청을 하기 전에 숙소를 검색하고 여러 숙소의 세부 정보를 볼 수 있으므로 검색 및 조회 기능과 예약 기능을 별도의 서비스로 분리하는 것을 고려할 수 있다.  


## 15.8 가용성 서비스

가용성 서비스는 다음과 같은 상황을 피해야 한다.  
- 이중 예약
- 게스트의 예약이 호스트에게 보이지 않을 때
- 호스트가 특정 날짜를 이용 불가로 표시했는데 게스트가 그 날짜에 예약할 때
- 이러한 좋지 않은 경험으로 인해 고객 지원 부서가 게스트와 호스트의 불만 처리로 과부하 걸릴 때

중복 예약을 방지하기 위해 SQL 행 잠금을 사용할 수 있다.  

리더-팔로워 SQL 아키텍처의 일관성 트레이드오프는 검색 결과에 이용 불가능한 숙소가 포함될 수 있다는 점이다.  


## 15.9 로깅, 모니터링, 경보

- 비정상적인 예약률
- 숙소 등록률
- 취소율
- 사용자가 전체 흐름을 거치지 않는 상황이 많이 발생할 때
- 낮은 퍼널 전환율


## 15.10 기타 논의 가능한 주제

사용자가 검색 기준과 정확히 일치하지 않는 숙소에 관심을 가질 수 있다.  
일래스틱서치에 제출하기 전에 검색 쿼리를 수정할 수 있을까?  
아니면 관련성이 있는 것으로 간주하는 일래스틱서치 인덱스를 어떻게 설계할 수 있을까?  


### 15.10.1 규정 처리

규정 정보를 전달하는 표준 API를 제공하는 전용 규정 서비스를 설계하고 구현하는 것을 고려할 수 있다.  
변화하는 규정에 유연하게 대응하거나 최소한 예상치 못 한 규정에 대응해 더 쉽게 재설계할 수 있다.  

- COPPA (아동 온라인 개인정보 보호법, 미국))
- GDPR (일반 개인정보 보호법, EU)
- CCPA (캘리포니아 소비자 개인정보 보호법, 미국)

일부 정부는 기업에 자국 관할 구역에서 발생하는 활동 데이터를 공유하게 요구하거나 자국민의 데이터를 국외로 유출하지 않게 요구할 수 있다.  

규정은 기업의 핵심 비즈니스에 영향을 미칠 수 있다.  



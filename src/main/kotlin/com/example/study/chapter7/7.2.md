# 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

클래스가 실수로 가변적으로 될 수 있는 일반적인 경우는 깊은 가변성 때문이다.  
이 문제는 멤버 변수 자체가 가변적인 유형이고 다른 코드가 멤버 변수에 엑세스할 수 있는 경우에 발생할 수 있다.  

## 7.2.1 깊은 가변성은 오용을 초래할 수 있다

> A 객체 생성 후 B 객체에 B-A로 멤버변수를 할당했을 때, A 객체를 수정하면, B 객체의 멤버변수인 B-A 객체도 변경이 일어남  
> Chapter721 테스트 코드 참고  

## 7.2.2 해결책: 방어적으로 복사하라

Getter 함수를 통해 객체가 반환될 때 객체의 복사본을 만들면 깊은 가변성을 방지할 수 있다.  

단점  
- 복사하는 데 비용이 많이 들 수 있다.
- 클래스 내부에서 발생하는 변경을 막아주지 못하는 경우가 많다.

> 코틀린은 listOf로 하면 리스트에 값을 추가할 수 없기 때문에 두번째 단점을 막아줌  

## 7.2.3 해결책: 불변적 자료구조를 사용하라

객체를 불변적으로 만드는 것은 널리 받아들여지고 있는 좋은 관행이다.  

> 코틀린은 불변인 listOf와 가변인 mutableListOf를 제공함  

# 5장 샤딩

데이터베이스 샤딩은 여러 데이터베이스에 워크로드를 분산하여 성능을 향상시키는 스케일아웃 기술로, 일반적이고 폭넓게 사용됩니다.  
샤드는 물리적으로 분리되어 있지만 논리적으로는 같은 데이터베이스입니다.  

샤딩은 MySQL의 고유한 기능이나 능력이 아니어서 엔지니어들이 받아들이기 싫어하는 기술 가운데 하나입니다.  


## 5-1 단일 데이터베이스를 확장하지 않는 이유

샤딩은 MySQL을 수평 확장하는 방식이므로 더 많은 데이터베이스가 필요합니다.  


### 애플리케이션 워크로드

쿼리와 데이터, 접근 패턴은 성능과 관련하여 뗄 수 없는 관계입니다.  
데이터 크기는 늘어날수록 쿼리와 접근 패턴에 영향을 줍니다.  

쿼리가 단순하고 인덱스가 매우 우수하며 접근 패턴이 단순하다면 단일 서버에 많은 데이터를 저장할 수 있습니다.  


### 모의 벤치마크

벤치마크는 모의 쿼리, 데이터, 접근 패턴을 사용합니다.  
따라서 벤치마크는 같은 하드웨어에서도 애플리케이션의 성능과 확장 방식을 알려주거나 제안할 수도 없습니다.  

대부분의 애플리케이션에는 하나 이상의 접근 패턴 때문에 성능이 좌우되는 워크로드를 가지고 있지 않습니다.  

벤치마크는 다음을 수행하는 데 사용 됩니다.  
- 하드웨어 비교
- 서버 최적화 비교: 플러싱 알고리즘을 다른 알고리즘과 비교
- 서로 다른 데이터 스토리지 비교
- MySQL 한계 테스트

벤치마크에서 확인한 놀라운 성능은 애플리케이션으로 변환되지 않습니다.  


### 쓰기

쓰기는 다음과 같은 이유로 단일 MySQL 인스턴스에서 확장하기 어렵습니다,  

#### 단일 쓰기 (원본) 인스턴스

동시에 같은 행에 여러 번 쓸 수 있는 쓰기 충돌을 피하기 위해 쓰기는 단일 MySQL 인스턴스로 제한됩니다.  

#### 트랜잭션과 잠금

트랜잭션은 ACID 호환 데이터베이스의 'C'와 같이 일관성을 보장하기 위해 잠금을 사용합니다.  
쓰기는 로우 락을 획득해야 하며 때로는 예상보다 훨씬 더 많은 행을 잠급니다.  
같은 데이터에 대해 쓰기 작업량이 많은 워크로드라면 세계 최고의 하드웨어로도 도움이 되지 않습니다.  

#### 페이지 플러싱(지속성)

페이지 플러싱은 MySQL이 디스크에서 변경 사항을 유지하는 지연된 프로세스입니다.  
중요한 점은 페이지 플러싱이 쓰기 성능의 병목 현상이라는 것입니다.  
디스크에 유지되는 지속성이 없다면 캐싱으로 인해 쓰기 속도가 매우 빨라지겠지만, 결국은 모든 하드웨어가 충돌하므로 지속성이 필요합니다.  

#### 쓰기 확대

쓰기 확대는 필요 이상의 부가적인 쓰기를 말합니다.  
테이블에 10개의 세컨더리 인덱스가 있을 때 단일 쓰기는 해당 인덱스를 갱신하기 위해 쓰기 작업을 10번 더 할 수 있습니다.  

> 레거시 테이블에 인덱스 추가가 쉽지 않았던 이유

#### 복제

고가용성을 위해서는 복제가 필요하므로 모든 쓰기 작업은 다른 MySQL 인스턴스로 복제해야 합니다.  
MySQL은 비동기 복제, 반동기 복제, 그룹 복제를 지원합니다.  

- 비동기 복제
  - 트랜잭션을 커밋할 때 데이터 변경 사항이 바이너리 로그에 기록되고 플러싱되므로 쓰기 성능에 약간의 영향이 있음
- 반동기 복제
  - 모든 커밋을 하나 이상의 복제본에서 인지해야 하므로 네트워크 대기 시간에 대한 트랜잭션 처리량을 떨어트림
  - 커밋된 트랜잭션이 손실되지 않도록 보장
- 그룹 복제
  - 더 복잡하고 쓰기를 확장하기가 더 어려움

### 스키마 변경

단일 테이블을 엄청난 크기로 확장하더라도 해당 테이블을 변경하는 데 필요한 시간은 감당할 수 없을 것입니다.  
테이블이 너무 커져서 합리적인 시간 내에 변경할 수 없게 만들면 안 됩니다.  

### 작업

정확하고 세심한 주의를 기울여 쿼리를 직간접적으로 최적화하면 보기 전에는 믿지 못할 크기로 단일 데이터베이스를 확장할 수 있습니다.  

- 백업과 복원
- 실패한 인스턴스 재구축
- MySQL 업그레이드
- MySQL 종료, 시작, 충돌 복구

데이터베이스가 클수록 이러한 작업이 더 오래 걸립니다.  
데이터를 효율적으로 관리하기 위해 규모에 맞는 MySQL 샤딩이 필요하며 이는 다음 절로 이어집니다.  


## 5-2 바위가 아닌 조약돌

규모가 큰 MySQL 샤딩은 작은 인스턴스를 많이 사용하여 달성합니다.  

- 2TB
- 4TB

7TB 데이터베이스보다 500GB 데이터베이스를 관리하는 것이 훨씬 쉽습니다.  


## 5-3 샤딩: 간략한 소개

샤딩 방법과 구현은 반드시 애플리케이션 워크로드와 결합됩니다.  

#### 샤딩용으로 새로운 애플리케이션 설계

애플리케이션이 처음부터 샤딩용으로 설계되는 경우입니다.  
나중에 마이그레이션하는 것보다 처음부터 샤딩하는 것이 훨씬 쉽습니다.  

샤딩이 필요한지 결정하려면 향후 4년 동안의 데이터 크기와 증가율를 추정해 보세요.  

데이터 세트가 제한이 있는지 아니면 무제한인지도 고려합니다.  
제한된 데이터 세트는 그 자체가 최대 크기이거나 본질적으로 느리게 증가합니다.  
무제한 데이터 세트(ex 사진)에는 본질적으로 제한이 없습니다.  
하드웨어 용량에는 제한이 있으므로 애플리케이션은 항상 무제한 데이터 세트를 정의할 때 제한을 둬야 합니다.  

#### 기존 애플리케이션을 샤딩으로 마이그레이션

단일 데이터베이스를 샤딩된 데이터베이스로 마이그레이션하는 방법은 샤딩 솔루션과 애플리케이션 워크로드에 따라 달라집니다.  
초기 마이그레이션은 근본적으로 첫 번째 리샤딩 잠시 후 다룰 "리샤딩"에서 해결해야 할 과제입니다.  

샤딩을 시작하려면 샤드 키와 전략을 세우고 직면하게 될 문제를 이해해야 합니다.  


### 샤드 키

샤드키는 데이터를 샤드에 매핑하기 위한 샤딩 전략과 함께 사용됩니다.  
MySQL에는 샤딩이라는 개념이 없으므로 그것에 대해 알지 못합니다.  

#### 높은 카디널리티

이상적인 샤드 키는 카디널리티가 높아 데이터가 샤드 전체에 고르게 분산됩니다.  
좋은 예는 동영상을 서비스하는 웹 사이트입니다.  

#### 참조 애플리케이션 엔티티

이상적인 샤드 키는 접근 패턴이 샤드를 교차하지 않도록 애플리케이션 엔티티를 참조합니다.  
단일 고객에 대한 모든 결제가 같은 샤드에 위치해야 하므로 고객별 샤딩이 이상적입니다.  

#### 소규모

샤드 키는 사용량이 많으므로 될 수 있는 한 작아야 합니다.  

애플리케이션에 이상적인 샤드 키를 식별하거나 생성하는 데 충분한 시간을 할애해야 합니다.  
샤드 키를 결정하는 것은 샤딩을 만드는 토대의 절반에 해당합니다.  


### 전략

샤딩 전략은 샤드 키값을 기준으로 데이터를 샤드에 매핑합니다.  
애플리케이션은 샤드 키값에 해당하는 데이터를 사용하여 쿼리를 샤드로 라우팅하는 전략을 구현합니다.  
샤드 키와 전략이 구현되면 변경하기가 매우 어려우므로 신중하게 선택해야 합니다.  

#### 해시 샤딩

해시 샤딩은 해시 알고리즘, 나머지 연산자(mod), 샤드 수(N)를 사용하여 해시 키값을 샤드에 매핑합니다.  

**일관된 해싱 알고리즘**은 N에 독립적인 일관된 해싯값을 출력합니다.  
샤드가 변경될 때 해싯값이 변경될 가능성은 여전히 있지만 훨씬 낮아집니다.  

해시 샤딩은 값을 정수로 추상화하므로 모든 샤드 키에 대해 작동합니다.  

포인트 접근은 하나의 행이 하나의 샤드에만 매핑될 수 있으므로 해시 샤딩과 잘 작동합니다.  

#### 범위 샤딩

범위 샤딩은 연속적인 키값 범위를 정의하고 각 범위에 샤드를 매핑합니다.  

| x < 10 | 10 >= x < 100 | 100 >= x < 500 |
|--------|---------------|----------------|
| 0      | 1             | 2              |

이렇게 하면 데이터를 샤드에 매핑할 때 유연성을 얻을 수 있지만, 데이터가 샤드 전체에 고르게 분산되도록 하려면 데이터 분산에 대한 상세한 지식이 필요합니다.  
데이터 분산이 변경되면 리샤딩 처리를 생각해야 합니다.  

모든 데이터를 정렬하고 범위로 나눌 수 있지만 임의 식별자와 같은 일부 데이터에는 적합하지 않습니다.  
데이터가 여러 샤드에 분배되지 않고 한 샤드에 몰립니다.  

범위 샤딩은 다음과 같은 경우에 가장 잘 작동합니다.  
- 샤드 키값의 범위는 제한적
- 범위를 결정할 수 있음
- 값의 분포를 알고 있으며 대부분 균일
- 범위와 분포는 변경되지 않을 것


#### 조회 샤딩

| .ca | .us | .mx |
|-----|-----|-----|
| 1   | 1   | 2   |

조회 샤딩은 샤드에 샤드 키값을 사용자 지정 매핑하는 것입니다.  
조회 샤딩은 가장 유연하지만 조회 테이블을 유지 관리해야 합니다.  
**조회 테이블**은 키-값 맵 역할을 합니다.  
샤드 키값은 키이고 데이터베이스 샤드는 값입니다.  

조회 테이블의 키는 단일 값 또는 범위일 수 있습니다.  
키가 범위라면 기본적으로 범위 샤딩이지만, 조회 테이블을 통해 범위를 더 잘 제어할 수 있습니다.  
범위 변경은 리샤딩을 의미합니다.  
키가 단일 값인 경우 고유 샤드 키값의 수를 관리할 수 있을 때는 조회 샤딩이 유용합니다.  


### 과제들

샤딩이 완벽하다면 한 번만 샤딩하고 모든 샤드가 같은 데이터 크기와 접근 권한을 갖게 됩니다.  
처음 샤딩할 때는 그럴 수도 있지만 계속 유지되지는 않을 것입니다.  

#### 트랜잭션

트랜잭션은 여러 샤드에 걸쳐 작동하지 않습니다.  
애플리케이션에서 2단계 커밋을 구현하는 것 외에는 근본적으로 해법이 없기 때문입니다.  

이 방해 요소는 피하는 것을 강력히 추천드립니다.  

#### 조인

SQL 문은 여러 샤드에 걸쳐 테이블을 조인할 수 없습니다.  
해법은 **교차 샤드 조인**입니다.  
복잡성과 별개로 주요 관심사는 일관성입니다.  
트랜잭션이 여러 샤드에 걸쳐 작동하지 않으므로 각 샤드의 결과에서 모든 데이터를 일관되게 볼 수 있는 것은 아닙니다.  

교차 샤드 조인은 특수한 목적의 교차 샤드 쿼리입니다.  

#### 교차 샤드 쿼리

교차 샤드 쿼리를 사용하려면 애플리케이션이 둘 이상의 샤드에 접근해야 합니다.  

교차 샤드 쿼리는 지연 시간이 발생합니다.  

샤딩이 완벽하다면 모든 애플리케이션 요청은 한 샤드에만 접근합니다.  
그것이 목표이지만 일부 애플리케이션은 효율적으로 샤딩된 경우에도 특정 요청을 수행하고자 여러 샤드에 접근해야 합니다.  
따라서 한 샤드에만 접근하려고 무리하게 노력하지 않아도 됩니다.  
교차 샤드 쿼리는 최소화해야 하지만, 애플리케이션 로직이 특정 요청에 교차 샤드 쿼리가 필요하다고 해도 이를 제거하려고 애쓰지 마세요.  

관련 문제는 **분산 쿼리**, 즉 애플리케이션이 많은 샤드에 접근해야 하는 쿼리입니다.  
애플리케이션에 분산 쿼리가 필요하지만 그렇게 할 수 없다면 샤딩은 아마도 적합한 해결책이 아니므로 접근 패턴을 변경해야 합니다.  

#### 리샤딩

리샤딩은 하나의 샤드를 둘 이상의 새 샤드로 나눕니다.  
리샤딩은 데이터 증가를 수용하는 데 필요하며, 샤드 간에 데이터를 재분산하는 데에도 사용할 수 있습니다.  
처음 샤딩할 때 추가 샤드를 감당할 수 있는 경우 최소 4년 동안의 데이터 증가에 대비해 충분한 샤드를 만드세요.  

샤딩이 더 많은 샤딩을 낳는다는 것이 샤딩의 어두운 면입니다.  

#### 재조정

재조정은 접근을 더 균등하게 분산하기 위해 데이터를 재배치합니다.  

- 해시
    - 해시 알고리즘이 자동으로 데이터를 샤드에 매핑하기 때문에 해시 샤딩으로 데이터를 재배치하는 것은 사실상 불가능합니다.
    - 애플리케이션은 먼저 조회 테이블을 확인하고, 샤드 키가 있으면 조회 테이블에 표시된 샤드를 사용, 그렇지 않으면 해싱 알고리즘을 사용하여 해결
- 범위
    - 핫 샤드를 더 작고 분리된 샤드로 나누기 위해 범위를 재정의
- 조회
    - 조회 테이블을 갱신하여 핫 데이터에 해당하는 샤드 키값을 다시 매핑

#### 온라인 스키마 변경

모든 샤드에 테이블을 변경하려면 어떻게 해야할 까요?  
각 샤드에서 OSC를 실행하지만, 문제는 여러 샤드에서 실행되도록 OSC 프로세스를 자동화하고 어떤 샤드가 변경되었는지 추적하는 것입니다.  


## 5-4 대안들

샤딩은 복잡하며 사용ㅈ아나 고객에게 직접적인 가치가 있는 것은 아닙니다.  

### NewSQL

NewSQL은 스케일아웃을 기본으로 지원하는 관계형 ACID 호환 데이터 스토리지를 나타냅니다.  
즉, 샤딩할 필요가 없는 SQL 데이터베이스입니다.  

#### 성숙함

데이터베이스 성숙도는 2가지를 의미합니다.  
- 데이터가 손실되거나 손상되지 않기에 데이터 스토리지를 신뢰할 수 있음
- 데이터 스토리지의 다양한 측면에 대한 깊은 지식이 추적되어 있음

#### SQL 호환성

NewSQL 데이터 스토리지는 SQL을 사용하지만 호환성은 크게 다릅니다.

#### 복잡한 작업

기본적으로 지원되는 스케일아웃은 분산 시스템을 통해 달성됩니다.  
이는 일반적으로 조정된 구성 요소들이 아닌 여러 가지로 다른 것들이 수반됩니다.  

#### 분산 시스템 성능

분산 시스템 고유의 대기 시간으로 인해 NewSQL 데이터 스토리지가 작동하지 않을 수 있습니다.  

#### 성능 특성

인덱스는 항상 최고의 활용을 제공하지만 분산 시스템에서 데이터가 저장되고 접근되는 방식 때문에 NewSQL 데이터 스토리지에서는 다르게 작동할 수 있습니다.  

NewSQL은 MySQL 샤딩의 대안으로 검토해야 할 유망한 기술이지만 NewSQL은 MySQL을 쉽게 대체할 수 없습니다.  

#### 미들웨어

미들웨어 솔루션은 애플리케이션과 MySQL 샤드 사이에서 작동합니다.  
샤딩의 세부 사항을 숨기거나 추상화하거나 적어도 샤딩을 더 쉽게 만들려고 시도합니다.  

- ProxySQL
- Vitess

#### 마이크로서비스

샤딩하기 전에 애플리케이션 설계와 해당 데이터를 검토하여 해당 파트가 별도 마이크로서비스로 분리되지 않는지 확인하세요.  
새로운 마이크로서비스와 해당 데이터베이스가 완전히 독립적이므로 샤딩보다 훨씬 쉽습니다.  

#### MySQL을 사용하지 마세요

샤딩 때문에 새 애플리케이션을 설계하고 있다면 다른 솔루션을 고려해 보세요.  
MySQL 샤딩은 해결된 문제이지만 결코 빠르고 쉬운 해결책은 아닙니다.  


## 요점정리

- MySQL은 샤딩을 통해 수평 확장됩니다.
- 하나의 거대한 데이터베이스보다 많은 작은 데이터베이스(샤드)를 관리하는 것이 훨씬 쉽습니다.

## 연습: 4년 적합성

데이터베이스가 매월 10GB씩 증가했다면 4년동안 '12 x 4 x 10GB = 480GB'가 됩니다.
현재 하드웨어의 MySQL은 580GB의 데이터를 쉽게 처리할 수 있으므로 샤딩할 필요가 없습니다.  




# 8.3 클래스 상속을 주의하라

## 8.3.1 클래스 상속은 문제가 될 수 있다

상속의 주요 특징 중 하나는 서브클래스가 슈퍼클래스에 의해 제공되는 모든 기능을 상속한다는 점이다.  

### 상속은 추상화 계층에 방해가 될 수 있다

슈퍼 클래스로부터 상속받은 메소드가 널리 사용될 수 있으며, 나중에는 상속 클래스를 수정할 수 없게 됨  

### 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

> 하나의 인터페이스에 대해 A와 B 두 가지 구현체가 있을 때, A에서 B 기능을 사용하지 못 하는 문제라고 이해함  
> 서비스 클래스에 대해서는 상속을 사용한 경험은 없음  
> 그 만큼 기능에 대한 충분한 분석 시간이 주어진 적이 없기 때문  
> 
> 대신에 도메인 객체나 DTO는 코드의 응집도를 높이기 위해 상속을 활용하는 편임  
> ex) abstract class CreateSlipParam  
>       ㄴ abstract class CreatePremiumReceiveSlipParam  
>           ㄴ data class CreateApprovedPremiumReceiveSlipParam  
>       ㄴ abstract class CreatePaymentSlipParam  
>           ㄴ data class CreateApprovedKakaoPayCardSlipParam  
>           ㄴ data class CreateApprovedKakaoPayMoneySlipParam  
> 
> open fun toSaveSlipParam()과 같이 전표를 저장하기 위해 SaveSlipParam으로 변환하는 메소드는 거의 동일하기 때문에 상속 받아서 사용함  
>
> 코틀린은 open 키워드가 붙은 클래스만 상속 가능, open 키워드가 붙은 메소드만 오버라이드 가능  

## 8.3.2 해결책: 구성을 사용하라

클래스를 확장하기보다는 해당 클래스의 인스턴스를 가지고 있음으로써 하나의 클래스를 다른 클래스로부터 구성한다는 것을 의미한다.  

> 인프런 토비의스프링 강의에서 데코레이터 패턴을 소개하는데, 예제 8.15와 동일한 것 같음  
> 코틀린은 by 키워드로 delegation을 제공함. KotlinDelegation.kt 참고  

### 더 간결한 추상화 계층

상속 대신 구성을 사용하면 IntFileReader 클래스가 전달이나 위임을 사용하여 명시적으로 노출하지 않는 한 CsvFileHandler 클래스의 기능이 노출되지 않는다.  

### 적응성이 높은 코드

요구 사항의 작은 변화에도 코드가 적응하지 못한다면 이런 코드를 유지하는 비용은 상당히 커질 수밖에 없다.  

## 8.3.3 진정한 is-a 관계는 어떤가?

진정으로 is-a 관계일 때조차 상속하는 것이 좋은 접근법인지에 대해서는 명확하지 않을 수 있다.  
진정한 is-a 관계가 있다 하더라도 상속은 여전히 문제가 될 수 있다는 점을 알아야 한다.  

- 취약한 베이스 클래스 문제: 슈퍼클래스가 수정되면 서브클래스가 동작하지 않을 수도 있다  
- 다이아몬드 문제: 다중상속 문제 > Java는 클래스의 다중상속을 지원하지 않음  
- 문제가 있는 계층 구조: FlyingCar는 비행기인가? 자동차인가?

- 인터페이스를 사용하여 계층 구조를 정의한다.
- 구성을 사용하여 코드를 재사용한다.

> 관계나 유스케이스가 명확한 경우에만 상속으로 얻는 이점이 있다고 생각함  
> 그 외에는 상속으로 얻는 이점이 적다고 생각하여 상속을 굳이 활용하는 편은 아님  

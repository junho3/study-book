# 10.2 좋은 단위 테스트는 어떻게 작성할 수 있는가?

단위 테스트에서 문제가 발생하면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤에 발생할 수도 있다.  

- 훼손의 정확한 감지: 코드가 훼손되면 테스트가 실패한다.
- 세부 구현 사항에 독립적: 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는 것이 이상적이다.  
- 잘 설명되는 실패: 테스트는 실패의 원인과 문제점을 명확하게 설명해야 한다.
- 이해할 수 있는 테스트 코드: 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하기 위한 것이고 테스트가 어떻게 수행되는지 이해할 수 있어야 한다.  
- 쉽고 빠르게 실행: 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.

## 10.2.1 훼손의 정확한 감지

- 코드에 대한 초기 신뢰를 준다.
- 미래의 훼손을 막아준다. : 코드 변경으로 인해 잘 돌아가던 기능이 작동하지 않는 것을 회귀라고 한다.

'코드가 훼손되면 반드시 실패한다'는 것이 반드시 ' 코드가 훼손될 때만 테스트가 실패한다'는 것을 의미하는 것은 아니다.  

테스트 대상 코드가 정상임에도 불구하고 때로는 통과하고 때로는 실패하는 테스트를 플래키라고 한다.  
보통 무작위성, 타이밍 기반 레이스 조건, 외부 시스템에 의존하는 등의 테스트의 비결정적 동작에 기인한다.  
정말 짜증나면 아예 테스트를 비활성화할 수 도 있다.  
더 이상 아무도 테스트 실패에 주의를 기울이지 않는다면 테스트가 없는 상황과 다를 바 없다.  

## 10.2.2 세부 구현 사항에 독립적

- 기능적 변화: 코드를 사용하는 모든 사람에게 영향을 미친다.
- 리팩토링: 코드를 사용하는 사람에게 영향을 미치지 않아야 한다.

기능 변경과 리팩토링을 같이 하지 말라  

> 접근 방식 B 방식으로 테스트 코드를 작성함  
> 중요한 private 메소드는 helper 메소드로 분리하여, 별도 테스트 코드를 작성함  
>
> 리팩토링은 왜 하는지 목적을 생각하고, 다른 사람에게 설명할 수 있어야 한다고 생각 함  

## 10.2.3 잘 설명되는 실패

테스트 실패가 잘 설명되도록 하는 좋은 방법 중 하나는 하나의 테스트 케이스는 한 가지 사항만 검사하고 각 테스트 케이스에 대해 서술적인 이름을 사용하는 것이다.  

## 10.2.4 이해 가능한 테스트 코드

서로 다른 테스트 케이스가 무엇을 테스트하는지 그리고 어떻게 테스트하는지 이해하고 있어야 한다.  
테스트를 코드에 대한 일종의 사용 설명서로 사용하기 때문이다.  

## 10.2.5 쉽고 빠른 실행

테스트를 빠르고 쉽게 유지해야 하는 또 다른 이유는 개발자가 실제로 테스트를 할 수 있는 기회를 극대화하기 위함이다.  

> 테스트 코드 작성에 편리함을 추구할 것인가? vs 테스트 코드 속도를 중요시할 것인가?
```
/**
 * Kotest 작성 시 MockMvc를 생성자로 넣기 위함
 * 해당 설정이 없으면 @Autowired로 구현해야함
 * 모든 Kotest에 SpringTestExtension이 추가되므로 테스트 코드 실행 속도가 느려짐
 */
object ProjectConfig : AbstractProjectConfig() {
    override fun extensions(): List<SpringTestExtension> = listOf(SpringExtension)
}

class SearchBlogControllerTest(
    private val mockMvc: MockMvc
) : DescribeSpec({
...
})

// override fun extensions(): List<SpringTestExtension> = listOf(SpringExtension)를 선언하지 않았을 때
class SearchBlogControllerTest() : DescribeSpec() {

    @Autowired
    private lateinit var mockMvc: MockMvc

    init { ... }
}
```

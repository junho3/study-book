# 3장 가비지 컬렉터와 메모리 할당 전략

## 3.1 들어가며

가비지 컬렉션의 역사는 자바보다 훨씬 오래되었다.  
동적 메모리 할당과 가비지 컬렉션 기술을 가장 처음 사용한 언어는 1960년에 MIT에서 개발된 리스프다.  

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면, 이 '자동화된' 기술을 적절히 모니터링하고 조율할 수 있어야 하기 때문이다.  

반면 자바 힙과 메서드 영역은 불확실한 게 아주 많다.  
같은 인터페이스라 해도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다.  


## 3.2 대상이 죽었는가?

### 3.2.1 참조 카운팅 알고리즘

1. 객체를 가리키는 참조 카운터를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.  
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

자바 가상 머신에서는 참조 카운팅을 쓰지 않는다.  
간단한 참조 카운팅만으로는 순환 참조 문제를 풀기 어렵다.  


### 3.2.2 도달 가능성 분석 알고리즘

오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 이용한다.  

GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다.  
시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다.  
어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 더 이상 사용할 수 없는 게 확실해 진다.  


### 3.2.3 다시 참조 이야기로

```
- 강한 참조
 - Object obj = new Object()
- 부드러운 참조
  - SoftReference<Object> softRef = new SoftReference<>(new Object());
  - 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다.
  - 캐시
- 약한 참조
  - WeakReference<Object> weakRef = new WeakReference<>(new Object());
  - 약한 참조뿐인 객체는 다음 가비지 컬렉션까지만 살아 있다.
  - 캐시, 리소스 관리
- 유령 참조
  - 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.
  - 네이트브 리소스 관리(예: 파일 핸들, 소켓 등)에서 사용되며, 객체가 수거되기 전에 리소스를 해제해야 할 대 유용하다.
```

> [Java] 참조 타입(Reference Type) : Strong Reference, Soft Reference, Weak Reference, Phantom Reference  
> https://lifework-archive-reservoir.tistory.com/m/324


### 3.2.4 살았나 죽었나?

도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다.  
필터링 조건은 `finalize() 메서드를 실행해야 하는 객체인가`이다.  

finalize()를 실행해야 하는 객체로 판명되면 F-큐라는 대기열에 추가된다.  

다시 말하지만 가능한 finalize()를 사용하지 말자.  
실행하는 비용도 높고 불확실성도 크다.  

finalize()로 할 수 있는 일은 전부 try finally 등의 다른 방법으로 제때 더 잘 처리할 수 있다.  


### 3.2.5 메서드 영역 회수하기

메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다.  
더 이상 사용되지 않는 `상수`와 `클래스`다.  

더 이상 쓰이지 않는 '클래스'인지 판단하는 조건은 더 까다롭다.  
다음 세 조건을 동시에 만족해야 한다.  

- 자바 힙에 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 이 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.


## 3.3 가비지 컬렉션 알고리즘

참조 카운팅 GC 알고리즘은 주류 자바 가상 머신들에서는 사용하지 않기 때문에 이번 절에서 소개할 알고리즘들은 모두 추적 GC에 속한다.

### 3.3.1 세대 단위 컬렉션 이론

한 번 살아남은 객체는 통계적으로 잘 죽지 않으니 다른 영역에 따로 모아 두고, 가상 머신이 그 영역을 회수하는 빈도를 줄이는 것이다.  
이렇게 하면 가비지 컬렉션에 드는 전체 시간도 줄고 메모리 공간도 효율적으로 이용할 수 있다.  

자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC, 메이저 GC, 전체 GC식으로 부르곤 한다.  

- 부분 GC: 자바 힙의 일부만 회수
  - 마이너 GC: Young Generation 대상 (Eden, Survivor1, Survivor2)
  - 메이저 GC: Old Generation 대상 (Old)
  - 혼합 GC: Young Generation 전체와 Old Generation 일부를 대상
- 전체 GC: 자바 힙 전체와 메서드 영역까지 모든 대상


### 3.3.2 마크-스윕 알고리즘

먼저 회수할 객체들을 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다.  

마크-스윕 알고리즘의 큰 단점은 두 가지다.  
첫째, 실행 효율이 일정하지 않다. 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어진다.  
둘째, 메모리 파편화가 심하다. 그 결과 또 다른 가비지 컬렉션을 유발한다.  


### 3.3.3 마크-카피 알고리즘

가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다.  
한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다.  

가용 메모리를 절반으로 줄여 낭비가 제법 심하다는 점이다.  
상용 자바 가상 머신 대부분은 Young Generation에 이 알고리즘을 활용한다.  


### 3.3.4 마크-컴팩트 알고리즘

생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.  

이런 식의 객체 이동은 사용자 애플리케이션을 모두 멈춘 상태에서 진행해야 하므로 아주 신중하게 고려해야 할 단점이다.  
이와 같은 일시 정지 현상을 'Stop the world'라는 말로 아주 생생하게 표현해 냈다.  

객체를 이동시킬 때와 아닐 때 모두 단점이 있다.  
객체를 이동시키면 회수 작업이 복잡해지고, 이동시키지 않으면 할당 작업이 복잡해진다.  

메모리를 할당하고 접근하는 빈도가 가비지 컬렉션 수행 빈도보다 훨씬 많으므로 할당과 접근 효율이 떨어지면 전체적인 처리량은 여전히 나빠진다.  


## 3.4 핫스팟 알고리즘 상세 구현

### 3.4.1 루트 노드 열거

루트 노드 열거란 도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업을 말한다.  
GC 루트로 고정할 수 있는 노드는 주로 전역 참조와 실행 콘텍스트에 존재한다.  

로트 노드 열거만큼은 반드시 일관성이 보장되는 스냅숏 상태에서 수행해야 한다.  
루트 노드들의 참조 관계가 변하지 않아야 한다는 말이다.  

이것이 가비지 컬렉션 시 모든 사용자 스레드가 일시 정지해야 하는 이유다.


### 3.4.2 안전 지점

핫스팟은 OopMap을 활용하여 GC 루트들을 빠르고 정확하게 열거할 수 있다.  
참조 관계나 OopMap의 내용을 변경할 수 있는 명령어가 많으며, 이런 명령어 모두에 OopMap을 만들어 넣으면 메모리를 더 많이 사용해야 한다.  

그래서 핫스팟은 모든 명령어 각각에 OopMap을 생성하지는 않는다.  
그 대신 안전지점이라고 하는 특정한 위치에만 기록한다.  
가비지 컬렉터는 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈춰 세우지 않는다.  

'장시간 실행'될 가능성을 보여주는 메서드 호출, 순환문, 예외 처리 등에서 안전 지점을 생성한다.  

선제적 멈춤 방식에서는 스레드의 코드가 가비지 컬렉터를 특별히 신경 쓸 필요가 없다.  
가비지 컬렉션이 실행되면 시스템이 모든 사용자 스레드를 인터럽트한다.  
안전 지점이 아니라면 스레드를 재개하고 안전 지점에 도달할 때까지 인터럽트를 반복한다.  

자발적 멈춤 방식에서는 가비지 컬렉터가 스레드 수행에 직접 관여하지 않는다.  
간단한 플래그 비트를 설정하고, 각 스레드가 실행 중에 플래그를 적극적으로 폴링한다.  
플래그 값이 true면 가장 가까운 안전 지점에서 스스로 멈춘다.  


### 3.4.3 안전 지역

실행 중이 아닌 프로그램(스레드)는 인터럽트 요청에 응답할 수 없고, 안전 지점까지 수행한 후 인터럽트되어 스스로를 일시 정지시킬 수 없다.  
또한 이런 스레드가 다시 활성화될 때까지 무한정 기다리는 것도 말이 안 된다.  

안전 지역은 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장한다.  
안전 지역 안이라면 어디서든 가비지 컬렉션을 시작해도 무방하다는 뜻이다.  

안전 지역에서 벗어나려는 스레드는 가상 머신이 루트 노드 열거를 완료했는지 또는 사용자 스레드를 일시 정지시켜야 하는 다른 가비지 컬렉션 단계를 완료했는지 확인한다.  


### 3.4.4 기억 집합과 카드 테이블

기억 집합은 비회수 영역에서 회수 영역을 가리키는 포인터들을 기록하는 추상 데이터 구조다.  
가비지 컬렉션 시 컬렉터는 기억 집합을 이용해 특정 비회수 영역에서 회수 영역을 가리키는 포인터가 존재하는지만 확인하면 된다.  

- 위드 정밀도
- 객체 정밀도
- 카드 정밀도

카드 테이블과 기억 집합의 관계는 자바 언어에서 HashMap과 Map의 관계 정도로 이해하며 좋을 것이다.  

이 객체들 중 하나에라도 세대 간 포인터를 갖는 필드가 있다면, 카드 테이블에서의 해당 원소를 1로 표기하고, 그 원소는 '더럽혀졌다'고 말한다.  
세대 간 포인터를 갖는 객체가 하나도 없다면 0으로 표시된다.  

그리고 객체를 회수할 때는 카드 테이블에서 더럽혀진 원소만 확인하면 어떤 카드 페이지의 메모리 블록이 세대 간 포인터를 포함하는지 쉽게 파악할 수 있다.  


### 3.4.5 쓰기 장벽

다른 세대의 객체가 현 블록 안의 객체를 참조하면 카드 테이블의 해당 원소가 더럽혀진다.  

핫스팟 가상 머신은 쓰기 장벽 기술을 이용해 카드 테이블을 관리한다.  
쓰기 장벽은 가상 머신 수준에서 '참조 타입 필드 대입'시 끼어드는 AOP 애스팩트에 비유할 수 있다.  
대입 전  쓰기 장벽을 사전 쓰기 장벽이라 하며, 대입 후 쓰기 장벽을 사후 쓰기 장벽이라 한다.  

컬렉터가 쓰기 장벽으로 카드 테이블 갱신 연산을 추가한다면 참조가 갱신될 때마다 오버헤드가 더해진다.  
그래도 마이너 GC 때 구세대 전체를 스캔하는 비용보다는 훨씬 저렴하다.  

쓰기 장벽에 의한 오버헤드 말고도, 카드 테이블은 멀티스레드 시나리오에서 `거짓 공유 문제`를 일으킬 수 있다.  
실제로는 공유하고 있지 않음에도 마치 공유하는 것처럼 서로 영향을 준다고 하여 이를 거짓 공유 문제라고 한다.  

거짓 공유 문제는 쓰기 장벽을 조건부로 사용하여 간단히 피할 수 있다.  
카드 테이블을 먼저 확인하여 원소가 더럽혀지지 않았을 때만 더럽히는 것이다.  


### 3.4.6 동시 접근 가능성 분석

OopMap 같은 다양한 최적화 기법 덕에 스레드가 멈춰 있는 시간은 매우 짧으며 상대적으로 일정하다.  

루트 노드 열거가 끝나면 가비지 컬렉터는 GC 루트로부터 객체 그래프를 탐색할 수 있다.  
힙이 클수록 더 많은 객체를 담게 되고 객체 그래프 구조도 복잡해진다.  
더 많은 객체를 확인해 표시하려면 일시 정지 시간은 당연히 길어진다.  

표시 단계의 일시 정지 시간이 힙 크기에 비례해 증가한다면 거의 모든 가비지 컬렉터에 악영향을 준다는 뜻이다.  

사용자 스레드의 일시 정지 문제를 해결하거나 줄이고 싶다면 일관성이 보장되는 스냅숏 상태에서 객체 그래프를 탐색해야 하는 이유를 먼저 파악해야 한다.  
삼색 표시 기법을 활용해 이 문제를 명확히 설명해 보겠다.  

- 흰색: 가비지 컬렉터가 방문한 적 없는 객체
- 검은색: 가비지 컬렉터가 방문한 적이 있으며, 이 객체를 가리키는 모든 참조 스캔
- 회색: 가비지 컬렉터가 방문한 적 있으나, 스캔을 완료하지 않은 참조 존재

컬렉터가 객체 그래프에 색을 칠해 가는 도중에 사용자 스레드가 참조 관계를 변경하면 두 가지 결과를 가져올 수 있다.  
첫째, 죽은 객체를 살았다고 잘못 표시할 수 있다.  
둘째, 살아 있는 객체를 죽었다고 표시할 수 있다.  

첫 번째 조건을 깨뜨려 주는 증분 업데이트는 검은색 객체에 흰색 객체로의 참조가 추가되면 추가된 참조를 따로 기록해 둔다.  
그리고 동시 스캔이 끝난 후 기록해 둔 검음색 객체들을 루트로 하여 다시 스캔한다.  

시작 단계 스냅숏은 두 번째 조건을 깨뜨려 준다.  
이번에는 회색 객체가 흰색 객체로의 참조 관계를 끊으려 하면 그 사실을 기록한다.  
동시 스캔이 끝난 후 기록해둔 회색 객체들을 루트로 하여 다시 스캔한다.  


## 3.5 클래식 가비지 컬렉터

자바 가상 머신 명세는 가비지 컬렉터를 어떻게 구현해야 하는지 규정하지 않았다.  
그래서 가상 머신 업체나 버전에 따라 다른 가비지 컬렉터를 제공한다.  

가비지 컬렉터 기술은 계속 발전 중이며, 아직까지 '최고'라거나 '만능'인 가비지 컬렉터는 등장하지 않았다.  

### 3.5.1 시리얼 컬렉터

시리얼 컬렉터는 가장 기초적이고 오래된 컬렉터로, '단일 스레드'로 동작한다.  
가비지 컬렉션이 시작되면 회수가 완료될 때까지 다른 모든 작업 스레드가 멈춰 있어야 한다.  
다른 컬렉터의 단일 스레드 알고리즘보다 간단하고 효율적이라는 이점이 있다.  
요구하는 메모리 사요얄잉이 가장 적다.  
온전히 가비지 컬렉션에 집중하므로 회수 효율을 최대로 끌어낸다.  


### 3.5.2 파뉴 컬렉터

파뉴 컬렉터는 여러 스레드를 활용하여 시리얼 컬렉터를 병렬화한 버전이다.  
여러 스레드를 사용한 병렬 회수 외에 시리얼 컬렉터보다 나아진 점은 딱히 없다.  

```
병렬: GC 스레드 다수가 동시에 함께 작업 수행. 보통 이때 사용자 스레드는 정지 상태
동시: GC 스레드와 사용자 스레드가 동시에 일을 진행.
```


### 3.5.3 패러렐 스캐빈지 컬렉터

마크-카피 알고리즘에 기초하며 여러 스레드를 이용해 병렬로 회수하는 등, 많은 면에서 파뉴 컬렉터와 닮았다.  
처리량을 제어하는 게 목표다.  

사용자와 상호 작용하거나 응답 속도를 보장해야 하는 Qos 프로그램이라면 정지 시간이 짧을수록 좋다.  

컬렉터는 메모리 회수에 소요되는 시간이 `-XX:MaxGCPauseMillis` 설정값을 넘지 않도록 최선을 다할 것이다.  


### 3.5.4 시리얼 올드 컬렉터

시리얼 컬렉터의 구세대용 버전이다.  
단일 스레드 컬렉터이며 마크-컴팩트 알고리즘을 쓴다.  
주로 클라이언트용 핫스팟 가상 머신에서 사용한다.  


### 3.5.5 패러렐 올드 컬렉터

PS 컬렉터의 구세대용 버전이다.  
멀티스레드를 이용한 병렬회수를 지원하며 마크-컴팩트 알고리즘을 기초로 구현되었다.  


### 3.5.6 CMS 컬렉터

표시와 쓸기 단계 모두를 사용자 스레드와 동시에 수행한다.  
CMS 컬렉터의 목적은 가비지 컬렉션에 따른 일시 정지 시간을 최소로 줄이는 것이다.  
이 분야에서는 서비스 응답 시간이 중요하므로 시스템의 일시 정지 시간이 짧아야 사용자에게 더 나은 경험을 선사할 수 있다.  

전체 과정은 네 단계로 구성된다.  
- 최초 표시(스탑 더 월드): GC 루트와 직접 연결된 객체들만 표시
- 동시 표시:GC 루트와 연결된 객체들로부터 시작해 객체 그래프 전체 탐색
- 재표시(스탑 더 월드): 둉시 표시 도중 사용자 스레드가 참조 관계를 변경한 객체들을 바로잡는다.  
- 동시 쓸기: 앞의 세 가지 표시 단계에서 죽었다고 판단한 객체들을 쓸어 담는다.

중요한 특성은 전체 과정 중 가장 긴 동시 표기와 동시 쓸기 단계에서 사용자 스레드를 멈추지 않는다는 것이다.  
가장 큰 이점인 동시 회수 능력 덕분에 정지 시간이 매우 짧다.  

다음과 같은 세 가지 단점이 남아있다.  

첫째, CMS는 프로세서 자원에 아주 민감하다.  
동시 수행 단계에서 사용자 스레드를 멈추지는 않더라도 애플리케이션을 느리게 하고 전체 처리량을 떨어뜨리는 건 피할 수 없다.  

두 번째 단점은 CMS가 부유 쓰레기를 처리하지 못해서 동시 모드 실패를 유발할 가능성이 있다는 것이다.  
동시 표기와 동시 쓸기 단계 동안 사용자 스레드는 여전히 실행 중이다.  
그래서 어떤 객체는 표시 스레드가 지나간 후에 쓰레기가 될 수도 있다.  
이런 객체는 쓸기 단계에서 회수할 수 없다.  
어쩔 수 없이 다음번 컬렉션까지 기다려야 한다.  

가비지 컬렉션 단계 동안 사용자 스레드는 계속 일을 해야 하므로 사용자 스레드가 사용할 메모리 공간이 충분히 확보되어야 한다.  

세 번째 단점은 마크-스윕 알고리즘이다.  
이 알고리즘은 회수 작업 끝에 상당한 파편화를 일으킨다.  
파편화가 심하면 큰 객체를 할당할 때 특히 문제가 된다.  


### 3.5.7 G1 컬렉터(가비지 우선 컬렉터)

'G1'은 'Garbage First'를 짧게 줄인 표현이다.  
G1은 부분 회수라는 컬렉터 설계 아이디어와 리전을 회수 단위로 하는 메모리 레이아웃 분야를 개척했다.  

G1은 서버용 애플리케이션에 집중한 컬렉터다.  

G1 설계자들은 정지 시간 예측 모델을 만들고자 했다.  
정지 시간 예측 모델은 목표 시가늘 M밀리초로 설정하면 가비지 컬렉터가 쓰는 시간이 M밀리초가 넘지 않도록 통제하는 것이다.  

G1은 힙 메모리의 어느 곳이든 회수 대상에 포함할 수 있다.  
`어느 세대에 속하느냐`가 아니라 `어느 영역에 쓰레기가 가장 많냐`와 `회수했을 때 어디가 이득이 어디가 가장 크냐`가 회수 영역을 고르는 기준이 된 것이다.  
이것이 G1의 혼합 GC모드다.  

하지만 힙 메모리 레이아웃은 다른 컬렉터와 매우 다르다.  
G1은 크기와 수가 고정된 세대 단위 영역 구분에서 벗어나, 연속된 자바 힙을 동일 크기의 여러 독립 리전으로 나눈다.  
각 리전은 필요에 따라 신세대의 에덴이나 생존자 공간이 될 수도, 구세대용 공간으로 쓰일 수도 있다.  

한편 '큰' 객체를 저장하기 위해 거대 리전이라는 특별한 유형도 활용한다.  

G1에서 정지 시간 예측 모델이 가능한 이유는 리전을 최소 회수 단위로 사용하기 때문이다.  

G1은 각 리전의 쓰레기 누적값을 추적한다.  
그리고 우선순위 목록을 관리하며 사용자가 `-XX:MaxGCPauseMillis` 매개 변수로 설정한 일시 정지 시간이 허용하는 한도 내에서 회수 효과가 가장 큰 리전부터 회수하는 것이다.  

실제로 G1이 해결해야 했던 주된 문제 몇 개를 살펴보자.  

첫째, 자바 힙을 다수의 독립된 리전으로 나눈다면 객체들의 리전 간 참조 문제를 해결해야 한다.  
둘째, 동시 표시 단계 동안 GC 스레드와 사용자 스레드가 서로 간섭하지 않도록 보장해야 한다.  
셋째, 신뢰할 수 있는 정지 시간 예측 모델을 구현해야 한다.  

사용자 스레드가 실행되는 동안 수행하는 작업을 제외한다면 G1의 동작은 대략 다음 네 단계로 나뉜다.  
- 최초 표시: GC 루트가 직접 참조하는 객체들을 표시하고 TAMS 포인터의 값을 수정
- 동시 표시: GC 루트로부터 시작하여 객체들의 도달 가능성을 분석하고, 전체 힙의 객체 그래프를 재귀적으로 스캔하며 회수할 객체를 찾음
- 재표시: 시작 단계 스냅숏 이후 변경된 소수의 객체만 처리
- 복사 및 청소: 회수할 리전들을 선별하고 선별된 리전들에서 살아남은 객체들을 빈 리전에 이주 시킴

G1 컬렉터는 동시 표시 단계를 제외하고는 사용자 스레드를 멈춰야 한다.  

또한 G1의 최우선 목표가 짧은 지연 시간이 아님을 생각하면, 사용자 스레드를 일시 정지함으로써 회수 효율을 극대화한다는 선택이 이해된다.  
처리량을 보장하기 위해 사용자 스레드를 완전히 멈춰 세우기로 한 것이다.  

정지 시간의 기댓값을 사용자가 설정할 수 있다는 건 G1의 매우 큰 장점이다.  
목표 시간이 너무 짧다면 힙 메모리의 아주 적은 일부만 회수하고 컬렉션을 마쳐야 한다.  
그 여파로 회수 속도가 새로 할당되는 속도를 따라잡지 못하여 쓰레기가 점차 쌓여 간다.  

| CMS                     | G1                                                   |
|-------------------------|------------------------------------------------------|
| 마크-스윕                   | 마크-컴팩트, 마크-카피                                        |
| 메모리를 적게 사용              | 메모리를 많이 사용하고, 오버헤드가 큼                                |
| 카드테이블이 단순               | 신세대, 구세대 상관없이 모든 리전이 카드 테이블을 가져야 함                   |
| 사후 쓰기 장벽 이용             | 사후 쓰기 장벽 이용                                          |
|                         | 시작 단계 스냅숏 알고리즘 구현으로 동시 작업 시에 사전 쓰기 장벽을 이용하여 참조 변경 추적 |
|                         | 동시 표시와 재표시 단계의 자원 소비가 적음                             |
| 메모리를 적게 사용하는 애플리케이션에 유리 | 메모리를 많이 사용하는 애플리케이션에 유리                              |


### 3.5.8 오늘날의 가비지 컬렉터들

가장 큰 특징은 신세대용과 구세대용의 구분이 사라졌다는 점이다.  
'어떤 조합이 최선일까'하는 큰 고민거리가 사라졌다.  


## 3.6 저지연 가비지 컬렉터

핫스팟의 가비지 컬렉터는 시리얼에서 CMS로, 다시 G1으로 진화해 왔다.  

가비지 컬렉터를 측정하는 가장 중요한 지표는 처리량, 지연 시간, 메모리 사용량이다.  
세 지표 중 지연 시간의 중요성이 점점 커지고 있다.  

메모리를 늘리면 지연 시간에는 악영향을 준다.  
힙 메모리 1TB를 청소하려면 1GB를 청소할 때보다 오래 걸리는게 당연하다.  

CMS 등장 전에는 모든 과정이 '스탑 더 월드'였다.  
CMS와 G1은 차례로 증분 업데이트와 시작 단계 스냅숏 기술을 적용해 표시 단계를 동시에 수행하기 시작했다.  
하지만 표시 단계 이후의 처리는 제대로 해결하지 못 했다.  


### 3.6.1 셰넌도어

**셰넌도어는 오라클 JDK에는 없고 다른 회사의 OpenJDK에만 존재하는 컬렉터다.**  

셰넌도어 프로젝트의 목표는 힙 크기와 상관없이 가비지 컬렉션으로 인한 일시 정자를 10밀리초 이내로 묶어 두는 것이다.  
셰넌도어는 표시 단계는 물론 객체 회수 후 마무리 작업까지 사용자 스레드와 동시에 수행해야 했다.  

#### 개선 사항

첫째, 모으기 단계를 사용자 스레드와 동시에 병렬로 수행한다.  

둘째, JDK 21까지의 셰넌도어는 세대 단위 컬렉션을 사용하지 않는다.  

마지막으로 메모리와 컴퓨팅 자원을 많이 사용하는 기억 집합 대신 '연결 행렬'로 리전 간 참조 관계를 기록한다.  
그 덕분에 관리 비용도 줄고 거짓 공유 문제가 발생할 가능성도 줄었다.  

#### 동작 방식

1. 최초 표시: GC 루트에서 직접 참조하는 객체들에 표시 (스탑 더 월드)
2. **동시 표시: 객체 그래프를 타고 힙을 탐색하며 도달 가능한 모든 객체를 표시**
3. 최종 표시: 보류 중인 모든 표시를 완료하고 GC 루트 집합을 다시 스캔
4. 동시 청소: 살아있는 객체가 없는 리전들을 청소
5. **동시 이주: 회수 집합 안에 살아 있는 객체들을 다른 빈 리전으로 복사**
6. 참조 갱신: 옛 객체를 가리키는 모든 참조를 복사(동시 이주) 후의 새로운 주소로 수정
   1. 최초 참조 갱신
   2. **동시 참조 갱신**
   3. 최종 참조 갱신
7. 동시 청소: 새로운 객체를 할당할 공간 확보

#### 동시 이주의 핵심, 포워딩 포인터

기존에는 옛 객체가 저장된 메모리 공간에 접근하려 하면 트랩이 발동하여 예외 처리기가 실행된다.  
그리고 이 처리기에서 복사된 새 객체를 사용하게끔 하는 것이다.  
객체 이동과 사용자 스레드를 동시에 실행하는 방법이다.  
사용자 모드와 커널 모드를 수시로 전환해야 해서 비용이 큰 해법이었다.  

브룩스는 메모리 보호 토랩을 사용하지 않는 새로운 해법을 제안했다.  
바로 원래의 객체 레이아웃 구조 상단에 참조 필드를 하나 추가한다.  
동시 이주가 아닌 경우에는 참조 필드가 객체 자신을 가리킨다.  

차이는 핸들 방식은 보통 여러 핸들을 하나의 핸들 풀에 모아 두는 반면, 포워딩 포인터는 각 객체의 헤더 앞에 흩어 놓는다는 점이다.  
우회하여 접근하는 오버헤드가 결국 각 객체 모두에 더해진다.  

포워딩 포인터가 가져다주는 이점은 포인터 하나의 값만 수정하면 끝이라는 것이다.  
이렇게 해서 옛 객체가 아직 회수되지 않았더라도 기존 참조를 통해 자동으로 새로운 객체로 포워딩된다.  

사용자 스레드가 옛 객체를 변경하는 것을 막기 위해 GC 스레드와 사용자 스레드 중 하나만 포워딩 포인터에 접근할 수 있고, 다른 스레드는 순서를 기다려야 한다.  

'객체로의 접근'에 속하는 동작을 모두 보호하려면 세넌도어는 이 작업 모두에 읽기 장벽과 쓰기 장벽을 동시에 설정해야 한다.  

#### 계속되는 개선

- 로드 참조 장벽 도입
- 포워딩 포인터를 객체 헤더에 통합
  * 포인터 하나가 별거 아닌 것 같지만, 포워딩 포인터 때문에 셰넌도어는 다른 가비지 컬렉터보다 메모리를 5~10% 더 소비하고 있었다.
  * 같은 공간에 더 많은 객체를 담을 수 있어서 가비지 컬렉션 수행 횟수가 줄어든다.
  * CPU 캐시에 더 많은 객체를 담을 수 있어서 캐시 적중룔이 높아진다.
  * 다른 가비지 컬렉터들과 객체 할당 코드를 공유할 수 있어서 구현 로직이 단순해 진다.
- 스택 워터마크를 활용한 스레드 스택 동시 처리

#### 실전 성능

다른 컬렉터들보다 일시 정지 시간은 극적으로 줄였지만, '최장 정지 시간을 10밀리초 이내로 제어하겠다'는 목표와는 거리가 있다.  


### 3.6.2 ZGC

ZGC와 셰넌도어의 목표는 아주 흡사하다.  
둘 다 처리량에 미치는 영향을 최소로 엊게하면서 힙 크기에 상관없이 가비지 컬렉션으로 인한 일시 정지 시간을 10밀리초 안쪽으로 줄이고자 했다.  

하지만 구현 방향은 사뭇 달랐다.  

- 세대 구분 없이 리전 기반 메모리 레이아웃을 사용한다.
- 낮은 지연 시간을 최우선 목표로 한다.
- 마크-컴팩트 알고리즘을 구현하기 위해 읽기 장벽, 컬러 포인터, 메모리 다중 맵핑 기술을 이용한다.

#### 리전 기반 메모리 레이아웃

셰넌도어와 G1처럼 ZGC도 힙 메모리를 리전들로 나누지만 차이가 있다.  
ZGC의 리전은 동적으로 생성/파괴된다.  
크기도 대,중,소 3가지로 동적으로 달라진다.  

#### 병렬 모으기와 컬러 포인터

ZGC를 상징하는 설계는 컬러 포인터 기술이다.  

컬러 포인터는 포인터 자체에 소량의 추가 정보를 직접 저장하는 기술이다.  

컬러 포인터는 메모리 용량이 제한되고, 32비트 플랫폼에서는 동작하지 않으며, 압축 포인터 같은 여러 기술을 지원할 수 없다.  
하지만 장점도 아주 크다.  

한 리전 안의 생존 객체들이 이동하면 그 즉시 해당 리전을 재활용할 수 있다.  
전체 힙에서 해당 리전으로의 참조들을 전부 수정할 때까지 기다릴 필요가 없다는 뜻이다.  
그에 반해 셰넌도어는 참조 갱신 단계가 끝나기 전에는 회수 중인 리전을 재활용하지 못한다.  

가바지 컬렉션 과정에서 메모리 장벽의 수를 크게 줄일 수 있다.  

컬러 포인터를 객체 표시 및 재배치와 관련해 더 많은 정보를 담을 수 있는 확장 가능한 저장 구조로 쓸 수 있다.  
현재 리눅스에서는 64비트 포인터의 상위 16비트를 사용하지 않는다.  
주소 지정에는 쓸 수 없지만 다른 정보를 저장하는 용도로는 쓸 수 있다.  


#### ZGC의 동작 방식

ZGC의 동작은 크게 네 단계로 나뉜다.  
네 단계 모두 사용자 스레드와 동시에 실행되지만, 사이사이에 사용자 스레드를 일시 정지시키는 작은 단계가 있다.  

1. 동시 표시: G1과 셰넌도어처럼 객체 그래프를 탐색하며 도달 가능성을 분석하는 단계다.
2. 동시 재배치 준비: 청소해야 할 리전들을 선정하여 재배치 집합을 만든다.
3. 동시 재배치: 재배치 집합 안의 생존 객체들을 새로운 리전으로 복사한다. 컬러 포인터 덕분에 ZGC는 객체가 재배치 집합에 속하는지 참조만 보고 바로 알 수 있다.  
4. 동시 재매핑: 힙 전체에서 재배치 집합에 있는 옛 객체들을 향하는 참조 전부를 갱신한다.

#### 다른 컬렉터들과의 비교

| G1                                   | ZGC                      |
|--------------------------------------|--------------------------|
| 세대 간 참조와 리전들의 점진적 회수 처리를 위해 기억 집합 활용 | 기억 집합을 사사용하지 않음          |
| 기억 집합 관리에 쓰기 장벽 사용                   | 세대 구분이 없어서 카드 테이블도 필요 없음 |
| 기억 집합은 메모리 공간을 상당히 차지                | 쓰기 장벽 사용하지 않음            |

ZGC의 선택은 객체 할당 속도를 제한하는 결과로 이어졌다.  
객체 할당 속도가 너무 빨라서 아주 많은 객체가 새로 만들어진다고 해 보자.  
객체가 너무 많으면 현 회수 단계에서는 다 표시 하기 어려워 대부분 살아남을 것이다.  
애플리케이션이 대량의 객체를 새로 만드는 일을 계속한다면, 각각의 동시 회수 주기가 매우 길어질 것이고, 회수되는 메모리 공간이 같은 기간에 만들어지는 부유 쓰레기보다 적어질 것이다.  
힙의 여유 공간은 계속 줄어들어 고갈될 것이다.  

> G1은 API, ZGC는 배치에 적합하다고 들었는데, 그 이유인 듯  

이 문제의 유일한 해법은 힙 크기를 최대한 늘리는 것이다.  
하지만 ZGC가 감당할 수 있는 객체 할당 속도를 근본적으로 끌어올리고 싶다면 세대 단위 컬렉션을 도입해야 한다.  
그래서 새로운 객체들을 특별한 영역에 생성하고, 이 영역들을 더 자주 빠르게 회수해야 한다.  


### 3.6.3 세대 구분 ZGC

세대를 구분해서 얻는 가장 큰 이점은 수명이 짧은 젊은 객체들을 더 자주 회수한다는 것이다.  

초기 ZGC와 셰넌도어에서 세대를 구분하지 않은 이유는 구현 복잡도 때문이다.  

약한 세대 가설에 따라 점은 객체들만 대상으로 하면 더 적은 노력으로 더 많은 메모리 공간을 확보할 수 있다.  

세대 구분 ZGC는 ZGC에 적용된 컬러 포인터와 읽기 장벽을 그대로 계승하고 있다.  
여기에 더해 세대 간 참조를 효율적으로 추적하기 위해 쓰기 장벽도 활용한다.  
세대 구분 ZGC의 컬러 포인터에는 새로운 메타데이터를 추가했다.  
그리고 쓰기 장벽은 이 데이터를 확인하여 현재 값이 써지는 필드가 세대 간 참조를 포함하는지 알 수 있다.  

읽기 장벽에서 수행하던 도달 가능 객체 표시 작업을 쓰기 장벽으로 옮겨왔다.  
일반적으로 쓰기보다 읽기가 훨씬 많이 수행되기 때문에 이 역시 전체 작업량을 상당히 줄여 준다.  

#### 다중 매핑 메모리 제거

세대 구분 ZGC는 읽기 장벽과 쓰기 장벽의 코드를 명확히 구분한다.  
컬러 포인터에서 다중 매핑 관련 메타데이터 비트들이 제거되니, 확보된 비트를 다른 용도로 활용할 수있다.  

#### 이중 버퍼를 이용한 기억 집합 관리

세대 구분 ZGC는 비트맵을 이용해서 객체 필드의 위치를 정확하게 기록한다.  
비트맵 하나는 애플리케이션 스레드들의 쓰기 장벽에서 수정하게 되며, 그 읽기 전용 복사본인 다른 비트맵은 GC 스레드가 참조한다.  
그리고 마이너 GC가 시작될 때마다 두 비트맵으 원자적으로 교환한다.  

#### 밀집도 기반 리전 처리

세대 구분 ZGC는 어느 리전부터 회수해야 할지 정하기 위해 신세대 리전들의 밀집도를 분석한다.  

#### 거대 객체 처리

세대 구분 ZGC에서는 거대한 객체도 신세대에 바로 할당한다.  
하지만 살아남은 거대한 객체를 구세대로 재배치하는 비용은 걱정할 필요가 없다.  
객체 재배치 없이 리전을 노화시킬 수 있기 때문이다.  


## 3.7 적합한 가비지 컬렉터 선택하기

### 3.7.1 엡실론 컬렉터

엡실론은 가비지 컬렉션을 전혀 하지 않는 컬렉터다.  

가비지 컬렉터의 영향을 배제해야 하는 성능 테스트나 스트레스 테스트에도 이용된다.  

단 몇 분 또는 몇 초만 동작하는 애플리케이션이라면 힙이 가득 차기 전에 일을 마칠 것이다.  
앱실론은 동작 부하가 아주 적고 메모리 회수 활동을 전혀하지 않기 때문에 이런 환경에 안성맞춤이다.  


### 3.7.2 컬렉터들 간 비교 및 취사선택

각자 애플리케이션에 맞는 컬렉터는 어떻게 선택해야 할까?

- 애플리케이션의 주목적이 무엇인가?
  - 처리량 ...
- 애플리케이션을 구동하는 서브시스템은 무엇인가?
  - 32bit, 64bit, cpu 개수, 메모리 용량, OS ..
- JDK 제공자는 어디인가?

브라우저-서버 시스템의 최고 관심사는 지연 시간이며, 다음과 같은 흐름으로 선택하면 된다.  

- 자금 사정은 여유로우나 최적화 경험이 부족하다면
  - Azul C4
- 상용 제품을 쓸 형편은 못 되나 소프트웨어와 하드웨어 모델을 제어할 능력이 된다면
  - 최신버전
- 레거시 시스템
  - 힙 메모리가 4~6GB 이하라면 CMS
  - 그 이상이면 G1
- 최대 100MB의 작은 데이터를 다루는 애플리케이션
  - 시리얼 컬렉터
- 애플리케이션이 단일 프로세서만 사용하고 일시 정지 시간 관련 제약이 없다면
  - 시리얼 컬렉터
- 애플리케이션의 최대 성능이 가장 중요하고, 지연 시간 제약이 없거나 1초 이상이라면
  - 기본 컬렉터나 패러렐 컬렉터
- 처리량보다 응답 시간이 중요하고 가비지 컬렉션에 따른 일시 정지가 짧아야 한다면
  - G1
- 응답 시간이 매우 중요하면
  - 세대구분 ZGC

> GPT 추천

| GC 종류         | 주요 특징                            | 적용 사례               |
|---------------|----------------------------------|---------------------|
| Serial GC     | 단일 스레드로 GC 작업 수행, 메모리 효율         | 작은 힙, 단일 스레드 환경     |
| Parallel GC   | 멀티스레드 GC, 처리량 중심                 | 대규모 데이터 처리, 배치 작업   |
| CMS GC        | 오래된 GC, 낮은 지연 시간, Java 8 이하에서 사용 | 낮은 지연 시간 애플리케이션     |
| G1 GC         | 적당한 지연 시간과 처리량, Java 9 기본 GC     | 대규모 웹 애플리케이션        |
| ZGC           | 매우 낮은 지연 시간, 동시 컴팩션, 대규모 힙 지원    | 실시간 시스템, 대규모 메모리 관리 |
| Shenandoah GC | 동시 컴팩션, 낮은 지연 시간                 | 대규모 힙, 클라우드 환경      |


## 3.7.3 가상 머신과 가비지 컬렉터 로그

안타깝게도 가비지 컬렉터 로그에는 엄격한 규칙이 없고 개발 당시 개발자 마음에 따라 다소 차이가 난다.  

- `-Xlog:gc`: 기본 정보
- `-Xlog:gc*`: 상세 정보
- `-Xlog:gc+heap=debug`: 가비지 컬렉션 전후로 가용한 힙과 메서드 영역의 용량 변화
- `-Xlog:safepoint`: 가비지 컬렉션 중 사용자 스레드의 동시 실행 시간과 일시 정지 시간
- `-Xlog:gc+ergo*=trace`: 자동 조절 관련 정보
- `-Xlog:gc+age=trace`: 회수 후 남은 객체들의 나이 분포


### 3.7.4 가비지 컬렉터 매개 변수 정리


## 3.8 실전: 메모리 할당과 회수 전략



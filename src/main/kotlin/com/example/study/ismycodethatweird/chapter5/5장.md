# 5장 응집도: 흩어져 있는 것들

응집도란 '모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지 나타내는 지표'다.  
응집도가 높은 구조는 변경하기 쉬우며, 바람직한 구조이다.  


## 5.1 static 메서드 오용

static 메서드 오용으로 응집도가 낮아지는 경우가 있다.  
데이터는 MoneyData(DTO)에 있고, 데이터를 조작하는 로직은 OrderManager(Service)에 있다는 것이 문제다.  

### 5.1.1 static 메서드는 인스턴스 변수를 사용할 수 없음  

어떤 메서드를 static 메서드로 만든 시점에 이미 데이터와 데이터를 조작하는 로직 사이에 괴리가 생긴다.  
당연히 응집도는 낮아질 수 밖에 없다.  

### 5.1.2 인스턴스 변수를 사용하는 구조로 변경하기

'인스턴스 변수'와 '인스턴스 변수를 사용하는 로직'을 같은 클래스에 만드는 것이 응집도를 높이는 방법이다.  

> DTO에 로직을 정의하지 말라는 얘기와 상반되는 내용인 듯

### 5.1.3 인스턴스 메서드인 척하는 static 메서드 주의하기

인스턴스 메서드로 정의했어도 매개변수로 받은 값만 활용해서 계산하므로, static 메서드와 차이가 없다.  
인스턴스 메서드인 척하는 static 메서드도 응집도를 낮춘다.  
인스턴스 메서드 앞에 static을 추가했을 때 IDE에서 오류가 발생하지 않는다면, 해당 메서드는 인스턴스 메서드인 척하고 있는 static 메서드이다.  

### 5.1.4 왜 static 메서드를 사용할까?

static 메서드를 사용하는 이유는 객체 지향 언어를 사용할 때, C 언어 같은 절차 지향 언어의 접근 방법을 사용하려 하기 때문이다.  
static 메서드는 클래스의 인스턴스를 만들지 않아도 되므로, 간단하게 사용할 수 있다.  
하지만, 응집도가 낮아지는 문제를 일으키므로, 남용하지 않는 것이 좋다.  

### 5.1.5 어떠한 상황에서 static 메서드를 사용해야 좋을까?

- 응집도의 영향을 받지 않는 경우 (로그 출력 전용 메서드,  포맷 변환 전용 메서드)
- 팩토리 메서드


## 5.2 초기화 로직 분산

클래스를 잘 설계해도, 초기화 로직이 분산되어 응집도가 낮은 구조가 되어 버리는 경우가 있다.  

```
val standardMembershipPoint = GiftPoint(3000) // 일반회원 초기화   
val premiumMembershipPoint = GiftPoint(10000) // 특별회원 초기화  
```

생성자를 public으로 만들면, 의도하지 않은 용도로 사용될 수 있다.  

### 5.2.1 private 생성자 + 팩토리 메서드를 사용해 목적에 따라 초기화하기

```
companion object {
  fun forStatndardMembership(): GiftPoint { ... } // 일반회원 초기화  
  fun forPremiumMembership(): GiftPoint { ... } // 특별회원 초기화  
}
```

### 5.2.2 생성 로직이 너무 많아지면 팩토리 클래스를 고려해 보자

생성 로직이 너무 많아지면 해당 클래스가 무엇을 하는 클래스인지 알기 어렵다.  
생성 로직이 너무 많아지는 것 같다면, 생성 전용 팩토리 클래스를 분리하는 방법을 고려하는 것이 좋다.  


## 5.3 범용 처리 클래스 (Common/Util)

Common/Util 클래스는 static 메서드와 마찬가지로 응집도가 낮은 구조가 만들어질 수 있다.  

### 5.3.1 너무 많은 로직이 한 클래스에 모이는 문제

범용의 의미와 재사용성을 잘못 이해하고 있기 때문이다.  
재사용성은 설계의 응집도를 높이면, 저절로 높아진다.  

### 5.3.2 객체 지향 설계의 기본으로 돌아가기

### 5.3.3 횡단 관심사

다양한 상황에서 넓게 활용되는 기능을 횡단 관심사라고 부른다.  
- 로그 출력
- 오류 확인
- 디버깅
- 예외 처리
- 캐시
- 동기화
- 분산처리


## 5.4 결과를 리턴하는 데 매개변수 사용하지 않기

```
class ActorManager {
  fun shift(location: Location, shiftX: Int, shiftY: Int) {
    location.x += shiftX
    location.y += shiftY
  }
}
```

데이터 조작 대상은 Location, 조작 로직은 ActorManager이다.  
데이터와 로직이 각자 다른 클래스에 있고, 응집도가 낮은 구조이다.  
응집도가 낮은 구조는 중복을 만든다.  

출력 매개변수로 설계하지 말고, 객체 지향 설계의 기본으로 돌아가서 '데이터'와 '데이터를 조직하는 논리'를 같은 클래스에 배치해야 한다.  


## 5.5 매개변수가 너무 많은 경우

매개변수가 너무 많은 메서드는 응집도가 낮아지기 쉽다.  
너무 많은 매개변수를 받는 메서드는 실수로 잘못된 값을 대입할 가능성이 높다.  
매개변수가 많다는 것은 많은 기능을 처리하고 싶다는 의미이고, 로직이 복잡해지거나, 중복 코드가 생길 가능성이 높아진다.  

> 코틀린은 Named arguments를 지정할 수 있어서 안전한 편  
> Student(name = name, age = age)  

### 5.5.1 기본 자료형에 대한 집착

기본 자료형을 남용하는 현상을 기본 자료형 집착이라고 한다.  

> 날짜 데이터를 String 타입의 YYYYMMDD(20231212)로 받으려는 습성이 있음

### 5.5.2 의미 있는 단위는 모두 클래스로 만들기


## 5.6 메서드 체인

. (점)으로 여러 메서드를 연결해서 리턴 값의 요소에 차례차례 접근하는 방법을 메서드 체인이라고 부른다.  
이 방법도 응집도를 낮출 수 있어 좋지 않은 작성 방법이다.  

데메테르의 법칙: 사용하는 객체 내부를 알아서는 안된다.  

> 기차충돌 vs 메서드 체이닝 https://hyesun03.github.io/2019/04/01/method-chain-vs-train-wrek/

### 5.6.1 묻지 말고 명령하기

다른 객체의 내부 상태(변수)를 기반으로 판단하거나 제어하려고 하지 말고, 메서드로 명령해서 객체가 알아서 판단하고 제어하도록 설계하라는 의미이다.  



# 1장 잘못된 구조의 문제 깨닫기

좋은 구조로 개선하기 위해서는 일단 나쁜 구조의 폐해를 인지해야 합니다.  
그런 다음 폐해를 개선할 수 있는 좋은 구조를 배우면, 나쁜 구조와 좋은 구조의 차이를 파악하여 설계를 개선할 수 있습니다.  

> 책 내용에 딴지를 거는건 아니지만, 나쁜 구조로 개발해온 사람들은 나쁜 구조가 당연한 것으로 생각함  
> 개인의 성향에 따라 다르겠지만, 나쁜 구조에 순응하는 개발자와 그렇지 않은 개발자로 나뉘는 듯  

## 1.1 의미를 알 수 없는 이름

```
class Class001 {
   void method001();
   void method002();
}
```

위처럼 클래스와 메서드에 번호를 붙여서 이름 짓는 것을 일련번호 명명이라고 합니다.  

> 현재 기간계 클래스명과 배치가 이렇게 명명되어 있음  
> FinC001 클래스명만 보고 알 수 가 없어서 풀네이밍으로 정의하자고 얘기하는 중  
> 
> 왜 이렇게 이름을 붙일까?  
> 프로젝트를 수주 받는 SI 입장에서는 네이밍하는 것조차 시간이 아깝다고 생각하거나,  
> method001 ~ method999까지 기능 문서를 작성하고, 각 담당자한테 전달해서 그러지 않았을까 추측  


## 1.2 이해하기 어렵게 만드는 조건(if) 분기 중첩

> early return으로 하나씩 풀기  
> 조건문 중첩이 복잡하다는건 클래스 설계가 잘못 되었다고 생각함  


## 1.3 수많은 악마를 만들어 내는 데이터 클래스

그런데 데이터 클래스에는 데이터뿐만 아니라, 세금이 포함된 금액을 계산하는 로직도 필요한데, 이러한 계산 로직을 데이터 클래스가 아닌 다른 클래스에 구현하는 일이 벌어지곤 합니다.  

> 책에서 말하는 데이터 클래스가 DTO인지 도메인 모델인지 정확히 모르겠음  
> DTO(VO)에 도메인적인 로직을 넣어도 되는가?  

### 1.3.1 사양을 변경할 때 송곳니를 드러내는 악마

계산 로직을 어느 한곳에 만들어 두면, 사람들이 모두 그것만 사용하고 따로 구현하지는 않겠지 하고 생각할 수도 있습니다.  
하지만 설계에 관심이 없다면, 필요한 로직이 이미 구현되어 있다는 사실을 모르고 따로 구현해 버릴 수도 있습니다.  
이런 상황은 데이터를 담고 있는 클래스와 데이터를 사용하는 계산 로직이 멀리 떨어져 있을 때 자주 일어납니다.  

이처럼 데이터와 로직 등이 분산되어 있는 것을 응집도가 낮은 구조라고 합니다.  

### 1.3.2 코드 중복

### 1.3.3 수정 누락

### 1.3.4 가독성 저하

중복된 코드를 포함해서 관련된 정보를 다 찾는 것만으로도 시간이 오래 걸립니다.  
따라서 가독성이 떨어지는 것입니다.  

### 1.3.5 초기화되지 않은 상태(쓰레기 객체)

> 초기화 되지 않은 값에 대한 NullPointerException의 문제를 얘기하고 있는데, 어떤 연관이 있는지 모르겠음  

### 1.3.6 잘못된 값 할당

잘못된 값이 들어가지 않게, 데이터 클래스를 사용하는 쪽에서 유효성을 검사하게 만들 수 있다.  
하지만 사용하는 곳마다 검사 로직을 추가해야 하니 코드가 중복될 수 있다.  

## 1.4 악마 퇴치의 기본

> 번외 엄청난 기간계 데이터 구조
> 
> 학생 10명을 데이터로 정의한다면 보통 List<Student>  
> 
> 하지만 기간계에서는 Student 단일 클래스이고, 내부 데이터 타입이 List로 되어 있음
> class Student {
>    List<String> name;
>    List<Int> age;
> }
> 3번째 학생정보를 가져오려면 student[2]가 아니라, student.name[2], student.age[2]로 가져와야함
> 문제는 name과 age 리스트 길이가 다른 적도 있음  

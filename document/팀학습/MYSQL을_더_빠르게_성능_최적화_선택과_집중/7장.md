# 7장 복제 지연

**복제 지연**은 원본 MySQL 인스턴스에서 쓰기가 발생하는 시간과 해당 쓰기가 복제 MySQL 인스턴스에 적용되는 시간 사이의 지연입니다.  
복제는 네트워크를 통하므로 네트워크 지연 시간이 발생합니다.  
따라서 모든 데이터베이스에서 복제 지연은 당연한 현상입니다.  

## 7-1 MySQL의 복제 유형

### 원본에서 복제본으로

MySQL 복제는 원본에서 복제본으로의 복제를 의미합니다.  

**원본 MySQL 인스턴스**는 클라이언트가 데이터를 쓰는 MySQL 서버입니다.  
쓰기 가능한 단일 원본이 일반적입니다.  

**복제본 MySQL 인스턴스**는 원본에서 데이터 변경 사항을 복제하는 모든 MySQL 서버입니다.  
복제본은 스플릿 브레인을 방지하기 위해 항상 읽기 전용이어야 합니다.  

MySQL 복제는 비동기식이 기본입니다.  

복제본은 바이너리 로그를 작성하는 데 필요하지 않지만 복제본이 원본이 될 수 있으므로 고 가용성을 위한 표준 관행입니다.  
원본이 죽거나 유지 관리를 위해 중단되면 복제본이 승격되어 새 원본이 됩니다.  
새 원본 바이너리 로그에서 이전 원본은 오프라인 상태에서 놓친 쓰기를 복제합니다.  


### 그룹 복제

그룹 복제는 그룹 합의 프로토콜을 사용하여 데이터 변경 사항을 동기화하고 그룹 구성원을 관리하는 기본과 보조 인스턴스의 MySQL 클러스터를 생성합니다.  

> Active/Active 클러스터의 두 개 이상의 데이터베이스 인스턴스에 쓰기를 수행함으로써 가용성을 극대화하고 쓰기 대기 시간을 감소시킬 수 있습니다.  
> https://aws.amazon.com/ko/blogs/tech/amazon-rds-for-mysql-active-active-group-replication-plugin/

그룹 복제보다 뛰어난 또 다른 혁신이 표준이 되고 있습니다.  
바로 InnoDB 클러스터입니다.  


### 바이너리 로그 이벤트

바이너리 로그 이벤트는 애플리케이션이 실행한 트랜잭션의 직접적인 결과입니다.  
따라서 애플리케이션이 복제 파이프라인을 통해 무엇을 플러시하려고 하는지 이해하는 것이 중요합니다.  


### 복제 지연

복제 지연은 복제본에 변경 사항을 적용하는 것이 원본에 변경 사항을 커밋하는 것보다 느릴 때 발생합니다.  

원본 MySQL 인스턴스(DB > 바이너리 로그 > 바이너리 로그 덤프 스레드) > 복제 MySQL 인스턴스(I/O 스레드 > 릴레이 로그 > SQL 스레드 > DB)  
복제본의 I/O 스레드는 바이너리 로그 이벤트를 릴레이 로그에 빠른 속도로 쓸 수 있습니다.  
그러나 SQL 스레드에는 변경 사항을 적용하는 훨씬 더 어렵고 시간이 많이 걸리는 과정이 있습니다.  

반동기식 복제를 사용하면 각 트랜잭션에 대해 MySQL은 복제본이 트랜잭션에 대한 바이너리 로그 이벤트를 릴리에 로그에 기록했음을 확인할 때까지 기다립니다.  

단일 SQL 스레드는 초당 수천 건의 트랜잭션을 쉽게 처리할 수 있습니다.  
첫 번째는 복제본은 원본이 실행하는 전체 워크로드를 실행하지 않습니다.  
두 번째는 복제본은 SQL 문을 실행하지 않고 바이너리 로그 이벤트를 적용합니다.  
이렇게 하면 복제본에 최종 결과가 제공되고 이를 적용할 위치를 알려주기 때문에 복제본에 많은 시간이 절약됩니다.  


## 7-2 복제 지연의 3가지 원인

### 트랜잭션 처리량

트랜잭션 처리량은 원본의 속도가 복제본의 SQL 스레드가 변경 사항을 적용할 수 있는 속도보다 빠를 때 복제 지연을 유발합니다.  

과도하게 많은 행을 수정하는 대규모 트랜잭션은 원본보다 복제본에 더 큰 영향을 미칩니다.  
해결책은 더 작은 트랜잭션입니다.  

> 1000 개 단위 chunk 처리  
> 무거운 쿼리를 실행하는 정산 DB를 분리해야하는 이유라고 생각  

복제본을 1초 지연하는 것보다 작업에 하루가 걸리는 것이 더 낫습니다.  


### 장애 후 재구축

MySQL이나 하드웨어에 장애가 발생하면 인스턴스가 수리되어 다시 복제 토폴로지로 돌아갑니다.  
또는 새 인스턴스가 기존 인스턴스에 복제되어 실패한 인스턴스를 대신합니다.  

수리된 인스턴스는 오프라인 상태에서 놓친 모든 바이너리 로그 이벤트를 복제하고 따라 잡는 데 몇 분, 몇 시간 또는 며칠이 걸립니다.  


### 네트워크 문제

네트워크 문제로 인해 원본에서 보게본으로 바이너리 로그 이벤트 전송이 지연되면 복제 지연이 발생합니다.  


## 7-3 위험: 데이터 손실

복제 지연은 **데이터 손실**입니다.  
반동기식 복제는 커밋된 트랜잭션을 잃지 않는 옵션입니다.  

### 비동기식 복제

충돌 원인이 MySQL이라면 자동으로 다시 시작하고 충돌 복구를 수행한 다음 정상 작동을 재개합니다.  
MySQL은 올바르게 구성되었을 때 정확한 지속성이 있으므로 커밋된 트랜잭션은 손실되지 않습니다.  

하드웨어나 운영체제가 충돌의 원인이거나 어떤 이유로든 손상된 MySQL 인스턴스를 신속하게 복구할 수 없다면 DBA가 장애 조치하고 트랜잭션은 잃게 됩니다.  

유일한 완하 방법은 복제 지연 최소화를 엄격히 준수하는 것입니다.  

비동기식 복제는 모범 사례가 아닙니다.  
비동기식 복제를 실행할 때 다음 3가지 조건이 충족된다면 즉시 조치를 취해야 합니다.  
- 하트비트로 복제 지연을 모니터링합니다.
- 복제 지연 시간이 너무 길면 언제든지 경고 알림을 받습니다.
- 복제 지연을 데이터 손실로 간주하고 즉시 수정합니다.

많은 기업이 비동기식 MySQL 복제를 사용하지만 더 높은 표준인 반동기식 복제를 사용할 수 있도록 노력해야 합니다.  


### 반동기식 복제

반동기식 복제를 사용하면 원본은 적어도 하나의 복제본이 각 트랜잭션을 승인할 때까지 기다립니다.  
트랜잭션은 복제본의 디스크에 안전하게 있지만 복제본은 아직 적용하지 않았습니다.  

InnoDB 트랜잭션 커밋은 2단계 커밋입니다.  

중요한 차이점은 반동기 복제를 사용하는 경우 연결당 커밋되지 않은 트랜잭션이 하나만 손실될 수 있다는 것입니다.  
요점은 반동기식 복제는 커밋된 모든 트랜잭션이 적어도 하나의 복제본으로 복제되도록 보장하며, 실패하면 연결당 커밋되지 않은 트랜잭션 하나만 손실될 수 있다는 것입니다.  

반동기식 복제는 가용성을 떨어뜨립니다.  

기본적으로 반동기식 복제는 복제본이 충분하지 않거나 원본이 응답 대기 시간을 초과하면 비동기식으로 되돌아갑니다.  
반동기식 복제의 성능을 위해서는 원본과 복제본이 빠른 로컬 네트워크에 있어야 합니다.  

비동기식 복제는 특별한 구성 없이 작동하지만, 반동기식 복제는 특정 구성과 튜닝이 필요합니다.  


## 7-4 지연 감소: 다중 스레드 복제

MySQL 복제는 비동기식이고 단일 스레드입니다.  
반동기식 복제도 단일 스레드입니다.  
다중 SQL 스레드는 트랜잭션을 병렬로 적용합니다.  

다중 스레드 복제는 MySQL을 사용하는 엔지니어에게는 간단하지만, MySQL로서는 간단하지 않은 해결책입니다.  
트랜잭션은 무작위 순서로 적용될 수 없습니다.  

하나의 시스템 변수 `LOGICAL_CLOCK`으로 다중 스레드 복제가 가능하지만 실제로는 더 복잡합니다.  

- replica_parallel_workers
- replica_parallel_type
- replica_preserve_commit_order

다중 스레드 복제는 최상의 방법이지만 성능을 극대화하려면 상단한 MySQL 설정과 때로는 튜닝이 필요하기도 합니다.  


## 7-5 모니터링

`SHOW_REPLICA_STATUS` 명령문으로 확인할 수 있는 악명 높은 복제 지연 메트릭인 `Seconds_Behind_Source`를 살펴보겠습니다.  

- 복제본의 현시각 - 바이너리 로그 이벤트의 트임스탬프
- 바이너리 로그 이벤트에 의존하므로 이벤트가 도착하기 전에 어떠한 문제도 알 수 없음
- 0과 0이 아닌 값 사이를 반복
- 복제본이 원본을 따라잡을 때까지 걸리는 시간을 정확하게 알 수 없음


## 7-6 복구 시간

복제본은 언제 원본을 따라잡아 최신 트랜잭션을 실행할까요? 정확한 답은 없습니다.  

결과적으로 복제본은 종종 원본보다 빠르게 트랜잭션을 적용하며, 이것이 결국 복제본이 따라잡는 방법입니다.  

복제본이 복구되는 정확한 시간을 알 수 있더라도 기다리는 수밖에 없습니다.  
복제본은 망가지지 않는 한 MySQL은 항상 복구됩니다.  


# 요점 정리

- 비동기식 복제가 기본값
- 복제 지연에는 3가지 주요 원인이 있습니다.
  - 원본의 높은 트랜잭션 처리량
  - 장애 후 재구축
  - 네트워크 문제
- 복제 지연으로 인한 복구 시간은 부정확하고 계산하기 어렵습니다.
- MySQL은 항상 원인이 해결되면 결국 복구됩니다.  



# 8장 트랜잭션

MySQL에는 MyISAM과 같은 비트랜잭션 스토리지 엔진이 있지만 InnoDB가 기본값이고, 사실상 모든 MySQL 쿼리는 단일 SELECT 문이라도 트랜잭션에서 실행됩니다.  
애플리케이션 워크로드가 잘 최적화되면 트랜잭션은 성능과 관련된 문제가 없습니다.  

## 8-1 로우 락

읽기는 행을 잠그지 않지만, 쓰기는 항상 행을 잠급니다.  
`REPEATBALE READ` 트랜잭션에서 InnoDB는 쓰기 행 말고도 훨씬 더 많은 행을 잠글 수 있습니다.  

테이블은 인덱스이므로, 행은 인덱스 레코드입니다.  
InnoDB 로우 락은 인덱스 레코드 갭 때문에 로우 락이 아니라 레코드 락 관점에서 논의됩니다.  

> MySQL 인덱스는 B-tree로 관리  
>        1    ...    10  
>    1  ..  5   |   6  ..  10   
>  1 . 2 | 3 . 5 |  6 . 7 | 8 . 10  
> 3번 데이터를 업데이트 할 경우, 3, 4, 5번 데이터가 잠김  

간단히 말해, 애플리케이션은 행 단위로 처리하고 InnoDB 로우 락은 레코드 단위로 처리합니다.  
이 절의 예는 갭 락이 상당히 광범위하고 개별 레코드 락보다 더 중요하다는 것을 보여 줍니다.  

### 레코드와 넥스트-키 락

```
UPDATE elem SET c = '' WHERE id BETWEEN 2 AND 5;  
하한 ... 2 (레코드 락) ... 5 (넥스트-키 락) ... 상한 (넥스트-키 락)  
```

> 2와 5 사이에는 갭 락이 존재  

흥미로운 질문은 "테이블 조건에서 5보다 큰 프라이머리 키값을 제외할 때, 5보다 큰 모든 프라이머리 키값을 포함하는 상한.의사 레코드를 잠그는 이유는 무엇일까요?" 입니다.  

새로운 값(3)을 삽입할 2와 5 사이의 갭에서 **삽입 의도 잠금**을 획득하려고 시도하는 첫번째 INSERT는 시간 초과가 발생합니다.  
lock_data 열에 값 5가 나열되지만 레코드나 넥스트-키 락이 아니므로 이 레코드는 잠기지 않습니다.  
이것은 특별한 유형의 갭 락인 삽입 의도 잠금이므로 값 5 이전의 갭을 잠급니다.  

두 번째 INSERT는 새 값 6이 현재 최댓값 5보다 크기 때문에 상한-의사 레코드에서 넥스트-키 락을 획득하려고 시도할 때 시간이 초과되어 최대 레코드와 상한 의사 레코드 사이에 삽입됩니다.  

영향을 받는 레코드 앞의 갭을 잠그면 넥스트-키 락은 쿼리가 접근하는 레코드의 전체 범위를 격리합니다.  
이는 ACID 속성 가운데 I(격리성)을 나타냅니다.  
이는 트랜잭션이 이전에 읽지 않은 행을 나중에 읽을 때 **팬텀 행**이라는 현상을 방지합니다.  

`REPEATABLE READ`는 MySQL의 기본값이며 InnoDB는 넥스트-키 락을 사용하여 REPEATABLE READ에서 팬텀 행을 방지합니다.  

트랜잭션 격리 수준인 `READ COMMITTED`는 넥스트-키 락을 포함하는 갭 락을 비활성화합니다.  
`READ COMMITTED` 트랜잭션의 동일한 UPDATE 문은 일치하는 행(2, 5)에서만 레코드 락을 획득합니다.  

`READ COMMITTED`에는 2가지 중요한 부작용이 있습니다.  
- 동일한 읽기 문을 다시 실행하면 다른 행을 반환할 수 있습니다.
- 동일한 쓰기 문을 다시 실행하면 다른 행에 영향을 미칠 수 있습니다.

> A1 트랜잭션 시작  
> A1 트랜잭션에서 SELECT 실행: 값이 5  
> B1 트랜잭션 시작  
> B1 트랜잭션에서 UPDATE 실행: 값이 5에서 1로 변경  
> A1 트랜잭션에서 SELECT 실행: 값이 5가 아닌 1로 조회 됨 << 이 부분이 문제인 듯  
> A1 트랜잭션 종료  
> B1 트랜잭션 종료  


### 갭 락

갭 락은 순수하게 다른 트랜잭션이 갭에 행을 삽입하는 것을 금지하고 방지합니다.  
모든 갭 락은 다른 갭 락과 호환되므로 다중 트랜잭션이 같은 갭을 잠글 수 있습니다.  
그러나 갭 락은 다른 트랜잭션이 갭에 행을 삽입하는 것을 방지하므로, 갭을 잠그는 유일한 트랜잭션일 때는 하나의 트랜잭션만 갭에 행을 삽입할 수 있습니다.  

`SELECT * FROM elem WHERE id = 3 FOR SHARE;`
`READ REPEATABLE`과 `SELECT FOR SHARE`로 갭에 접근하면 단독 갭 락(2 ~ 5 사이)을 호출합니다.  

공유(SHARE) 또는 배타적인(EXCLUSIVE) 모든 갭 락은 다른 트랜잭션이 갭에 행을 삽입하는 것을 방지합니다.  
무해한 SELECT 문은 실제로는 교활한 INSERT 차단기입니다.  

```
UPDATE elem SET c = '' id BETWEEN 2 AND 5; >> 넥스트-키 락으로 갭을 잠금
UPDATE elem SET c = '' id IN (2, 5); >> 갭에 접근하지 않으므로 레코드 락을 사용
UPDATE elem SET c = '' id IN (2, 3, 5); >> 2~5 사이의 공백에 접근하고 갭 락 사용
```
똑같은 EXPLAIN 계획이 있고 행이 일치하더라도 쿼리는 행에 다르게 접근 합니다.

갭 락은 `READ COMMITTED`를 사용하여 쉽게 비활성화할 수 있습니다.  


### 세컨더리 인덱스

세컨더리 인덱스는 로우 락, 특히 고유하지 않은 인덱스와 관련하여 잠재적으로 광범위한 결과를 초래합니다.  

```
UPDATE elem SET c = '' WHERE a BETWEN 'Ar' AND 'Au';
```
UPDATE는 두 행만 일치하지만 전체 세컨더리 인덱스를 잠가 값을 삽입하지 못하게 합니다.  

`READ COMMITTED`는 일치하는 행만 레코드 락으로 잠기므로 고유하지 않은 세컨더리 인덱스에 대해서도 갭 락을 방지합니다.  

```
UPDATE elem SET c = '' WHERE a IN ('Ar', 'Au');
```
BETWEEN 절을 IN 절로 변경하여 갭 락을 방지했지만, 고유하지 않은 인덱스에서는 작동하지 않습니다.  

> IN 절로 갭락을 방지하는건 PK와 유니크키만 가능하다는 것인지?

```
UPDATE elem SET c = 'GO' WHERE a = 'Au';
```
'Au' 값은 사라졌지만 InnoDB는 여전히 튜플에 넥스트-키 락('Au', 2)을 유지합니다.  
새로운 'Go'에는 레코드 락이나 넥스트-키 락이 없으며 ('Go', 2) 앞에 갭 락만 있습니다.  


### 삽입 의도 잠금

삽입 의도 잠금은 갭이 다른 트랜잭션에 의해 잠기지 않을 때 트랜잭션이 갭에 행을 삽입함을 의미하는 특별한 유형의 갭 락입니다.  
삽입 의도 잠금은 다른 삽입 의도 잠금과 호환됩니다(차단하지 않음).  
이는 다중 트랜잭션이 동시에 같은 갭에 서로 다른 행을 삽입할 수 있어서 INSERT 성능에 중요합니다.  

갭 락은 INSERT를 방지합니다. 삽입 의도 잠금은 INSERT를 허용합니다.  

```
UPDATE elem SET c = '' WHERE id BETWEEN 2 AND 5; // id < 5 조건의 갭을 잠금  

INSERT INTO elem VALUES (3, ...); // 먼저 삽입의도 잠금을 생성하고, UPDATE 문이 COMMIT(갭이 잠금 해제) 되면 데이터 추가

INSERT INTO elem VALUES (9, ...); // 갭 락을 차단하지 않음
```

명시적 잠금은 메모리에 잠금 구조로 존재하므로 InnoDB는 이를 보고할 수 있습니다.  
암시적 잠금은 잠금 구조가 없으므로 InnoDB는 보고할 것이 없습니다.  


## 8-2 MVVC와 언두 로그

InnoDB는 다중 버전 동시성 제어(MVCC)와 언두 로그를 사용하여 A, C, I 속성을 수행합니다.  
MVCC는 행에 대한 변경 사항이 행의 새 버전을 생성함을 의미합니다.  
행이 처음 생성될 때는 버전이 1입니다.  
처음 업데이트될 때 버전은 2가 됩니다.  

언두 로그는 변경 사항을 이전 행 버전으로 롤백하는 방법을 기록합니다.  

`REPEATBALE READ` 트랜잭션에서 첫 번째 읽기는 SELECT가 실행되는 순간 데이터베이스의 가상 보기인 스냅샷을 설정합니다.  
이때 설정된 스냅샷은 해당 트랜잭션이 끝날 때까지 유지되며, 이후 모든 읽기는 데이터베이스의 변경 내역에서 오직이 시점의 행 접근에만 사용됩니다.  
이 시점 이후에 다른 트랜잭션에 의해 변경된 사항은 원본 트랜잭션 내에서 볼 수 없습니다.  
다른 트랜잭션이 데이터베이스를 수정한다고 가정하면, 원본 트랜잭션의 스냅샷은 트랜잭션이 활성 상태를 유지하는 동안 점점 더 오래된 데이터베이스 보기가 됩니다.  

> 이래서 Jpa가 영속성 컨텍스트 (1차 캐시)가 존재하는 것인지?  
> REPEATABLE READ의 @Transactional 범위 내에서는 결국 DB의 스냅샷 결과만 조회할태니깐?  

해당 트랜잭션이 SELECT 를 다시 실행하면 버전 5를 읽지만, 해당 버전이 스냅샷으로 인해 설정된 데이터베이스 변경 내역의 지점보다 더 최신임을 알 수 있습니다.  
결과적으로 MySQL은 언두 로그를 사용하여 행을 롤백하고 버전 1을 재구성합니다.  
이는 첫 번째 SELECT 문에 의해 설정된 스냅샷과 일치합니다.  

> REPETABLE READ에서 트랜잭션이 유지 된다면, SELECT의 결과는 모두 똑같다는 의미로 이해함

`READ COMMITTED`트랜잭션에서 각 읽기는 새 스냅샷을 설정합니다.  
스냅샷이 사용되기 때문에 언두 로그가 계속 생성되지만, 각 스냅샷은 읽기 기간 동안만 유지 됩니다.  
읽기에 매우 오랜 시간이 걸리고 데이터베이스의 쓰기 처리량이 많을 때는 변경 내역 목록 길이가 증가함에 따라 리두(redo) 로그가 발생할 수 있습니다.  

스냅샷은 읽기에만 영향을 미치며 쓰기에는 사용되지 않습니다.  
쓰기는 트랜잭션이 SELECT로 현재 행을 볼 수 없더라도 항상 비밀리에 현재 행을 읽습니다.  
원본 트랜잭션이 프라이머리 키 값이 같은 행을 삽입하려고 하면 트랜잭션이 SELECT로 다른 트랜잭션이 입력한 프라이머리 키값을 볼 수 없어도 존재는 하므로 MySQL은 중복 키값을 반환합니다.

> 비록 트랜잭션 A가 트랜잭션 B의 값을 조회할 수는 없지만, MySQL은 내부적으로 해당 프라이머리 키 값의 잠금(lock)을 알고 있기 때문에, 중복 키 값 충돌을 감지할 수 있습니다.  
> 트랜잭션이 다른 경우, SELECT를 하지 않더라도 삽입 의도 잠금으로 알 수 있는 듯  

언두 로그는 쓰기로 인해 변경된 내용을 되돌리기 위해 `ROLLBACK`에서도 사용됩니다.  
언두 로그는 버퍼 풀 페이지에 있으므로 메모리를 사용하고 주기적으로 디스크로 플러시 됩니다.  


## 8-3 변경 내역 목록 길이

변경 내역 목록 길이(HLL)은 제거 또는 플러시되지 않은 이전 행 버전의 양을 측정합니다.  
언두 로깅의 전체 구조가 복잡했기 때문에 HLL을 정의하기 어려웠습니다.  

HLL값이 10,000이면 10,000개의 변경으로 읽을 수 있습니다.  

100,000보다 큰 HLL은 문제이므로 무시하면 안 됩니다.  

HLL이 확인되지 않고 증가하면 성능이 눈에 띄게 느려지거나 MySQL이 충돌하는 문제가 발생한다는 점입니다.  

SELECT가 실행될 때마다 언두 로그를 통해 나온 버전은 일관된 스냅샷에 의해 원래 행 버전으로 재구성하고, 재구성된 버전은 쿼리 응답 시간을 늘립니다.  


## 8-4 일반적인 문제

트랜잭션 문제는 트랜잭션을 구성하는 쿼리, 애플리케이션이 해당 쿼리를 얼마나 빨리 실행하는지, 애플리케이션이 트랜잭션을 얼마나 커밋하는지에 따라 발생합니다.  

애플리케이션이 트랜잭션을 커밋하지 않으면 MySQL은 해당 활성 트랜잭션의 결과가 종료될 때까지 기다립니다.  

> @Transactional 범위에 API 호출이 포함되는건 막아야 함


### 대규모 트랜잭션(트랜잭션 크기)

트랜잭션이 `REPETABLE READ`에서 실행 중이라면 갭 락으로 인해 수정된 행보다 더 많은 수의 레코드를 잠근 것으로 가정해야 안전합니다.  

대규모 트랜잭션은 복제 지연의 주요 원인이며 다중 스레드 복제의 효율성을 떨어뜨립니다.  

트랜잭션은 작을수록 더 좋습니다.  

해결 방법은 트랜잭션에서 너무 많은 행을 수정하는 쿼리를 찾아 더 적은 수로 행을 수정하도록 변경하는 것입니다.  


### 오래 실행되는 트랜잭션

오래 실행되는 트랜잭션은 완료(커밋 / 롤백)하는 데 너무 오래 걸립니다.  

개별 쿼리가 빨라지므로 결국 전체 트랜잭션이 더 빨라져 트랜잭션 처리량이 증가할 수 있습니다.  
오래 실행되는 트랜잭션이 애플리케이션에는 충분히 빠르지만, 다른 트랜잭션에는 너무 길 수 있다는 것입니다.  

트랜잭션에서 실행되는 쿼리 수를 줄이도록 애플리케이션을 수정하여 해결할 수 있습니다.  


### 지연된 트랜잭션

지연된 트랜잭션이 `BEGIN` 이후, 쿼리 사이 또는 `COMMIT` 이전에 너무 오래 대기하고 있습니다.  
지연된 트랜잭션은 오래 실행되는 트랜잭션일 가능성이 크지만 원인은 다릅니다.  

대기는 애플리케이션에 의해 발생하며 그 이유는 무한합니다.  
**일반적인 이유는 트랜잭션 전후가 아니라 트랜잭션이 활성 상태인 동안 시간을 소모하는 애플리케이션 로직을 수행하기 때문입니다.**  

아니면 `READ COMMITTED` 격리 수준으로 갭 락을 비활성화할 수 있나요?  


### 버려진 트랜잭션

버려진 트랜잭션은 활성 클라이언트 연결이 없는 활성 트랜잭션입니다.  

버려진 트랜잭션의 2가지 주요 원인  
- 애플리케이션 연결 누수
- 반쯤 닫힌 연결

MySQL과 운영체제 외부의 문제로 인해 MySQL 측을 닫지 않고 클라이언트 측 연결을 닫을 수 있습니다.  
이것이 반쯤 닫힌 연결이라고 하는 이유입니다.  

MySQL은 트랜잭션이 버려졌음을 알지 못하기 때문에 일관된 스냅숏이나 데이터 잠금도 활성 상태로 유지됩니다.  


## 8-5 보고

### 활성 트랜잭션: 최신

```
SELECT ...
FROM    performance_schema.events_transactions_current trx
        JOIN performance_schema.events_statuements_current stm USING (thread_id)
WHERE   trx.state = 'ACTIVE'
AND     trx.timer_wait > 1000000000000 * // 1초`
```

SQL 문은 1초보다 오래 활성화된 모든 트랜잭션에 대한 최신 쿼리를 보고 합니다.  

`information_schema.innodb_trx` 테이블을 조회하면 오래 실행되는 트랜잭션을 확인할 수 있습니다.  


### 활성 트랜잭션: 요약

```
SELECT ...
FROM    performance_schema.events_transactions_current trx
        JOIN performance_schema.events_statuements_current stm 
        ON stm.thread_id = trx.thread_id
        AND stm.nesting_event_id = trx.event_id
WHERE   stm.event_name LIKE 'statement/sql/%'
AND     trx.state = 'ACTIVE'
AND     trx.timer_wait > 1000000000000 * // 1초`
```


### 활성 트랜잭션: 쿼리 수행 내역

```
SELECT ...
FROM    performance_schema.events_statements_history stm
WHERE   stm.thread_id = 0
AND     stm.nesting_event_id = 0
ORDER   BY stm.event_id
```

수행 내역은 문제가 있는 트랜잭션을 디버깅할 때 매우 유용합니다.  


### 커밋된 트랜잭션: 요약


## 요점 정리

- 기본 InnoDB 데이터 잠금
  - 레코드 락: 단일 인덱스 레코드 락
  - 넥스트-키 락: 단일 인덱스 레코드와 그 앞의 레코드 간격 잠금
  - 갭 락: 두 레코드 사이의 범위 잠금
  - 삽입 의도 잠금: 갭에 INSERT를 허용
- 기본 트랜잭션 격리 수준인 REPEATABLE READ는 접근되는 행 범위를 격리하기 위해 갭 락을 사용합니다.
- READ COMMITTED 트랜잭션 격리 수준은 갭 락을 비활성화합니다.
- InnoDB는 REPEATABLE READ 트랜잭션에서 일관된 스냅샷을 사용하여 다른 트랜잭션에 의한 행 변경에도 불구하고 읽기가 동일한 행을 반환하도록 합니다.
- 트랜잭션 성능은 쿼리 성능만큼 중요합니다.




# 05 분산 트랜잭션

트랜잭션은 원자적으로 단일 작업으로 실행되며, 전체 트랜잭션이 성공해 커밋하거나 실패해 중단 혹은 롤백한다.  

분산 트랜잭션은 별개의 쓰기 요청을 하나의 분산된(원자적) 트랜잭션으로 결합한다.  
서비스 간의 일관성을 위해 쓰기 이벤트 중 문제가 생기더라도 합의가 이뤄져야 한다.  

- 이벤트 소싱, 변경 데이터 캡처(CDC), 이벤트 기반 아키텍처(EDA)
- 체크포인팅과 데드 레터 큐
- 사가(Saga) 패턴
  - https://camel.apache.org/
- 2단계 커밋


## 5.1 이벤트 기반 아키텍처(EDA)

EDA는 비동기적이고 논블로킹 방식이다.  
이벤트가 성공적으로 발행되면 서버는 성공 응답을 반환한다.  

- 느슨한 결합
- 확장성
- 응답성

EDA의 대안은 서비스가 다른 서비스에 직접 요청하는 것이다.  
이 요청은 각 서비스에서 스레드를 소비하므로 요청 처리에 걸리는 시간 동안 사용 가능한 스레드가 하나 줄어든다.  
트래픽 급증은 서비스의 처리 능력을 초과해 504 타임아웃을 유발할 수 있다.  

리소스 소비가 적은 접근 방식은 이벤트 로그에 이벤트를 발행하는 것이다.  


## 5.2 이벤트 소싱

이벤트 소싱은 추가 전용 로그에 이벤트로 데이터나 데이터 변경을 저장하는 패턴이다.  
모든 쓰기는 먼저 이벤트 로그에 이뤄져야 한다.  
이 쓰기가 성공한 후 하나 이상의 이벤트 핸들러가 이 새로운 이벤트를 소비하고 다른 데이터베이스에 쓴다.  

이벤트 소싱은 특정 데이터 소스에 묶여 있지 않다.  
사용자 상호 작용, 외부와 내부 시스템 등 다양한 소스에서 이벤트를 캡처할 수 있다.  

- 카프카
- 관계형 데이터베이스(SQL)
- MongoDB, Couchbase
- 레디스, 아파치 이그나이트

이벤트 소싱은 이벤트 스토리지, 복원, 버전 관리, 스키마 변화를 관리해야 하므로 시스템 설계와 개발에 복잡성이 더해지고 저장 요구사항이 증가한다.  
로그가 커질수록 이벤트 복원에 더 비용이 많이 들고 시간도 오래 걸린다.  

> Zipkin, Micrometer 필수


## 5.3 변경 데이터 캡처

변경 데이터 캡처(CDC)는 데이터 변경 이벤트를 변경 로그 이벤트 스트림에 기록하고 이 이벤트 스트림을 API를 통해 제공하는 방식이다.  

> MySQL Bin log

CDC는 이벤트 소싱보다 일관성이 높고 지연 시간이 낮다.  

트랜잭션 로그 테일링 패턴은 또 다른 시스템 설계 패턴으로, 프로세스가 데이터베이스에 쓰거나 카프카에 생성해야 할 때 발생할 수 있는 불일치를 방지하기 위하는 것이다.  
두 쓰기 중 하나가 실패하면 불일치가 발생할 수 있다.  

- Debezium
- 데이터버스
- 다이나모 DB 스트림
- Eventutate CDC Service


트랜잭션 로그 마이너는 중복 이벤트를 생성할 수 있다.  
중복 이벤트를 처리하는 한 가지 방법은 메시지 브로커의 'exactly once' 메커니즘을 사용하는 것이다.  
다른 방법은 이벤트를 멱등하게 정의하고 처리하는 것이다.  


## 5.4 이벤트 소싱과 CDC 비교

일부 시스템 설계에서는 이벤트 소싱과 CDC를 함께 사용할 수 있다.  
서비스 내에서는 이벤트 소싱을 사용해 데이터 변경을 이벤트로 기록하고, CDC를 사용해 이러한 이벤트를 다른 서비스로 전파할 수 있다.  

|        | 이벤트 소싱   | 변경 데이터 캡처(CDC)      |
|--------|----------|---------------------|
| 목적     | 이벤트 기록   | 이벤트를 전파해 데이터 변경 동기화 |
| 기준 데이터 | 로그, 이벤트  | DB 로그               |
| 세분성    | 세분화된 이벤트 | CUD 데이터베이스 수준의 변경   |


## 5.5 트랜잭션 감독자

트랜잭션 감독자는 트랜잭션이 성공적으로 완료되거나 취소되게 보장하는 프로세스다.  
보상 트랜잭션을 자동화하는 것은 일반적으로 위험하며 주의를 기울여 접근해야 한다.  
그렇지 않으면 서로 간섭해 데이터 손실이나 디버그하기 어려운 상황으로 이어질 수 있다.  

보상 트랜잭션은 수동으로 실행되었든 자동으로 실행되었든 상관없이 항상 기록돼야 한다.  


## 5.6 사가 패턴

사가는 실패를 관리하는 데 도움이 되는 패턴이다.  
사가 패턴 자체는 상태 비저장이다.  

결제 서비스 트랜잭션이 실패하면 다른 두 서비스 보상 트랜잭션을 사용해 역순으로 전체 사가를 롤백 해야 한다.  

- 코레오그레피(병렬)
- 오케스트레이션(선형)


### 5.6.1 코레오그래피 방식

코레오그래피 방식에서 사가 패턴을 시작하는 서비스는 두 개의 카프카 토픽과 통신한다.  

필요한 모든 이벤트가 수신되면 결제 서비스가 결제를 처리한다.  

타사 서비스가 자사 서비스의 카프카 토픽을 어떻게 구독하는지 질문이 제기될 수 있다.  

더 많은 수의 토픽과 서비스 간의 코레오그래피 방식은 지나치게 복잡하고, 오류가 발생하기 쉬우며, 유지보수가 어려워질 수 있다.  


### 5.6.2 오케스트레이션 방식

오케스트레이션 방식에서 사가 패턴을 시작하는 서비스가 오케스트레이터다.  

오케스트레이터는 단계의 순서만 포함해야 한다.  
보상 메커니즘을 제외하고는 다른 비즈니스 로직을 포함해서는 안 된다.  


### 5.6.3 비교

특정 시스템 설계에서 어떤 접근 방식을 사용할지 평가하기 위해 차이점과 상충 관계를 이해해야 한다.  

> 개인적으로 코레오그래피 방식은 유니콘 같은 존재라고 생각함


### 5.7 다른 트랜잭션 유형

합의 알고리즘은 일반적으로 분산 데이터베이스에서 많은 수의 노드 합의를 달성하는 데 더 유용하다.  

- 정족수 쓰기
- 팍소스와 EPaxos
- Raft
- Zab



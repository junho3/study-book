# CHAPTER 8 진화적 아키텍처의 함정과 안티패턴

소프트웨어 프로젝트에서 발견되는 그릇된 엔지니어링 관행은 함정과 안티패턴이라는 두 가지 형태로 구분할 수 있다.  

소프트웨어 안티패턴의 두 가지 특성
- 처음에는 괜찮아 보이지만 나중에 가면 실수였으이 밝혀진다.  
- 대부분 더 나은 대안이 존재한다.  

함정은 표면적으로 괜찮은 아이디어처럼 보였다가 곧바로 나쁜 본색을 드러낸다는 점이 다르다.  


## 8.1 기술 아키텍처

### 8.1.1 안티패턴 마지막 10%의 덫, 로우코드/노코드

4GL 언어로 빠르게 개발할 수 있는 달성률은 최대 80%  
실행 스크립트, 메서드 체인 등을 동원해도 최대 90%  
결과적으로 문제를 완전히 해결하지 못 하고, 마지막 10%의 덫에 빠진다.  
4GL을 사용하면 간단한 결과물을 빠르게 만들어 낼 수 있지만, 현실 세계에 발생하는 요구조건을 충족시키기에는 역부족이다.  
개발자들은 결국 번용 언어로 되돌아가는 수밖에 없었다.  

> 4GL 언어  
> 비주얼베이직, 비주얼 C++, 파워빌더, 델파이 등  
> https://m.blog.naver.com/chuck2013/220717999167  

로우코드/노코드는 풀스택 개발은 물론 오케스트레이터처럼 특화된 도구까지 아우르는 개발 환경이다.  

> 로우코드/노코드  
> 프로그래밍 코드가 아니라 템플릿으로 개발하는 방식으로 워드프레스로 이해함  
> https://www.samsungsds.com/kr/insights/nc-lc-tech.html  

아키텍트는 일부 특수한 상황에서 로우코드 환경이나 도구를 고려할 수 있지만, 그에 따른 한계를 사전에 인지하고 생태계에 어떤 영향을 미칠지 판단해야 한다.  

> 첫 회사 홈페이지는 워드프레스로 되어 있었음  
> php로 되어있지만 문제가 발생하거나 기능을 추가하고 싶어도 개발자는 대응 불가  


### 8.1.2 사례연구 PenultimateWidgets의 컴포넌트 재사용

PenultimateWidgets의 아키텍트는 재사용성이라는 목표를 달성했지만 한편으로 새로운 병목 현상을 초래했다.  
재사용성은 개발자가 새로운 것을 빠르게 구축할 수 있다는 이점을 낳는다.  
그러나 컴포넌트팀이 동적 균형의 혁신 속도를 따라잡지 못한다면, 기술 아키텍처 컴포넌트의 재사용성은 결국 안티패턴으로 전락하는 최후를 맞는다.  

> 슬랙 / 카프카 메세지 발행을 각 애플리케이션이 담당할 것인가? 아니면 슬랙 / 카프카 메세지 발행을 담당하는 애플리케이션을 운영할 것인가?  
> 슬랙 / 카프카 메시지 발행 자체는 단순한 기능이라 재사용이 가능하고, 카프카 메세지 발행을 담당하는 애플리케이션을 운영하면 네트워크 보안 관리 측면에서 이점이 있음  
> 하지만, SPOF 문제와 기능을 커스터마이징하기 어려움  

재사용 가능한 자산을 구축할 필요가 없다는 뜻이 아니다.  
이러한 자산이 가치를 창출하고 있는지 지속적으로 평가해야 한다는 뜻이다.  

1. 커플링 지점이 진화를 방해하거나 중요한 아키텍처 특성을 저해할 경우 포크 또는 복제를 통해 커플링을 끊어야 한다.  
2. 아키텍트는 아키텍처의 각종 특성을 평가하며 이들이 지속적으로 가치를 더하고 안티패턴으로 남겨지지 않도록 관리해야 한다.  

구축 당시 아키텍트가 내렸던 올바른 결정은 시간이 흐른 뒤 틀린 결정으로 뒤바뀌는 경우가 많다.  
원래의 결정은 틀리지 않았지만 생태계가 예상치 못한 방향으로 움직인 것이다.  

> 장기적인 개발 로드맵은 있어야하고, 구성원들은 반드시 로드맵을 이해할 필요가 있다고 생각 함  
> 그래야 그 당시의 배경과 장기적인 모습 사이의 트레이드 오프를 결정할 수 있지 않을까?  
> 컬리에서는 탈고도라는 명확한 목표가 존재했고, 구성원들은 잠재적으로 목표를 달성하도록 업무를 이어나갔음  
> 카카오페이손해보험은 장기적인 로드맵이 없는 듯. 춘추전국시대


### 8.1.3 안티패턴 벤더 킹

벤더 킹 안티패턴은 특정 벤더를 중심으로 구축된 아키텍처를 의미하며, 조직과 도구가 병적인 수준의 결합을 이룬다는 특징이 있다.  
벤더 소프트웨어를 구입한 회사는 벤더가 제공하는 플러그인을 이용해 자사 비즈니스의 핵심 기능을 구현하려 한다.  
그러나 대부분의 ERP 도구는 원하는 기능을 정확히 구현할 정도로 자유롭게 가공할 수 없다.  
아키텍트는 벤더를 아키텍처의 왕으로 추대하고, 이후로는 벤더의 결정을 따르게 된다.  

아키텍처의 중심에 외부 도구나 프레임워크가 배치되면 기술적인 측면과 비즈니스 프로세스 측면에서 개발자의 능력은 심각하게 제한된다.  


# 8장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조

결합도란 '모듈(클래스) 사이의 의존도를 나타내는 지표'라고 할 수 있다.
어떤 클래스가 다른 클래스에 많이 의존하고 있는 구조를 강한 결합이라 한다.  
느슨한 결합 구조로 개선하면 코드 변경이 쉬워진다.  


## 8.1 결합도와 책무

### 8.1.1 다양한 버그

```
class DiscountManager {

  boolean add(Product product) { ... }
  static int getDiscountAmount(int amount) { ... }
}

class SummerDiscountManager {
  DiscountManager discountManager;
  
  boolean add(Product product) {
     DiscountManager.getDiscountAmount()
  }
}
```

SummerDiscountManager가 DiscountManager의 getDiscountAmount()를 사용하고 있을 때 DiscountManager.getDiscountAmount()의 내용이 변경되면, SummerDiscountManager까지 영향을 받는다.  

### 8.1.2 로직의 위치에 일관성이 없음

- DiscountManager가 너무 많은 일을 하고 있음
- 상품 유효성 검증이 DiscountManager에 존재함
- 여름 할인 금액 계산을 위해 SummerDiscountManager가 DiscountManger를 호출하고 있음

어떤 클래스는 처리해야 할 작업이 집중되어 있는 반면, 어떤 클래스는 특별히 하는 일이 없다.  
그리고 어떤 클래스는 편의를 위해 다른 클래스의 메서드를 무리하게 활용하고 있다.  
이런 클래스 설계가 바로 책무를 고려하지 않은 설계이다.  

### 8.1.3 단일 책임 원칙

### 8.1.4 단일 책임 원칙 위반으로 발생하는 악마

책임을 대신 지는 클래스(DiscountManager)가 만들어지면, 다른 클래스가 제대로 성장할 수 없다.  

### 8.1.5 책임이 하나가 되게 클래스 설계하기

RegularAmount, RegularDiscountedAmount, SummerDiscountedAmount처럼 관심사에 따라 클래스를 분리한다.  

### 8.1.6 DRY 원칙의 잘못된 적용

RegularDiscountedAmount와 SummerDiscountedAmount의 코드가 거의 동일하여 중복 코드라고 생각할 수도 있다.  
책무를 생각하지 않고, 로직의 중복을 제거하면 안 된다.  
그렇게 되면 하나로 모인 로직이 여러 책무를 담당해야 한다.  

DRY는 각각의 개념 단위 내에서 반복을 하지 말라는 의미이다.  
**같은 로직, 비슷한 로직이라도 개념이 다르면 중복을 허용해야 한다.**  

중복 코드를 제거하려면, 일반화를 사용하면 된다.  
하지만 개념이 다른 코드를 일반화하면 안 된다.  
사양이 변경되 특정 유스케이스인지 판정하는 조건 분기를 추가하게 된다면, 이러한 로직은 더 이상 일반 로직이 아니다.  


## 8.2 다양한 강한 결합 사례와 대처 방법

### 8.2.1 상속과 관련된 강한 결합

상속은 주의해서 다루지 않으면, 곧바로 강한 결합 구조를 유발한다.  
그래서 이 책에서는 상속을 권장하지 않는다.  

#### 슈퍼 클래스 의존

슈퍼 클래스가 변경되면 서브 클래스에 영향이 간다.  
일반적으로 슈퍼 클래스는 서브 클래스를 싱경 쓰지 않고 변경하기 때문에 서브 클래스에 문제가 발생하기 쉽다.  

#### 상속보다 컴포지션

슈퍼 클래스 의존으로 강한 결합을 피하려면, 컴포지션을 사용하는 것이 좋다.  

```
// 상속
class FighterAttack extends Attack {
  int singleAttack() {
    return super.singleAttack() + 20;
  }
}

// 컴포지션
class FighterAttack {
  private final Attack attack;

  int singleAttack() {
    return attack.singleAttack() + 20;
  }
}
```

> 상속과 컴포지션 방식이 무슨 차이가 있는지 모르겠음  

#### 상속을 사용하는 나쁜 일반화

상속을 사용하면 서브 클래스가 슈퍼 클래스의 로직을 그대로 사용하게 되므로, 슈퍼 클래스가 공통 로직을 두는 장소로 사용된다.  
상속으로 무리하게 일반화하려고 하면 강한 결합이 발생하기 쉽다.  

하나의 로직으로 봐야 하는 흐름이 두 클래스에 분산되어 있는 설계는 좋지 않다.  

상속은 다른 동작을 구현하기 위해 사용하는 것이다.  
상속은 전략 패턴 등으로 조건 분기를 중릴 때 활용할 수 있다.  
또한 일반 할인과 여름 할인 로직은 RegularDiscount와 SummerDiscount에 캡슐화되어 있어야 한다.  

상속받는 쪽에서 차이가 있는 로직만 구현하는 템플릿 메서드라는 디자인 패턴도 있다.  
상속은 반드시 단일 책임 원칙을 염두에 두고 구현해야 한다.  

### 8.2.2 인스턴스 변수별로 클래스 분할이 가능한 로직

책임이 다른 메서드가 한 클래스 안에 정의되어 있으면, 여러 문제가 발생할 수 있다.  

### 8.2.3 특별한 이유 없이 public 사용하지 않기

특별한 이유 없이 public을 붙이면, 관계를 맺지 않았으면 하는 클래스끼리도 결합되어, 강한 결합 구조가 되어 버린다.  
접근 수식자로 가시성을 적절하게 제어해야 한다.  

패키지들의 불필요한 의존 관계를 피할 때 package private이 적절하다.  
패키지는 밀접한 클래스끼리 응집하게 설계한다.  

> MVC 레이어 vs 도메인 단위

### 8.2.4 private 메서드가 너무 많다는 것은 책임이 너무 많다는 것

책임이 다른 메서드는 다른 클래스로 분리하는 것이 좋다.  

### 8.2.5 높은 응집도를 오해해서 생기는 강한 결합

관련이 깊은 데이터와 논리를 한곳에 모은 구조를 응집도가 높은 구조라고 한다.  
그런데 이런 높은 응집도를 잘못 이해해서 강한 결합이 발생하는 경우가 있다.  

**응집도가 높다는 개념을 염두에 두고, 관련이 깊다고 생각되는 로직을 한곳에 모으려고 했지만, 결과적으로 강한 결합 구조를 만드는 상황은 매우 자주 일어난다.**  

### 8.2.6 스마트 UI

복잡한 계산 로직이 프런트 코드에 섞여 있으면, 디자인을 변경하다 기존 것이 동작하지 않거나 버그가 발생하기 쉽다.  

> 복잡한 계산 로직을 프런트에 두는게 좋은가? 백엔드에서 내려주는게 좋은가?

### 8.2.7 거대 데이터 클래스

데이터가 많아지다 보면 클래스를 '데이터를 편리하게 운반하는 역할'로 인식하고 데이터를 계속 추가하기 쉽다.
거대 데이터 클래스는 다양한 데이터를 가지므로, 수많은 유스케이에서 사용된다.  
결국 전역 변수와 같은 성질을 띠게 된다.  

> 거대 데이터 클래스는 테스트 코드를 작성하기 어렵게 만듬  

### 8.2.8 트랜잭션 스크립트 패턴

메서드 내부에 일련의 처리가 하나하나 길게 작성되어 있는 구조를 트랜잭션 스크립트 패턴이라고 한다.  
응집도가 낮아지고 결합은 강해지므로 변경하기 매우 어려워진다.  

### 8.2.9 갓 클래스

갓 클래스는 하나의 클래스 내부에 수천 ~ 수만 줄의 로직을 담고 있으며, 수많은 책임을 담당하는 로직이 난잡하게 섞여 있는 클래스이다.  
갓 클래스는 개발자의 시간을 빼앗고, 개발자를 피폐하게 맏느는 무섭고 악마 같은 힘이 있다.  

### 8.2.10 강한 결합 클래스 대처 방법

책임별로 클래스를 분할해야 한다.  




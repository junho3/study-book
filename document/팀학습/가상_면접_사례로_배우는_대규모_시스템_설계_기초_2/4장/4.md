# 4장 분산 메시지 큐

- 결합도 완화: 메시지 큐를 사용하면 컴포넌트 사이의 강한 결합이 사라진다.  
- 규모 확장성 개선
- 가용성 개선: 시스템의 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 큐와 계속 상호작용을 이어갈 수 있다.  
- 성능 개선: 생산자는 응답을 기다리지 않고도 메시지를 보낼 수 있다.  

> 컴포넌트 간 결합도는 완화되지만, 카프카의 의존성이 높아짐  
> 카프카 장애 시 Failover를 고려해야 함  
> 규모 확장 시 카프카는 파티션을 고려해야 함  
> 컨슈머에서 장애 발생을 대비 한 DLT 고려해야 함  
> 메시지 성격(중요도)에 따라 일관성을 고려해야 함 (inbox, outbox pattern)  

### 메시지 큐 대 이벤트 스트리밍 플랫폼

아파치 카프카나 펄사는 메시지 큐가 아니라 이벤트 스트리밍 플랫폼이다.  

> Kafka와 RabbitMQ의 차이점은 무엇인가요?
> https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/
>
> Kafka를 메시지 큐로 사용 중  

## 1단계: 문제 이해 및 설계 범위 확정

생산자는 메시지를 큐에 보내고, 소비자는 큐에 메시지를 꺼낼 수 있으면 된다.  

- 메시지의 형태는 텍스트만 지원
- 메시지 크기는 수 KB 수준
- 하나의 메시지를 여러 소비자가 수신 가능해야 함
- 메시지가 생성된 순서로 소비되야 함
- 데이터의 지속성은 2주
- 지원해야 하는 생산자와 소비자는 많을 수록 좋음
- 메시지는 '최소 한 번'을 반드시 지원해야 함
- 높은 수준의 대역폭을 제공해야 함

### 기능 요구사항

### 비기능 요구사항

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정으로 선택 가능해야 함
- 규모 확장성. 메시지 양이 급증해도 처리 가능해야 함
- 지속성 및 내구성. 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제되어야 함

### 전통적 메시지 큐와 다른 점

- 전통적인 큐는 메시지가 소비자에게 전달되기 충분한 기간 동안만 메모리에 보관
- 전통적인 메시지 큐는 생산된 순서와 소비되는 순서는 다를 수 있음


## 2단계: 개략적 설계안 제시 및 동의 구하기



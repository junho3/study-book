# 8.3 클래스 상속을 주의하라

## 8.3.1 클래스 상속은 문제가 될 수 있다

상속의 주요 특징 중 하나는 서브클래스가 슈퍼클래스에 의해 제공되는 모든 기능을 상속한다는 점이다.  

### 상속은 추상화 계층에 방해가 될 수 있다

슈퍼 클래스로부터 상속받은 메소드가 널리 사용될 수 있으며, 나중에는 상속 클래스를 수정할 수 없게 됨  

### 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다

> 하나의 인터페이스에 대해 A와 B 두 가지 구현체가 있을 때, A에서 B 기능을 사용하지 못 하는 문제라고 이해함  
> 서비스 클래스에 대해서는 상속을 사용한 경험은 없음  
> 그 만큼 기능에 대한 충분한 분석 시간이 주어진 적이 없기 때문  
> 
> 대신에 도메인 객체나 DTO는 코드의 응집도를 높이기 위해 상속을 활용하는 편임  
> ex) abstract class CreateSlipParam
>       ㄴ abstract class CreatePremiumReceiveSlipParam
>           ㄴ data class CreateApprovedPremiumReceiveSlipParam
>       ㄴ abstract class CreatePaymentSlipParam
>           ㄴ data class CreateApprovedKakaoPayCardSlipParam
>           ㄴ data class CreateApprovedKakaoPayMoneySlipParam
> 
> open fun toSaveSlipParam()과 같이 전표를 저장하기 위해 SaveSlipParam으로 변환하는 메소드는 거의 동일하기 때문에 상속 받아서 사용함  
>
> 코틀린은 open 키워드가 붙은 클래스만 상속 가능, open 키워드가 붙은 메소드만 오버라이드 가능  

## 8.3.2 해결책: 구성을 사용하라

클래스를 확장하기보다는 해당 클래스의 인스턴스를 가지고 있음으로써 하나의 클래스를 다른 클래스로부터 구성한다는 것을 의미한다.  

> 인프런 토비의스프링 강의에서 데코레이터 패턴을 소개하는데, 예제 8.15와 동일한 것 같음  
> 코틀린은 by 키워드로 delegation을 제공함. KotlinDelegation.kt 참고  

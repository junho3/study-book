# 8.1 의존성 주입의 사용을 고려하라

하위 문제에 대해 해결책이 항상 하나만 존재하는 것은 아니므로 하위 문제를 재구성할 수 있는 방식으로 코드를 작성하는 것이 유용할 수 있다.  
의준성 주입은 이를 달성하는 데 도움이 될 수 있다.  

## 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다

RoadMap의 특정 구현에 의존해서 코드를 구현하면 다른 구현으로 코드를 재설정할 수 없다.  

## 8.1.2 해결책: 의존성 주입을 사용하라

> Springboot는 ApplicationContext에 Bean을 관리하고, 알맞은 Bean으로 의존성 주입을 해줌  
> 일반적으로 클래스/메소드명으로 Bean이 생성됨  
> 만약 클래스/메소드명이 중복될 경우, 어플리케이션 기동 시 에러가 발생함  
> @Qualifier, @Primary 어노테이션으로 해결할 수 있으나, 개인적으로 팩토리 클래스를 만들어서 조건에 맞는 객체를 주입하는 편임  
> 
> 의존성 주입방법: setter 주입, @Autowired (필드 주입), 생성자 주입이 있고, 생성자로 주입해야함  
> 생성자로 주입해야하는 이유  
> - 불변 보장  
> - 순환참조 발생 시 어플리케이션 구동이 안됨, 필드 주입은 어플리케이션이 구동되고, 런타임에서 발생하기 때문에 위험함  

## 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라  

정적 함수에 과도하게 의존하는 것을 정적 매달림이라고 한다.  
특히 단위 테스트 코드에서 문제가 될 수 있는데, 그 이유는 정적 매달림이 많은 코드에 대해서는 **테스트 더블**을 사용할 수 없기 때문이다.

> 정적(static)함수로 인해 의존성 주입을 사용할 수 없다고 이해함  
> 예제 8.6은 극단적인 예시로 느껴짐  
> 보통은 정적 메소드를 구현하지 않는 편이고, fun of()와 같은 팩토리 메소드가 필요할 경우에는 사용  
> 코틀린의 확장함수를 애용하는 편  

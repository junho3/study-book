# Part 03. 이론

이론만으로는 설득할 수 없습니다.  
이론을 이해하면 최적의 응용이 가능합니다.  

- 언제 소프트웨어 설계 결정을 시작해야 하는가?
- 언제 소프트웨어 설계 결정을 중단하고 시스템의 동작을 변경해야 하는가?
- 다음 결정은 어떻게 내릴 것인가?

이러한 질문은 당장 합리적이고 논리적으로 답할 수 없습니다.  
그 시점에는 합리적이고 논리적인 답을 찾는 데 필요한 정보가 존재하지 않기 때문입니다.  

이론을 이해하면, 이러한 질문에 추측으로 답해야 할 때를 대비해 판단력을 키울 수 있습니다.  

모두 같은 목표를 달성하려고 하지만 서로 방법이 다를 뿐입니다.  
이론은 이러한 견해 차이가 더 깊어질 때 도움이 됩니다.  
서로 다른 목표를 달성하려고 할 때에도 이론적인 틀을 공유하는 것이 유용합니다.  

원칙에 동의하지 않더라도 서로의 원칙에 대해 논의할 수 있다면 더 빨리 합의할 수 있는 기회가 생깁니다.  
또한 서로에게서 배울 수 있는 기회도 있습니다.  

우리는 '소프트웨어 설계는 인간관계 속에서 벌어지는 활동'이라는 말로 이 모든 여정을 시작했습니다.  
이 책은 주로 자신과의 관계에 초점을 맞추고 있습니다.  


## Chapter 22. 요소들을 유익하게 관계 맺는 일

제가 어떤 내용을 설계라고 하는지 앞에서 예를 보셨을 겁니다.  
지금까지 개별적인 결정이 함께 이어져서 더 큰 목표를 달성하는 모습도 보셨을 것입니다.  
이제는 '소프트웨어 설계의 의미'에 대해 '요소들을 유익하게 관계 맺는 일'이라고 말할 수 있습니다.  

### 요소

- 프로그래밍 세계에서는, 토큰 > 식 > 문 > 함수 > 객체/모듈 > 시스템

요소에는 경계가 있습니다.  
그래서 어디서 시작하고 끝나는지 알 수 있습니다.  

또한 요소는 하위 요소를 포함합니다.  

### 관계 맺기

소프트웨어 설계에서 관계는 다음과 같은 것들이 있습니다.  
- 호출
- 발행
- 대기
- 참조

### 유익하게

하나의 설계 작업은 작은 하위 요소로 만든 거대한 수프를 만다는 일과 같은 것입니다.  

전역 네임스페이스를 사용한 어셈블리 언어를 생각해 보세요.  
잘 설계된 프로그램과 똑같이 동작하겠죠.  
하지만, 빠르게 변경할 수는 없을 것입니다.  
요소들 사이에는 분명 존재하지만, 잘 드러나지 않는 관계가 너무 많기 때문입니다.  

설계할 때, 기계를 위한 명령어가 아닌, 일종의 중간 요소를 만들면, 그 중간 요소들이 서로에게 도움이 되기 시작합니다.  

### 요소들을 유익하게 관계 맺는 일

```
caller()  
  return box.width() * box.height()

caller ()
  return box.area()
Box>>area()
  return width() * height()
```
설계 관점에서 Box.area()라는 새로운 요소를 만들고 caller() 함수와 box 객체 사이의 관계를 조정했습니다.  

- 요소 계층 구조
- 요소 사이의 관계
- 이러한 관계가 만들어내는 이점

이제 시스템의 구조와 동작을 좀 더 명확하게 구분할 때입니다.  


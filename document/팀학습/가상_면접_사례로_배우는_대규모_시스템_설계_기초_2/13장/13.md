# 13장 증권 거래소

## 1단계 문제 이해 및 설계 범위 확정

- 주식만 거래
- 새 주문을 넣을 수 있고, 채결되지 않은 주문은 취소할 수 있어야 함  
- 지정가 주문만 가능
- 시간 내 거래만 가능
- 호가 창의 정보는 실시간으로 갱신되어야 함
- 최소 수만 명 사용자가 동시에 거래할 수 있어야 함
- 100가지 주식 거래가 가능해야 함
- 거래소는 규제 시설이므로 위험성 점검이 가능해야 함
  - 특정 주식에 대한 조건을 위반하는 거래는 불가능
- 아직 체결되지 않은 주문이 있는 경우, 해당 주문에 이요된 자금은 다른 주문에 사용 불가

### 비기능 요구사항

- 가용성: 최소 99.99%
- 결함 내성
- 지연 시간: 왕복 지연 시간은 밀리초 수준이어야 하며, 특히 p99 지연 시간이 중요하다.  
- 보안

### 개략적 규모 추정

QPS: 10억(하루 주문 양) / 6.5시간(거래소 영업시간) x 3600 = 43,000
최대 QPS : 43,000 x 5 = 215,000 (장 시작 직후, 마감 직전에 거래량이 몰림)

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 증권 거래 101

#### 브로커

#### 기관 고객

#### 지정가 주문

#### 시장가 주문

#### 시장 데이터 수준

#### 봉 차트

#### FIX

금융 정보 교환 포로토콜


### 개략적 설계안

#### 거래 흐름은 지연 시간 요건이 엄격한 중요 경로다.  

1. 고객이 브로커를 통해 주문
2. 브로커가 주문을 거래소에 전송
3. 주문이 클라이언트 게이트웨이를 통해 거래소로 진입
4. 위험성 점검
5. 지갑에 주문 처리 자금이 충분한지 확인
6. 주문이 체결 엔진으로 전송
   - 매수 측과 매도 측에 각각 하나씩 총 두 개의 집행 기록 생성
   - 시퀀서는 주문 및 집행 기록을 일정 순서로 정렬
7. 주문 진햅 사실을 클라이언트에 전송

#### 시장 데이터 흐름

1. 체결 엔진은 주문이 체결되면 스트림을 만들고, 시장 데이터 게시 서비스로 전송
2. 시장 데이터 게시 서비스는 스트림 데이터로 봉 차트와 호가 창 구성
3. 시장 데이터는 실시간 분석 전용 스토리지에 저장
4. 브로커는 데이터 서비스를 통해 실시간 시장 데이터 조회 및 고객에게 전달

#### 보고 흐름

1. 보고 서비스는 주문 및 실행 기록에서 필요한 모든 값을 수집
2. 수집한 값을 정리하여 데이터베이스에 기록


### 거래 흐름

#### 체결 엔진

1. 각 주식에 대한 주문서와 호가 창을 유지 및 관리
2. 매수 주문과 매도 주문 연결
3. 집행 기록 스트림을 시장 데이터로 배포

가용성 높은 체결 엔진 구현체가 만드는 체결 순서는 결정론적이어야 한다.  
입력으로 주어지는 주문 순서가 같으면 체결 엔진이 만드는 집행 기록 순서는 언제나 동일해야 한다.  

#### 시퀀서

시퀀서는 체결 엔진에 주문을 전달하기 전에 순서 ID를 붙여 보낸다.  
체결 엔진이 처리를 끝낸 모든 집행 기록 쌍에도 순서 ID를 붙인다.  
입력 시퀀서와 출력 시퀀서 두 가지가 있으며, 각각 고유한 순서를 유지한다.  

입력되는 주문과 출력하는 실행 명령에 순서 ID를 찍는 이유
1. 시의성 및 공정성
2. 빠른 복구 및 재생
3. 정확한 1회 실행 보증

시퀀서는 순서 ID만 생성하는 것이 아니며, 메시지 큐 역할도 한다.

##### 주문 관리자

주문 관리자는 한쪽에서는 주문을 받고 다른 쪽에서는 집행 기록을 받는다.  
주문 상태를 관리한다.  

- 위험성 검토
- 거래에 필요한 자금 확인
- 주문을 시퀀서에 전달

주문 관리자는 빠르고 효율적이며 정확해야 한다.  
다양한 상태 변화를 관리해야 하는 문제 때문에 주문 관리자의 구현은 아주 복잡하다.  
이벤트 소싱은 주문 관리자 설계에 적합하다.  

##### 클라이언트 게이트웨이

- 인증
- 유효성 검사
- 처리율 제한
- 정규화
- FIXT 지원

지연 시간에 민감하고, 가벼워야 한다.  
고객 유형별(개인/기관)로 클라이언트 게이트웨이는 다양하다.  
주요 고려 사항은 지연 시간, 거래량, 보안 요구사항이다.  

##### 시장 데이터 흐름

체결 엔진에서 집행 기록을 수신하고 집행 기록 스트림에서 호가 창과 봉 차트를 만들어 낸다.  

##### 보고 흐름

- 거래 이력
- 세금 보고
- 규정 준수 여부 보고
- 결산

입력으로 들어오는 주문과 결과로 나가는 집행 기록을 잘 병합하여 보고서를 만든다.  


### API 설계

#### 주문

요청  
price: 지정가 주문의 가격. 자료형 Long

> 무조건 정수인지?

응답  
creationTime: 주문이 시스템에 생성된 시간. 자료형 Long

> Date, String 타입이 아니라 Long 타입인 이유가 있는지?

#### 집행

price: 체결 가격 자료형 String

> 요청에서는 Long, 집행에서는 String 무슨 차이인지?  
> 요청에서는 orderId가 String, 응답에서는 Long?

#### 호가 창/주문서

#### 가격 변동 이력(봉 차트)


### 데이터 모델

#### 상품, 주문, 집행

이 데이터는 자주 변경되지 않는다.  
아무 데이터베이스에나 저장 가능하며, 캐시를 적용하기 좋다.  

중요 거래 경로는 주문과 집행 기록을 데이터베이스에 저장하지 않는다.  
성능을 높이기 위해서 메모리에서 거래를 체결하고 하드디스크나 공유 메모리를 활용하여 주문과 집행 기록을 저장하고 공유한다.  
주문과 집행 기록은 빠른 복구를 위해 시퀀서에 저장하며, 데이터 보관은 장 마감 후에 실행한다.  

#### 호가 창

- 일정한 조회 시간
- 빠른 추가/취소/실행 속도
  - 가급적 O(1) 시간 복잡도를 만족해야 한다.
- 빠른 업데이트
- 최고 매수 호가 / 최저 매도 호가 질의
- 가격 수준 순회

이중 연결 리스트를 사용하여 모든 삭제 연산이 O(1)에 처리되도록 해야 한다.  

새 주문을 넣는다는 것은 리스트 마지막에 새 주문을 추가하는 것을 의미한다.  
이중 연결 리스트에서 이 연산은 O(1)에 처리된다.  

재문을 체결한다는 것은 리스트의 맨 앞에 있는 주문을 삭제한다는 것과 같다.  
이중 연결 리스트의 경우 이 연산의 시간 복잡도는 O(1)이다.  

주문을 취소한다는 것은 호가 창에서 주문을 삭제한다는 뜻이다.  
Map<OrderId, Order> 구조에서 O(1) 시간 내에 취소할 주문을 찾을 수 있다.  

```
{
    "Order1" => {},
    "Order2" => {},
}
```

#### 봉 차트

봉 차트에서 많은 종목의 가격 이력을 다양한 시간 간격을 사용해 추적하려면 메모리가 많이 필요하다.  

1. 미리 메모리를 할당해 둔 링 버퍼에 봉을 보관하면 새 객체 할당 횟수를 줄일 수 있다.
2. 메모리에 두는 봉의 개수를 제한하고 나머지는 디스크에 보관한다.

시장 데이터는 일반적으로 실시간 분석을 위해 메모리 상주 컬럼형 데이터베이스에 둔다.  


## 3단계: 상세 설계

### 성능

평균 지연 시간은 낮아야 하고, 전반적인 지연 시간 분포는 안정적이어야 한다.  

지연 시간을 줄이는 방법에는 두 가지가 있다.  
1. 중요 경로에서 실행할 작업 수를 줄인다.  
2. 각 작업의 소요 시간을 줄인다.
   1. 네트워크 및 디스크 사용량 경감
   2. 각 작업의 실행 시간 경감

중요 경로에는 꼭 필요한 구성 요소만 둔다.  
로깅도 지연 시간을 줄이기 위해 중요 경로에서는 뺀다.  

경쟁에서 앞서 나가기 위해 거래소는 주로 네트워크 및 디스크 액세스 지연 시간을 줄이거나 없애는 방안을 통해 중요 경로의 단대단 지연 시간을 수십 마이크로초로 줄였다.  
오랜 시간 동안 검증된 그 설계안의 요체는, 모든 것을 동일한 서버에 배치하여 네트워크를 통하는 구간을 없애는 것이다.  
같은 서버 내 컴포넌트 간 통신은 이벤트 저장소인 mmap를 통한다.  

> 모놀리틱을 의미하는 것인지?

애플리케이션 루프의 주된 작업 실행 메커니즘은 while 순환문을 통해 실행할 작업을 계속 폴링하는 것이다.  
엄격한 지연 시간 요건을 만족하려면 목적 달성에 가장 중요한 작업만 이 순환문 안에서 처리해야 한다.  
이 메커니즘의 목표는 각 구성 요소의 실행 시간을 줄여 전체적인 실행 시간 예측 가능하도록(p99) 보장하는 것이다.  

CPU 효율성을 극대화하기 위해 애플리케이션 루프는 단일 스레드로 구현하며, 특정 CPU 코어에 고정시킨다.  
애플리케이션 루프를 CPU에 고정하면 상당한 이점이 있다.

1. 컨텍스트 스위치가 없다.
2. 상태를 업데이트하는 스레드가 하나뿐이라서 락을 사용할 필요가 없고 잠금 경합도 없다.  

> 스레드를 유지시켜서 생성/삭제 비용도 줄인걸로 이해함  
> 옵저버 패턴 방식으로 while문을 돌면서 루프에 명령이 들어왔는지 판단하는 듯  

CPU를 고정하는 방안의 단점은 코딩이 더 복잡해진다는 것이다.  
엔지니어는 각 작업이 애플리케이션 루프 스레드를 너무 오래 점유하지 않도록 각 작업에 걸리는 시간을 신중하게 분석해야 한다.  

mmap는 파일을 프로세스의 메모리에 매핑하는 mmap(2)라는 이름의 POSIX 호환 UNIX 시스템 콜을 일컫는다.  
mmap(2)는 프로세스 간 고성능 메모리 공유 메커니즘을 제공한다.  
mmap(2)를 수행하면 공유 메모리에 접근해도 디스크 I/O는 발생하지 않는다.  

서버에서 mmap(2)를 사용하여 중요 경로에 놓인 구성 요소가 서로 통신할 때 이용할 메시지 버스를 구현하는 것이다.  
이 통신 경로를 사용하면 네트워크나 디스크에 접근하는 일은 없으며, 메시지 전송에 마이크로 초 미만이 걸린다.  

#### 이벤트 소싱

이벤트 소싱 아키텍처는 현재 상태를 저장하는 대신 상태를 변경하는 모든 이벤트의 변경 불가능한 로그를 유지한다.  
이 로그를 절대적 진실의 원천으로 삼는 것이다.  

모든 이벤트를 순서대로 재생하면 주문 상태를 복구할 수 있다.  

mmap 이벤트 저장소를 메시지 버스로 사용하는 이벤트 소싱 설계안은 카프카의 펍섭 모델과 아주 비슷하다.  
지연 시간에 대한 엄격한 요구사항만 없었으면 카프카를 사용할 수도 있었을 것이다.  

이벤트 소싱 아키텍처에서 더 효율적으로 동작할 수 있도록 조정한 부분이 몇 가지 있다.  

첫번째 차이는 주문 관리자가 컴포넌트에 내장되는 재사용 가능 라이브러리다.  
다른 컴포넌트가 주문 상태 업데이트 또는 질의를 위해 중앙화된 주문 관리자를 이용하도록 할 경우, 지연 시간은 길어질 수 있다.  

> 주문 관리자가 체결엔진의 일부로 포함된 것을 의미하는건지?  

또 다른 주요 차이점은 시퀀서가 없다는 점이다.  
이벤트 저장소에 보관되는 항목에는 sequence 필드가 있다.  
이 필드의 값은 이벤트 저장소에 있는 시퀀서가 넣는다.  

> 시퀀서가 이벤트 저장소의 일부로 포함된 것을 의미하는건지?

각 이벤트 저장소에는 하나의 시퀀서만 있다.  
시퀀서가 여러 개 있으면 이벤트 저장소에 쓰는 권한을 두고 결쟁하게 되므로 좋지 않다.  

### 고가용성

거래소가 다운될 수 있는 시간은 하루에 8.64초를 넘으면 안 된다는 뜻이다.  
따라서 서비스가 다운되면 즉각 복구해야 한다.  

- 거래소 아키텍처의 단일 장애 지점을 식별해야 한다.  
- 장애 감지 및 백업 인스턴스로의 장애 조치 결정이 빨라야 한다.

클라이언트 게이트웨이와 같은 무상태 서비스의 경우, 서버를 추가하면 쉽게 수평적 확장이 가능하다.  
하지만 주문 관리자나 체결 엔진처럼 상태를 저장하는 컴포넌트는, 사본 간에 상태 데이터를 복사할 수 있어야 한다.  

주 체결 엔진은 소위 주 인스턴스이고, 부 체결 엔진은 동일한 이벤트를 수신하고 처리하지만 이벤트 저장소로 이벤트를 전송하지는 않는다.  
주 인스턴스가 다운되면 부 인스턴스는 즉시 주 인스턴스 지위를 승계한 후 이벤트를 전송한다.  
부 인스턴스가 다운된 경우, 일단 재시작 하고 나서 이벤트 저장소 데이터를 사용해 모든 상태를 복구한다.  

체결 엔진과 박동 메시지를 주고받는 방안도 생각해 볼 수 있다.  
박동 메시지를 시간 내에 받지 못하면 체결 엔진에 문제가 있는 것으로 판단하는 것이다.  

주/부 체결 엔진 설계안의 문제점은 단일 서버 안에서만 동작한다는 것이다.  
고가용성을 달성하려면 이 개념을 여러 서버 또는 데이터 센터 전반으로 확장해야 한다.  

안정적 UDP를 사용하면 모든 부 서버에 이벤트 메시지를 효과적으로 브로드캐스트할 수 있다.  

### 결함 내성

- 주 서버가 다운되면 언제? 그리고 어떻게 부 서버로 자동 전환하는 결정을 내리는가?
- 부 서버 가운데 새로운 리더는 어떻게 선출하는가?
- 복구 시간 목표(RTO)는 얼마인가?
- 어떤 기능을 복구해야 하는가? 시스템이 성능 저하 상태로도 동작할 수있는가?

먼저 '장애가 생겼다는 것', 즉 다운되었다는 것이 실제로 무엇을 의미하는지 이해해야 한다.  
- 시스템에서 잘못된 경보를 전송하면 불필요한 장애 극복 절차, 즉 부 시스템으로의 자동 전환이 발생할 수 있다.  
- 코드의 버그로 인해 주 서버가 다운되었다면 부 서버로 자동 전환되더라도 같은 버그 때문에 부 서버까지 다운될 수 있다.  

새 시스템을 처음 출시할 때는 수동으로 장애 북구 조치를 수행한다.  
카오스 엔지니어링은 드물게 발생하는 까다로운 사례를 수면으로 이끌어내고 운영 경험을 빠르게 축적하는 데 좋은 방법이다.  

실전에서 검증된 리더 선출 알고리즘이 많다.  
여기서는 래프트를 예로 들어보겠다.  

리더는 팔로어에 데이터를 전송한다.  
래프트에서 작업 수행에 필요한 최소 투표수는 n(클러스터 구성원 수)/2 +1 이다.  

수신된 이벤트는 팔로어의 자체 mmap 이벤트 저장소에 저장된다.  

리더는 팔로어에게 박동 메시지를 보낸다.  
일정 기간동안 박동 메시지를 받지 못 한 팔로어는 새 리더를 선출하는 선거 타이머를 시작한다.  
가장 먼저 타이머가 타임아웃된 팔로어는 후보가 되고, 다른 나머지 팔로어에게 투표를 요청한다.  
그 팔로어가 과반수 이상의 표를 받으면 새로운 리더가 된다.  

증권 거래소의 경우 2등급 RTO를 달성해야 하는데, 서비스의 자동 복구가 반드시 가능해야 한다.  

래프트 메커니즘을 사용하면 데이터 사본은 많다.  
모든 클러스터 노드가 같은 상태를 갖도록 보장할 수도 있다.  
리더에 장애가 생기면 새로운 리더가 중단 없이 작업을 계속할 수 있다.

### 체결 알고리즘

FIFO 체결 알고리즘을 사용한다.  
특정 가격 수준에서 먼저 들어온 주문이 먼저 체결되고, 마지막 주문이 가장 나중에 체결된다.  

FIFO에 LMM을 결합한 알고리즘의 경우, FIFO 대기열보다 LMM에 먼저 일정 수량을 할당한다.  
그 비율은 LMM 회사가 거래소와 협상하여 결정한다.  

### 결정론

결정론에는 기능적 결정론과 지연 시간 결정론이 있다.  

기능적 결정론에서는 이벤트가 발생하는 실제 시간은 대체로 중요하지 않다.  
중요한 것은 순서다.  

지연 시간 결정론은 각 거래의 처리 시간이 거의 같다는 뜻이다.  
99번 백분위수 지연 시간(p99)이나 99.99번 백분위수 지연 시간을 재는 것이다.  
p99 지연 시간이 낮다는 것은 거래소가 거의 모든 거래에 안정적인 성능을 제공한다는 뜻이다.  

지연 시간 변동 폭이 커지면 원인을 조사해야 한다.  

### 시장 데이터 게시 서비스 최적화

MDP의 메모리는 무한대로 확장할 수 없으므로 봉 차트에는 상한선을 두어야 한다.  

원형 버퍼라고도 하는 링버퍼는 앞과 끝이 연결된 고정 크기 큐다.  
여기에 생산자는 계속 데이터를 넣고, 하나 이상의 소비자는 데이터를 꺼낸다.  
이 데이터 구조는 락을 사용하지 않는다.  

### 시장 데이터의 공정한 배포

안정적 UDP를 사용하는 멀티 캐스트는 한 번에 많은 참가자에게 업데이트를 브로드캐스트 하기 좋은 솔루션이다.  

#### 멀티캐스트

- 유니캐스트
- 브로드캐스트
- 멀티캐스트

### 코로케이션

많은 거래소가 해지 펀드 또는 브로커의 서버를 거래소와 같은 데이터 센터에 둘 수 있도록 하는 코로케이션 서비를 제공한다.  

### 네트워크 보안

1. 공개 서비스와 데이터를 비공개 서비스에서 분리하여 DDos 공격이 가장 중요한 클라이언트에 영향을 미치지 않도록 한다.  
2. 자주 업데이트 되지 않는 데이터는 캐싱한다.
3. 디도스 공격에 대비해 URL을 강화한다.
4. 효과적인 허용/차단 리스트 메커니즘을 사용한다.
5. 처리율 제한 기능을 활용한다.


## 4단계: 마무리

최근 암호화폐 산업이 발전함에 따라 많은 암호화폐 거래소가 클라우드 인프라를 사용하여 서비스를 배포한다.  
일부 탈중앙화 금융 프로젝트는 AMM 개념을 기반으로 하며, 심지어 호가 창도 없다.  




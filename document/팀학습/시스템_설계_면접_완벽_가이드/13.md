# 13 콘텐츠 배포 네트워크 설계하기

## 13.1 CDN의 장점

### 13.1.1 CDN 사용의 장점

- 낮은 지연 시간
  - 낮은 지연 시간은 SEO (검색 엔진 최적화) 개선 가능
  - 여러 데이터 센터 모니터링의 복잡성
- 확장성
- 낮은 단위 비용
- 높은 처리량
  - 많은 사용자와 높은 부하를 처리할수록 비용 감소
- 높은 가용성
  - 자사 서비스의 호스트가 실패할 때 대체 수단으로 적용 가능
  - 트래픽 급증 시 다른 데이터 센터로 리다이렉션 가능


### 13.1.2 CDN 사용의 단점

- 복잡성
  - 추가적인 DNS 조회
  - 추가적인 실패 지점
- 트래픽이 적을 경우 높은 비용
- 다른 CDN으로 마이그레이션 어려움
  - 특정 지역의 서비스 미제공
  - 폐업
  - 낮은 퀄리티
- 일부 국가나 조직이 특정 CDN IP 차단 가능성
- 보안과 프라이버시 문제


### 13.1.3 이미지 제공 CDN을 사용할 때 발생할 수 있는 예상치 못한 문제의 예

CDN은 GET 요청의 User-Agent 헤더를 읽어 요청이 웹 브라우저에서 온 것인지 확인하고, 업로드 된 PNG나 JPEG 대신 WebP 이미지를 반환할 수 있다.  
일부 서비스에서는 이상적일 수 있지만, 원본 형식으로 이미지를 반환받고자 하는 다른 브라우저 애플리케이션에서는 세 가지 선택지가 있다.  

> WebP 단점 (GPT 답변)
> - 오래된 브라우저의 미지원
> - 구형 기기에서 WebP 디코딩 진행 시 높은 CPU 연산과 베터리 소모를 요구하게 됨
> - 낮은 투명도 품질


1. 웹 애플리케이션에서 User-Agent 헤더 재정의
2. 서비스별로 서로 다른 이미지를 제공하도록 CDN 구성
3. 백엔드 서비스를 통한 라우팅


## 13.2 요구사항

- 기능 요구사항
  - 권한 있는 사용자는 디렉토리 생성
  - 10GB 크기 제한의 파일 업로드
  - 파일 다운로드
- 비기능 요구사항
  - 확장성
    - 페타바이트 규모의 저장 용량
    - 하루 테라바이트 수준의 다운로드 용량
  - 고가용성
  - 고성능
    - 가장 빠른 다운로드 속도
    - 동기화는 시간이 필요하므로 업로드 성능은 덜 중요함
  - 내구성
    - 파일이 손상돼서는 안 됨
  - 보안과 프라이버시


## 13.3 CDN 인증과 권한 부여

- 인증: 사용자 식별
- 인가: 사용자의 리소스 권한 식별
- 핫링킹: 사이트나 서비스 허가 없이 CDN 자산에 접근하는 것


- 쿠키 기반 인증
- 토큰 기반 인증
  - 메모리를 덜 사용함
  - IP 주소나 특정 사용자 계정으로 제한 가능

### 13.3.1 CDN 인증과 권한 부여 단계

클라이언트/사용자가 CDN에 HTTP 요청을 할 때는 CDN 사용 업체의 URL을 레퍼러 HTTP 헤더로 포함해야 한다.  
CDN은 승인된 레퍼러만 허용하므로 이는 승인되지 않은 레퍼러가 CDN을 사용하는 것을 막는다.  

하지만 이것은 적절한 보안 체계가 아니다.  
클라이언트는 레퍼러 헤더를 쉽게 위조할 수 있다.  

### 13.3.2 키 교체

피해를 제한하기 위해 고객의 키를 주기적으로 변경할 수 있다.  
새 키가 고객의 모든 시스템에 전파되는 데 시간이 걸리므로 그동안 고객은 이전 키와 새 키를 모두 계속 사용할 수 있다.  

> 옮긴 회사마다 꼭 한번쯤 키 만료로 인한 장애는 발생하는 듯  
> 팀캘린더에 1년에 한번 모든 키(인증서) 만료 확인하는 날을 등록함  


## 13.4 상위 수준 아키텍처

- API 게이트웨이
- 속도 제한 서비스
- 메타데이터 서비스
  - 어떤 저장소에서 읽고 쓸지 제어
- 스토리지 서비스
  - 초기 설계를 단순화하려면 모든 파일을 모든 데이터 센터에 복제할 수 있다.
- 원본
- 비밀 관리 서비스
  - 암호화 키 관리
- 로깅 서비스
  - 분석
  - 요금 청구


## 13.5 저장소 서비스

파일은 호스트의 파일 시스템에 저장해야 한다.  
가용성과 내구성을 위해 파일을 복제해야 하며, 각 파일을 여러 호스트에 할당해야 한다.  


### 13.5.1 클러스터 내부

주키퍼를 클러스터 내부 관리자로 포함하는 HDFS와 같은 분산 파일 시스템을 사용할 수 있다.  
주키퍼는 리더 선출을 관리하고 파일, 리더, 팔로워 간의 매핑을 유지한다.  

호스트 관리자는 클러스터 내부나 외부에 있을 수 있다.  
클러스터 내부 관리자는 노드를 직접 관리하고, 클러스터 외부 관리자는 작은 독립 노드 클러스터를 관리하며, 각각의 작은 클러스터는 자체적으로 관리한다.  

### 13.5.2 클러스터 외부

클러스터 외부 관리자가 관리하는 각 클러스터는 여러 데이터 센터에 분산된 3개 이상의 노드로 구성된다.  

### 13.5.3 평가


## 13.6 일반적인 작업

클라이언트가 IP 주소 대신 CDN 서비스의 도메인으로 요청하면 GeoDNS가 가장 가까운 호스트의 IP 주소를 할당하고, 여기서 로드 밸런서가 API 게이트웨이 호스트로 요청을 보낸다.  
API 게이트웨이는 캐싱을 포함한 여러 작업을 수행한다.  

### 13.6.1 읽기: 다운로드

- 메타데이터 서비스 역할
  - 레디스, SQL 둘 다 사용 가능
  - 파일의 저장 위치(호스트, 데이터 센터)
  - 호스트의 현재 상태와 부하 추적
  - 동일한 파일명 구분 (MD5, SHA)
  - 파일 소유권과 접근 제어

#### 다운로드 과정

클라이언트 > API 게이트웨이 > 속도 제한 서비스 > 메타데이터 서비스 > 스토리지 서비스

> API 게이트웨이가 오케스트레이션 역할을 한다는게 의외였음

#### 저장 시 암호화가 적용된 다운로드 과정

비밀 관리 서비스는 향후 요청을 위해 토큰을 호스트에 전달한다.  
저장소 서비스에서 암호화된 자산을 가져와 복호화하고 사용자에게 반환한다.  


### 13.6.2 쓰기: 디렉터리 생성, 파일 업로드, 파일 삭제

파일 이름을 식별자로 사용할 수 없다.  

CDN이 사용하는 총 저장 공간이 커짐에 따라 파일 중복 제거로 절약할 수 있는 비용이 추가 복잡성과 비용을 감수할 만큼 가치가 있을 수 있다는 점을 면접관과 논의할 수 있다.  

체크포인팅이나 벌크헤드와 유사한 프로세스를 개발해 파일을 청크로 나눠야 한다.  
그러면 클라이언트는 완료되지 않은 청크에만 업로드나 다운로드 작업을 반복하면 된다.  
이러한 업로드 프로세스를 멀티파트 업로드라고 하며, 같은 원리를 다운로드에도 적용할 수 있다.  

> 멀티파트(청크) 업로드 (GPT 답변)  
> 
> 파일을 분할 압축하는 개념이 아님  
> 브라우저는 Blob.slice(start, end)로 바이트 범위만 지정할 뿐, 큰 복사를 하지 않습니다. 매우 가볍습니다.  
> 서버/스토리지는 이 조각들을 받아 내부적으로 하나의 원본 파일로 조립합니다.  

주기적으로 불완전하게 업로드된 파일의 청크를 삭제하는 간단한 크론 작업이나 배치 ETL 작업을 구현할 수 있다.  

- 파일을 업로드하는 동안 복제해 CDN 전체에서 더 빨리 다운로드할 수 있게 하는 것은 추가적인 복잡성을 도입하며 필요할 가능성이 낮지만, 그런 고성능이 필요하면 논의해볼 수 있다.  
- 클라이언트가 첫 번째 청크를 다운로드하자마자 미디어 파일 재생을 시작할 수 있게 하는 것
- 클라이언트가 모든 데이터 센터에서 이 파일의 잠금을 획득하고, 모든 데이터 센터에서 이 작업을 수행한 다음, 잠금을 해제 한다.
- 특정 데이터 센터가 작업을 수행하고 변경 사항을 다른 데이터 센터에 전파하게 지정하는 단일 리더 접근 방식


#### 모든 데이터 센터에 파일 사본을 유지하지 않기

특정 파일은 주로 특정 지역에서 사용될 수 있으므로 모든 데이터 센터에 해당 파일의 사본을 포함할 필요는 없다.  
하지만 이는 내결함성을 위해 데이터 센터 내에 파일을 복제해야 함을 의미한다.  

예를 들어 비디오 파일은 모든 사용자에게 제공되고, 특정 언어의 동반 오디오 파일이 있을 수 있다.  
이 로직은 CDN이 아닌 애플리케이션 수준에서 처리할 수 있다.  


#### 배치 ETL 작업의 재조정

다양한 데이터 센터에 파일을 분산하고 수요를 충족하기 위해 적절한 수의 호스트에 파일을 복제하는 주기적인 배치 작업이 수행한다.  

> 계속해서 책에서 오케스트레이션(Saga 패턴)의 프로토콜을 메시지 큐로 표현하길래 찾아봄  
> 메시지 큐로 오케스트레이션의 프로토콜을 표현한 자료가 많아서 가능은 한 것 같음  
> 오케스트레이션의 장점은 단순하고 직관적인 로직제어인데, HTTP 대신 메시지큐를 사용했을 때의 이점을 이해하지 못 함


## 13.7 캐시 무효화


## 13.8 로깅, 모니터링, 경보

- CDN 미스를 기록하고 모니터링하며 낮은 긴급도의 경보를 트리거한다.  


## 13.9 미디어 파일 다운로드에 대한 기타 가능한 논의

미디어 파일을 완전히 다운로드하기 전에 재생할 수 있기를 바랄 수 있다.  
해결책은 미디어 파일을 더 작은 파일로 나누는 것이다.  




# 3장 데이터

이 장에서는 여정의 두 번째 부분인 **간접 쿼리 최적화**를 시작합니다.  

## 3-1 세 가지 비밀

### 인덱스가 도움이 되지 않을 수 있다  

- 인덱스는 성능에서 핵심이지만 좋은 인덱스라도 쿼리가 느릴 수 있음
- 인덱스와 인덱싱에 대해 학습한 후 엔지니어는 인덱스 스캔과 테이블 스캔을 피하는 데 너무 능숙해져서 인덱스 조회만 남게 되는데, 이는 바람직한 문제지만 여전히 아이러니한 면이 있음

각 상황에서 쿼리와 인덱스를 더 이상 최적화할 수 없다고 가정하면 다음 단계는 간접 쿼리 최적화 입니다.  

#### 인덱스 스캔

인덱스 스캔은 테이블이 커질수록 인덱스도 함께 커지므로 영향력이 점점 감소합니다.  
인덱스 스캔은 테이블의 행 수가 증가할수록 인덱스 스캔을 사용하는 쿼리에 대한 응답 시간도 늘어나므로 반드시 지연 시간이 발생합니다.  

MySQL은 느슨한 인덱스와 부분 인덱스를 지원하지 않습니다.  
- 느슨한 인덱스
  - 데이터 페이지의 한 부분만 가지고 있음
  - 인덱스 용량이 작음
  - 속도가 느림
- 밀집 인덱스
  - 데이터마다 모든 인덱스 페이지를 가지고 있음
  - 인덱스 용량이 큼
  - 속도가 빠름
- 부분 인덱스
  - 테이블의 일부분에만 구축된 인덱스
  - 조건식을 만족하는 테이블 행에 대해서만 항목을 포함

#### 행 찾기

인덱스 조회를 사용하는 느린 쿼리를 최적화할 때 확인하는 첫 번째 쿼리 메트릭은 조회된 행입니다.  
좋은 인덱스를 사용하더라도 쿼리가 너무 많은 행을 검사할 수도 있습니다.  

`type`이 아래 4가지 유형과 다르다면 `rows`와 조회된 쿼리 메트릭 행에 주의를 기울여야 합니다.  
- system
- const
- eq_ref
- unique_subquery

세컨더리 인덱스는 행을 읽기 위해 프라이머리 키에서 두 번째 조회가 필요하므로, 선택도가 매우 낮은 인덱스를 피하고 더 나은 인덱스가 없다는 가정하에 풀 테이블 스캔을 수행하는 것이 더 빠를 수 있습니다.  
접근 방법이 테이블 스캔(type: ALL)이지만 MySQL이 사용할 수 있는 인덱스(possible_keys)가 있을 때는 EXPLAIN 계획에서 이를 감지할 수 있습니다.  
MySQL이 선택하지 않은 실행 계획을 보려면 `FORCE INDEX`로 쿼리를 `EXPLAIN`하여 `possible_keys`필드에 나열된 인덱스를 사용하세요.  
실행 계획 결과는 많은 행을 포함하는 인덱스 스캔(type: index)일 것이고, 이는 MySQL이 대신 테이블 스캔을 선택하는 이유입니다.  

카디널리티는 일정하게 유지되지만 행 수가 증가하면 선택도가 감소합니다.  

#### 테이블 조인

테이블을 조인할 때 각 테이블의 몇 개 행이 성능을 빠르게 떨어뜨립니다.  
중첩 반복 조인 알고리즘은 조인을 위해 접근한 전체 행 수가 각 테이블에 대해 접그한 행의 곱이었습니다.  

때때로 잘못된 조인에 대한 해결책은 다른 테이블에서 더 나은 인덱스를 생성하여 MySQL이 조인 순서를 변경할 수 있도록 하는 것입니다.  

인덱스 조회가 없으면 테이블 조인이 힘들어집니다.  

#### 작업 세트 크기

인덱스는 메모리에 있을 때만 유용합니다.  
쿼리가 조회하는 인덱스 값이 메모리에 없으면 MySQL은 디스크에서 값을 읽습니다.  
디스크에서 읽는 것이 메모리에서 읽는 것보다 훨씬 느리지만, 한 가지 주요 문제는 인덱스가 메모리를 놓고 경쟁한다는 것입니다.  

MySQL이 자주 사용하는 인덱스 값을 메모리에 유지하려고 시도하기 때문에, 인덱스 사용으로 인해 스토리지 입출력이 증가하게 됩니다.  
이러한 입출력 증가는 두 가지 이유로 드물게 발생합니다.  
첫째, MySQL은 자주 사용하는 인덱스 값을 메모리에 유지하는 데 탁월합니다.  
둘째, 자주 사용하는 인덱스 값과 이들이 참조하는 프라이머리 키 행을 **작업 세트**라고 하며, 일반적으로 테이블 크기에서 작은 비율을 차지합니다.  
DBA는 보통 전체 데이터 크기의 10%에 해당하는 메모리를 할당하며 표준 메모리값(64GB, 128GB)에 맞춥니다.  

작업 세트의 크기가 사용할 수 있는 메모리보다 훨씬 커지면 인덱스가 도움이 되지 않을 수 있습니다.  
스케일업은 지속 가능한 접근 방식이 아닙니다.  
최선의 해결책은 큰 작업 세트에 원인이 되는 데이터 크기와 접근 패턴을 해결하는 것입니다.  

애플리케이션이 단일 MySQL 인스턴스에서 작업 세트의 크기가 적절한 크기의 메모리에 맞지 않을 정도로 많은 데이터를 저장하고 접근해야 할 때 해결책은 **샤딩**입니다.  


### 데이터가 적을수록 좋다

현재 증가율을 기반으로 향후 4년 동안의 데이터 크기를 추정합니다.  
미래의 데이터 크기를 현재 하드웨어와 애플리케이션 설계로 다룰 수 없다면 문제가 되기 전에 지금 해결하세요.  


### QPS가 낮을수록 좋다

#### QPS는 숫자에 불과하며 원시 처리량을 측정한 값이다

QPS가 높다는 것은 쿼리 응답 시간이 좋다는 의미이기도 합니다.  

#### QPS값은 객관적인 의미가 없다

평균 2,000QPS라면 100QPS는 중단을 나타내는 급격한 하락일 수 있습니다.  
그러나 평균 300QPS라면 100QPS는 정상적인 변동일 수 있습니다.  
QPS는 시간, 요일, 계쩔, 휴일 등과 같은 외부 요인에도 영향을 받습니다.  

#### QPS를 높이기는 어렵다

데이터 크기는 1GB에서 100GB로 100배 정도는 비교적 쉽게 증가할 수 있습니다.  
그러나 QPS를 100배 높이기는 매우 어렵습니다.  

요즘을 말하자면 QPS는 도움이 되지 않습니다.  
그것은 자산이라기보다는 부채에 가깝습니다.  
따라서 QPS가 낮을수록 좋습니다.  

> 가벼운 쿼리를 여러번 호출하기 vs 무거운 쿼리를 한번 호출하기


## 3-2 최소 데이터 원칙

최소 데이터 원칙을 '필요 데이터만 저장과 접근'으로 정의합니다.  

### 데이터 접근

필요 이상으로 많은 데이터에 접근하지 마세요.  

효율적인 데이터 접근 점검표
- 필요한 열만 반환
- 쿼리 복잡성 감소
- 행 접근 제한
- 결과 세트 제한
- 행 정렬 피하기

습관이 될 때까지 반복해 사용하면 점검표를 완전히 무시하는 엔지니어들보다 MySQL로 더 큰 성과와 성능을 얻게 됩니다.  

#### 필요한 열만 반환

쿼리는 필요한 열만 반환해야 합니다.  
`SELECT *` 쿼리를 실행하지 마세요.  
이는 테이블에 `BLOB`, `TEXT` 또는 `JSON` 열이 있을 때 특히 중요합니다.  

> Jpa의 단점

#### 쿼리 복잡성 감소

쿼리는 될 수 있는 한 단순해야 합니다.  
**쿼리 복잡도**는 쿼리를 구성하는 모든 테이블, 조건, SQL절을 나타냅니다.  

복잡한 쿼리는 MySQL이 아니라 엔지니어에게 문제입니다.  
쿼리가 복잡할수록 분석하고 최적화하기가 더 어렵습니다.  

> 인수인계 하면서 한 마지막 유언
> "수백 줄의 마감 쿼리를 애플리케이션에서 병렬 처리할 수 있도록 해야 한다."

#### 행 접근 제한

쿼리는 될 수 있는 한 적은 수의 행에 접근해야 합니다.  
데이터 증가와 단순한 실수가 교차하는 지점에서 가장 중요한 원인은 **범위와 목록을 제한하지 않는 것**입니다.

`LIMIT`절은 행을 일치시킨 후 결과 세트에 `LIMIT`가 적용되므로 행 접근을 제한하지 않습니다.  
`ORDER BY LIMIT` 최적화는 예외입니다.  

```
SELECT * FROM elem WHERE a > 'Ag' ORDER BY a;
``` 
LIMIT 절이 없으면 쿼리는 8개의 행에 접근합니다.  

```
SELECT * FROM elem WHERE a> 'AG' ORDER BY a LIMIT 2;
```  
`LIMIT 2`절이 있을 때도 `rows: 8`을 보고합니다.  
처음 두 행이 유일한 테이블 조건과 일치한다는 것을 알 수 있습니다.  

- 쿼리는 인덱스를 사용합니다.  
- ORDER BY 열은 해당 인덱스의 맨 왼쪽 접두사입니다.
- Extra 필드는 "Using filesort"을 보고하지 않습니다.

`Rows_examined: 2`는 MySQL이 `ORDER BY LIMIT` 최적화를 사용하여 8개 행 모두가 아닌 2개 행에만 접근했음을 증명합니다.  

애플리케이션 입력을 요청당 1,000개의 값으로 제한하는 것입니다.  

테이블을 조인할 때 행 접근을 제한하는 것도 중요합니다.  

> [if kakao 2022] Batch Performance를 고려한 최선의 Reader  
> https://tech.kakaopay.com/post/ifkakao2022-batch-performance-read/#mysql-limit-offset  





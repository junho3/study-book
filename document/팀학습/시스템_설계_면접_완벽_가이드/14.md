# 14 문자메시징 앱 설계

정확히 한 번 전달(exactly-once delivery)을 고려하는 첫 번째 예시 시스템이다.  

## 14.1 요구사항

- 기능 요구사항
  - 실시간, 결과적 일관성
  - 채팅방은 2명 ~ 1,000명
  - 텍스트만 가능, UTF-8, 문자당 최대 32비트, 메시지 크기 최대 4KB
  - 안드로이드, iOS, 윈도우...
  - 전송 확인과 읽음 확인
  - 최대 10MB의 과거 메시지 조회 및 검색
  - 메시지 본문은 비공개
- 비기능 요구사항
  - 확장성: 동시 사용자 10만 명, 1분마다 4KB, 쓰기 속도 400MB/분
  - 고가용성: 99.99%
  - 고성능: P99 10초
  - 보안과 프라이버시
  - 일관성: 메시지의 엄격한 순서는 필요 없음


## 14.2 초기 구상

얼핏 보면 9장에서 설명한 알림/경보 서비스와 유사해 보인다.  


## 14.3 초기 고수준 설계

- 메시징 서비스는 각 수신자와 열린 웹소켓 연결을 유지해야 한다.
- 발신자는 각 수신자의 공개 키로 메시지를 암호화해야 한다.
- 예측 불가능한 트래픽 급증을 처리해야 한다.

기능 요구사항을 제공하고 그 외 비기능 요구사항을 최적화하기 위해 별도의 서비스를 만든다.  

- 발신자 서비스
  - 발신자로부터 메시지를 받아 수신자에게 전달
  - 메시지 서비스에 기록
- 메시지 서비스
  - 발신자와 수신자는 이 서비스에 메시지를 요청
- 연결 서비스
  - 사용자의 활성과 차단 연결을 저장하고 검색
  - 연락처에 사용자 추가
  - 메시지 차단


## 14.4 연결 서비스


### 14.4.1 연결 만들기

사용자의 연결은 사용자의 기기 또는 브라우저 쿠키나 로컬스토리지에 저장돼야 한다.  
따라서 연결 서비스는 사용자가 기기를 변경하는 경우에 대비한 이 데이터의 백업이 되거나 사용자의 여러 기기 간에 이 데이터를 동기화하는 역할을 한다.  


### 14.4.2 발신자 차단

차단은 모든 계층(클라이언트와 서버)에서 구현해야 한다.  

#### 트래픽 줄이기

서버로의 트래픽을 줄이기 위해 차단된 수신자 연결은 사용자의 기기에 저장돼야 한다.  

#### 즉시 차단/차단 해제 허용

차단 엔드포인트를 사용할 수 없을 경우를 대비해 클라이언트는 발신자를 차단했다는 사실도 기록할 수 있다.  
이 요청은 기기의 데드 레터 큐로 보내고 해당 엔드포인트를 다시 사용할 수 있을 때 서버로 보낼 수 있다.  

#### 앱 해킹


#### 가능한 일관성 문제

요청의 순서를 결정하기 위해 기기의 타임스탬프를 요청에 첨부하는 것은 해결책이 아니다.  
기기의 시계를 완벽하게 동기화할 수 없기 때문이다.  


#### 공개 키

기기가 앱을 설치하고 처음 시작할 때 공개-비공개 키 쌍을 생성한다.  
공개 키를 연결 서비스에 저장해야 한다.  

키 변경은 드문 이벤트일 것이므로 예측하지 못한 트래픽 급증을 일으키지 않을 것이며, 연결 서비스는 메시지 브로커링이나 카프카를 사용할 필요가 없을 것이다.  

발신자가 오래된 공개 키를 사용해 메시지를 암호화하면 수신자가 복호화한 후 이상한 문자로 나타날 것이다.  
발신자는 SHA-2와 같은 암호화 해시 함수로 메시지를 해싱하고 이 해시를 메시지의 일부로 포함할 수 있다.  
수신 기기는 복호화된 메시지를 해싱하고 해시가 일치할 때만 복호화된 메시지를 수신 사용자에게 표시할 수 있다.  


## 14.5 발신자 서비스

중요한 기능의 디버깅 가능성과 유지보수성을 최적화하기 위해 가능한 한 간단하게 만들어야 한다.  

### 14.5.1 메시지 보내기

메시지 서비스는 메시지 요청을 받아 새 메시지 카프카 토픽에 생성한 다음, 발신자에게 200 성공을 반환한다.  
메시지 생성기는 새 메시지 카프카 토픽에서 소비하고 각 수신자에 별도의 메시지를 생성한다.  
호스트는 레디스 같은 분산 인메모리 데이터베이스에 체크포인트를 쓸 수도 있다.  

> 메시지를 주고 받을 때 웹 소켓을 사용하는게 아닌지?  
> 낮은 지연시간과 높은 가용성이 필요한데, 카프카 acks 옵션은 어떻게 설정하는게 좋을까?  

메시지 서비스가 사용자의 어떤 기기가 해당 메시지를 받지 않았는지 기록하고 이를 사용해 각 기기가 받지 않은 메시지만 검색할 수 있는 엔드포인트를 제공하는 것이다.  


### 14.5.2 기타 논의사항

지수 재시도와 백오프, 데드 레터 큐와 같은 실패한 요청에 대한 일반적인 기술을 구현할 수 있다.  

큐와 같은 풀 메커니즘을 사용하면 결과적 일관성을 허용하지만 실시간 메시징에는 적합하지 않다.  


## 14.6 메시지 서비스

- 종단 간 암호화
  - 수신자가 공개-비공개 키 쌍을 생성한다.
  - 발신자가 수신자의 공개 키로 메시지를 암호화한 다음 수신자에게 메시지를 보낸다.
  - 수신자가 자신의 비공개 키로 메시지를 복호화한다.

메시지 서비스는 높은 쓰기 트래픽과 낮은 읽기 트래픽을 예상하며, 이는 카산드라의 이상적인 사용 사례다.  


## 14.7 메시지 전송 서비스

### 14.7.1 소개

사용자의 기기가 서버가 되는 것은 일반적으로 다음과 같은 이유로 불가능하다.  

- 보안: DDos, 하이재킹 등 악성 프로그램을 기기에 보낼 수 있다.
- 기기로의 네트워크 트래픽 증가: 소유자에게 증가된 트래픽에 대한 과도한 요금이 부과될 수 있다.
- 전력 소비

이전 호스트가 멈추기 전에 일부 수신자에게는 메시지를 성공적으로 전달했지만 모든 수신자에게는 전달하지 못했을 수도 있다.  
새 호스트가 같은 메시지를 다시 전달해 중복을 일으키는 것을 어떻게 피할 수 있을까?  

- 각 메시지를 보낼 때마다 체크포인트를 기록하는 방식이다.  
- 모든 수신자에게 메시지를 다시 보내고 수신자의 기기에 의존하여 메시지를 중복 제거하게 하는 것이다.  
- 발신자가 몇 분 후 확인을 받지 못하면 메시지를 다시 보내는 것이다.  


### 14.7.2 고수준 아키텍처

모든 클라이언트는 웹소켓을 통해 발신자 서비스에 연결되므로 호스트는 거의 실시간 지연으로 클라이어트에 메시지를 보낼 수 있다.  

사진이나 동영상 같은 파일을 처리하기 위한 자체 호스트 클러스터가 있는 별도의 메시징 서비스를 만들고 이 서비스를 텍스트를 처리하는 메시징 서비스와 독릭접으로 확장할 수 있다.  

호스트가 메시지를 받으면 메모리에 ㅁ메시지를 저장하는 동시에 스레드를 분기해 카프카 큐에 메시지를 생성할 수 있다.  
레디스는 빠른 쓰기가 가능하지만 더 높은 내결함성을 위해 여전히 카프카를 사용해 쓰기를 버퍼링할 수 있다.  

일관된 해싱, 라운도 로빈이나 가중 라운드 로빈을 사용해 ID를 호스트에 할당할 수 있지만, 이는 빠르게 특정 호스트가 불균형한 부하를 처리하는 핫 샤드 문제로 이어질 수 있다.  


### 14.7.3 메시지 전송 단계


### 14.7.4 몇 가지 질문

- 수신자에게 메시지를 전달하거나 발신자에게 '전송됨' 알림을 전달하기 전에 서버가 멈추면 어떻게 되는가?
- 메시지 순서를 해결하려면 어떤 접근 방식을 취해야 하는가?
  - 각 메시지에는 발신자 클라이언트의 타임스탬프가 있다.
  - 나중 메시지가 이미 수신자의 기기에 전달됐다면 이전 메시지를 버리는 것이다.
  - 수신자 클라이언트가 메시지를 받으면 더 나중 타임스탬프를 가진 메시지가 있는지 확인하고, 있다면 적절한 오류 메시지와 함께 422 오류를 반환할 수 있다.


### 14.7.5 가용성 개선

호스트가 실패하면 호스트 할당자는 즉시 모든 클라이언트를 대기 호스트에 할당할 수 있다.  

다운타임을 최소화하는 설계는 미니 클러스터를 만드는 것이다.  
각 호스트에 하나나 두 개의 보조 호스트를 할당한다.  
주 호스트는 모든 요청을 지속적으로 보조 호스트로 전달해 보조 호스트가 주 호스트와 최신 상태를 유지하고 항상 주 호스트 역할을 수행할 준비가 돼 있게 한다.  


## 14.8 검색


## 14.9 로깅, 모니터링, 경보

- 사용자 프라이버시를 위해 모든 필드, 발신자, 수신자, 본문, 전송 확인, 읽음 확인 등을 포함한 메시지 내용을 절대 로깅하지 않는다.  
- 높은 속도로 메시지를 보내는 클라이언트와 같은 사기와 비정상적인 상황도 모니터링한다.


## 14.10 기타 논의 가능한 주제




# 10장 실시간 게임 순위표

## 1단계: 문제 이해 및 설계 범위 확정

- 경기에서 승리하면 포인트 획득
- 모든 플레이어가 순위표에 포함
- 매달 새로운 토너먼트를 시작할 때마다 새로운 순위표 생성
- 상위 10명과 특정 사용자의 순위 표시
- DAU 500만명, MAU 2,500만명
- 각 선수는 하루 평균 10경기
- 점수가 같을 경우 순위는 동일
- 순위표는 실시간 또는 준실시간

### 기능 요구사항

### 비기능 요구사항

- 일반적인 확장성, 가용성 및 안정성 요구사항

### 개략적 규모 추정

게임 사용량이 균등한 경우는 별로 없으며, 북미 지역 기준 저녁 시간이 피크 시간대일 가능성이 높다.  
이를 고려하기 위해 최대 부하는 평균 5배라고 가정, 초당 최대 250명의 사용자를 감당할 수 있어야 한다.

- 사용자 점수 획득 QPS: 최대 2,500 QPS  
- 상위 10명 순위표 가져오기 QPS: 평균 50 QPS


## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 설계

#### POST /v1/scores

#### GET /v1/scores

#### GET /v1/scores{:user_id}


### 개략적 설계안

클라이언트 > 게임 서비스 > 순위표 서비스 > 순위표 저장소

#### 클라이언트가 순위표 서비스와 직접 통신해야 하나?

클라이언트가 점수를 계산하면 중간자 공격을 할 수 있기 때문에 보안상 안전하지 않다.  
따라서 점수는 서버가 설정해야 한다.  

온라인 포커처럼 서버가 게임 전반을 통솔하는 경우에는 게임 서버가 모든 게임 로직을 처리하고, 클라이언트의 개입 없이도 점수를 정할 수 있다.  

#### 게임 서비스와 순위표 서버 사이에 메시지 큐가 필요한가?

데이터를 다른 곳에서도 사용하거나 여러 기능을 지원해야 한다면 카프카에 데이터를 넣는 것이 합리적일 수 있다.  

> 게임은 실시간 결과가 중요한데, 큐가 적합한건지?

### 데이터 모델

#### 관계형 데이터베이스

점수 갱신 쿼리  
`UPDATE leaderboard set score = score + 1 where user_id = 'xxxx';`
> Lock 필요

사용자 순위표 쿼리  
`SELECT (@rownum := @rownum + 1) AS rank, user_id, score FROM leaderboard ORDER BY score DESC;`

- 레코드가 많아질 수록 성능이 너무 나빠지는 문제가 있다.  
  - 사용자 순위를 포악하려면 모든 사용자를 순위표의 정확한 위치에 정렬해야 한다.  
- 데이터가 지속적으로 변경되기 때문에 캐시 도입도 불가능하다.  
- 일괄 작업으로 수행하면 RDS를 사용하는 것도 가능하겠지만, 실시간 순위를 보여주어야 한다는 요구사항에 부적합하다.  
- INDEX를 추가하고 LIMIT 절을 사용할 수 있지만, 규모 확장성이 좋지 않다.  

#### 레디스

메모리에서 동작하므로 빠른 읽기 및 쓰기가 가능하다.  
순위표 시스템 설계 문제를 해결하는 데 이상적인 정렬 집합이라는 자료형을 제공한다.  

정렬 집합은 내부적으로 해시 테이블과 스킵 리스트라는 두 가지 자료 구조를 사용한다.  
해시 테이블은 사용자의 점수를 저장하기 위해서, 스킵 리스트는 특정 점수를 딴 사용자들의 목록을 저장하기 위해 쓰인다.  

정렬된 연결 리스트에 다단계 색인을 두는 구조다.  

레디스 연산 목록
- ZADD: 기존에 없던 사용자를 집합에 삽입 O(log(n))
- ZINCRBY: 사용자 점수를 지정된 값만큼 증가 O(log(n))
  - ZINCRBY leaderboard 1 'user_id': user_id 값을 1 증가
- ZRANGE/ZREVRANGE: 점수에 따라 정렬된 사용자 중에 특정 범위에 드는 사용자들을 가져옴 O(log(n) + m)
  - ZREVRANGE leaderboard 0 9 WITHSCORES: 0~9 조회
- ZRANK/ZREVRANK: 오름차순/내림차순 정렬하였을 때 특정 사용자의 위치를 가져옴 O(log(n))
  - ZREVRANK leaderboard 'user_id': user_id 순서 조회

> 유사한 Redis 명령이라도 시간복잡도가 다름  
> 시간 복잡도를 반드시 확인할 필요가 있음  

#### 저장소 요구사항

`26B (ID 24자) x 2,500만 = 650MB` 최신 레디스 서버 한 대만으로 데이터 저장 가능  
최대 QPS 2500/초 단일 레디스 서버로도 충분히 감당 가능  
레디스에 Read Replica를 둬서 장애 발생 시 Master로 승격  

쉬운 성능 최적화 방안은 가장 자주 검색되는 상위 10명의 사용자 정보를 캐시하는 것이다.  
데이터 양은 많지 않다.  

> 일별 보고서 로직을 구성할 때도 당일 데이터는 DB에서 조회하고, 최근 1일 ~ 29일 데이터는 캐시로 만들어 둠  


## 3단계: 상세 설계

### 클라우드 서비스 사용 여부

#### 자체 서비스를 이용하는 방안

#### 클라우드 서비스를 이용하는 방안

AWS API 게이트웨이와 AWS 람다의 두 가지 기술을 사용한다.  
이제 막 게임을 만들려는 상황이라면 서버리스 기술을 고려해 보기 바란다.  

> AWS Lambda 장단점과 운영의 어려움  
> https://umanking.github.io/2023/03/06/aws-lambda-pros-and-cons/  
> 
> AWS 람다 성능 개선 (Cold Start 해결) 전략 4가지  
> https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-%EB%9E%8C%EB%8B%A4-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0-Cold-Start-%ED%95%B4%EA%B2%B0  


### 레디스 규모 확장

원래 규모의 100배인 5억 DAU를 처리해야 한다고 해 보자.  
최악의 경우 저장 용량은 650GB(650MB x 100)까지 필요하고, 250,000(2,500 x 100) QPS의 질의를 처리할 수 있어야 한다.  
이 정도 규모를 감당하려면 샤딩이 필요하다.  

#### 데이터 샤딩 방안

##### 고정 파티션

고정 파티션은 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.  
이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분포되어야 한다.  
특정 사용자의 점수를 입력하거나 갱신할 때는 해당 사용자가 어느 샤드에 있는지 알아야 할 것이다.  
사용자 ID와 점수 사이의 관계를 저장하는 2차 캐시를 통해 알아내면 성능을 더 높일 수 있을 것이다.  
**사용자의 점수가 높아져서 다른 샤드로 옮겨야 할 때는 기존 샤드에서 해당 사용자를 제거한 다음 새 샤드로 옮겨야 핟나는 점에 유의해야 한다.**
특정 샤드에 속한 모든 사용자 수는 `info keyspace` 명령을 실행하면 O(1) 시간에 알아낼 수 있다.  

##### 해시 파티션

레디스 클러스트를 사용하는 것으로, 사용자들의 점수가 특정 대역에 과도하게 모여 있을 경우에 효과적이다.  
레디스 클러스터는 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공한다.  
각각의 키가 특정한 해시 슬롯에 속하도록 하는 샤딩 기법을 사용한다.  
총 16384개 해시 슬롯이 있으며, CRC16(key) % 16384의 연산을 수행하여 어떤 키가 어느 슬롯에 속하는지 계산한다.  

점수를 갱신하려면 해당 사용자의 샤드를 찾아(CRC16(key) % 16384) 거기서 해당 사용자 점수를 변경하기만 하면 된다.  
모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집 접근법을 사용해야 한다.  

이 방법에는 다음과 같은 문제가 있다.
- 상위 k개의 결과를 반환해야 하는 경우, 각 샤드에서 많은 데이터를 읽고 또 정렬해야 하므로 지연 시간이 늘어난다.  
- 가장 느린 파티션에서 데이터를 다 읽고 나서야 질의 결과를 계산할 수 있으므로 지연 시간이 길어진다.
- 특정 사용자의 순위를 결정할 간단한 방법이 없다.  

따라서 고정 파티션 방안을 사용할 것이다.  

#### 레디스 노드 크기 조정

쓰기 연산이 많은 애플리케이션에는 메모리를 두 배 더 할당하는 것이 안전하다.  


### 대안: NoSQL

- 쓰기 연산에 최적화되어 있다.
- 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.

좋은 후보로는 아마존의 DynamoDB, 카산드라 또는 MongoDB 등이 있다.  
DynamoDB는 기본 키 이외의 속성을 활용하여 데이터를 효과적으로 질의할 수 있도록, 전역 보조 색인을 제공한다.  

순위표와 사용자 테이블을 비정규화하는 방안은 규모 확장이 어렵다.  
레코드가 많아지면 상위 점수를 찾기 위해 전체 테이블을 뒤져야 하므로 사용자가 많아지면 성능이 떨어진다.  

DynamoDB는 안정 해시를 사용하여 여러 노드에 데이터를 분산한다.  
`game_name#{year-month}`을 파티션 키로 설계하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라 핫 파티션이 되고 만다.  
`game_name#{year-month} % number_of_partitions`를 파티션 키에 추가하여 해결할 수 있지만, 읽기 및 쓰기 복잡도가 높아진다.  

쓰기 볼륨 또는 DAU를 기준으로 파티션의 수를 결정할 수 있다.  
다만 파티션이 받는 부하와 읽기 복잡도 사이에는 타협적인 부분이 있음에 유의하자.  
전역 보조 색인은 `game_name#{year-month}#p{partition_number}`를 파티션 키로, 점수를 정렬 키로 사용하게 구성한다.  
각 파티션에서 상위 10개 결과를 가져온 다음, 애플리케이션 단에서 그 결과를 모아 정렬하는 것이다.  

1,200,001로 정확한 순위를 표시하는 것보다 상위 10~20%에 속한다고 말하는 것이 더 나을 수 있다는 것이다.  
규모가 충분히 커서 샤딩이 필요한 상황이라면 모든 샤드의 점수 분포는 거의 같다고 가정할 수 있다.  
각 샤드의 점수 분포를 분석한 결과를 캐시하는 크론 작업을 만들어 볼 수 있다.  


## 4단계 마무리

### 더 빠른 조회 및 동점자 순위 판정 방안

레디스 해시를 사용하면 문자열 필드와 값 사이의 대응관계를 저장해 둘 수 있다.  

1. 순위표에 표시할 사용자 ID와 사용자 객체 사이의 대응관계를 저장한다.
2. 두 사용자의 점수가 같은 경우 누가 먼저 점수를 받았는지에 따라 순위를 매길 수 있다.

### 시스템 장애 복구

사용자가 게임에서 이길 때마다 MySQL에 타임 스탬프와 함께 저장한 백업본을 활용하는 스크립트를 만들면 간단히 복구할 수 있다.  
사용자별로 모든 레코드를 훑으면서, 레코드당 한 번씩 `ZINCRBY`를 호출하는 것이다.




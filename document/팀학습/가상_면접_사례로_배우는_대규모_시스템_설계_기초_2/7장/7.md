# 7장 호텔 예약 시스템

## 1단계: 문제 이해 및 설계 범위 확정

- 5000개 호텔, 100만 개 객실
- 예약할 때 대금을 지불한다고 가정
- 객실은 웹이나 앱에서만 예약 가능
- 10% 초과 예약이 가능해야 함 (over booking)
- 객실 가격은 유동적

### 비기능 요구사항

- 높은 수준의 동시성 지원: 성수기, 대규모 이벤트 기간에는 고객이 몰릴 수 있음
- 적절한 지연 시간: 예약 처리에 몇 초정도 걸리는 것은 괜찮다.

### 개략적 규모 추정

- 5000개 호텔, 100만 개 객실
- 평균 객실의 70%를 사용하고, 평균 투숙은 3일이라고 가정
- 일일 예상 예약 건수: 240,000
- 초당 예약 건수: 3 TPS

웹사이트를 사용하는 흐름  
대략 10%의 사용자가 다음 단계로 진행하고 90%의 사용자는 이탈한다고 가정  

1. 호텔/객실 상세 페이지 조회: 300 QPS
2. 예약 상세 정보 페이지 확인: 30 QPS
3. 객실 예약 (트랜잭션 발생): 3 QPS


## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 설계

#### 호텔 관련 API

#### 객실 관련 API

#### 예약 관련 API

새 예약을 만들 때 API에 전달하는 인자의 형태  

```
{
  "startDate": "2021-04-28",
  "endDate": "2021-04-30",
  "hotelId": "245",
  "roomId": "U123456789",
  "researvationId": "13422445"
}
```

researvationId는 이중 예약을 방지하고 동일한 예약은 단 한 번만 이루어지도록 보증하는 멱등 키다.  

> researvationId를 프론트에서 생성한다는 것인지?  
> 멱등 키가 필요한 이유를 이해하지 못 함  
> 동시성 문제 챕터 읽고 이해함  
> 고객은 객실이 아니라 객실 유형을 예약하는 개념이라 더블 클릭 등으로 동일한 객실 유형을 예약할 수 있음

### 데이터 모델

- 질의 1: 호텔 상세 정보 확인
- 질의 2: 지정된 날짜 범위에 사용 가능한 객실 유형 확인
- 질의 3: 예약 정보 기록
- 질의 4: 예약 내역 또는 과거 예약 이력 정보 조회

대략적인 추정 과정을 통해 시스템 규모가 크지 않은 것은 알았으나 대규모 이벤트가 있는 경우에는 트래픽이 급증할 수도 있으니 대비해야 한다.  
본 설계안에서는 관계형 데이터베이스를 선택할 것이다.  

- 관계형 데이터베이스는 읽기 빈도가 쓰기 연산에 비해 높은 작업 흐름을 잘 지원한다.  
- 관계형 데이터베이스는 ACID 속성을 보장한다.
- 관계형 데이터베이스를 사용하면 데이터를 쉽게 모델링할 수 있다.  

이 스키마 디자인에는 큰 문제가 있다.  
room_id가 있으므로 에어비앤비 같은 회사에는 적합하다.  
하지만 호텔의 경우에는 그렇지 않다.  
사용자는 특정 객실을 예약하는 것이 아니라 특정 호텔의 특정 객실 유형을 예약하기 때문이다.  
**객실 번호는 예약할 때가 아닌, 투숙객이 체크인 하는 시점에 부여된다.**  

### 개략적 설계안

- 공개 API 게이트웨이: 처리율 제한, 인증 등의 기능을 지원
- 호텔 서비스: 호텔과 객실에 대한 상세 정보 제공
- 요금 서비스: 객실의 요금은 해당 날짜에 호텔에 얼마나 많은 손님이 몰리느냐에 따라 달라짐
- 예약 서비스
- 결제 서비스
- 내부 API: 승인된 호텔 직원만 사용 가능한 API로 VPN으로만 접근 가능
- 호텔 관리 서비스

실제 상업적으로 이용되는 시스템의 서비스 간 통신에는 gRPC와 같은 고성능 원격 프로세저 호출 프레임워크를 사용하곤 한다.  

> 요금 서비스를 별도로 관리하는 것이 인상적


## 3단계: 상세 설계

### 개선된 데이터 모델

```
{
  "startDate": "2021-04-28",
  "endDate": "2021-04-30",
  "hotelId": "245",
  "roomTypeId": "U123456789",
  "researvationId": "13422445"
}
```

| room_type_inventory | 설명                      |
|---------------------|-------------------------|
| hotel_id            | 호텔 식별자                  |
| room_type_id        | 객실 유형 식별자               |
| date                | 일자                      |
| total_inventory     | 총 객실 수 - 일시적으로 제외한 객실 수 |
| total_reserved      | 예약된 모든 객실 수             |

**날짜당 하나의 레코드를 사용하면 날짜 범위 내에서 예약을 쉽게 관리하고 질의할 수 있다.**  
이 테이블은 2년 이내 모든 미래 날짜에 대한 가용 객실 데이터 질의 결과를 토대로 미리 채워 놓고, 시간이 흐름에 따라 새로 추가해야 하는 객실 정보는 매일 한 번씩 일괄 작업을 돌려 반영한다.  
위 테이블에 저장해야 하는 레코드 수는 5,000(전체 호텔 수) x 20(호텔별 객실 유형) x 2년 x 365일 = 7,300만 개  
데이터베이스 서버를 하나만 두면 SPOF 문제 발생  
고가용성을 달성하려면 여러 지역, 가용성 구역에 데이터베이스를 복제해 두어야 한다.  

10% 초과 예약이 가능하도록 조건 추가  
`if ((total_reserved + numberOfRoomsToReserve) <= 110% * total_inventory)`

예약 데이터를 단일 데이터베이스에 담기에 너무 크다고 생각 될 때  
1. 현재 및 향후 예약 데이터만 저장하고, 과거 데이터는 아키이빙 하거나 cold storage로 옮김
2. hotel_id를 샤딩 키로 하여 샤딩한다.  

### 동시성 문제

1. 같은 사용자가 예약 버튼을 여러 번 누를 수 있다.  
2. 여러 사용자가 같은 객실을 동시에 예약하려 할 수 있다.  

- 클라이언트 측 구현: 클라이언트가 요청을 전송하고 '예약' 버튼을 비활성화 시킴
- 멱등 API: 예약 API 요청에 멱등 키를 추가하는 방안

같은 사용자가 예약 버튼을 여러 번 누르는 경우
1. 예약 주문서를 만든다.  
2. 고객이 검토할 수 있도록 예약 주문서를 반환한다. 반환 결과에 전역적 유일성을 보증하는 reservation_id를 넣는다.  
3. 검토가 끝난 예약을 전송한다. 이 때 요청에도 reservation_id가 붙는다.  
4. 더블 클릭으로 같은 예약이 전송되지만, reservation_id가 동일하여 요청이 실패한다.  

여러 사용자가 같은 객실을 동시에 예약하려는 경우

#### 방안 1: 비관적 락

사용자가 레코드를 갱신하려고 하는 순간 즉시 락을 걸어 동시 업데이트를 방지하는 기술이다.  
MySQL의 경우 "SELECT FOR UPDATE" 문을 실행하면 SELECT가 반환한 레코드에 락이 걸린다.  

장점:
- 애플리케이션이 변경 중이거나 변경이 끝난 데이터를 갱신하는 일을 막을 수 있다.  
- 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다. 비관적 락은 데이터에 대한 경합이 심할 때 유용하다.  

단점: 
- DeadLock이 발생할 수 있다.  
- 확장성이 낮다. 트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없다.   

#### 방안 2: 낙관적 락

낙관적 락은 일반적으로 버전 번호와 타임스탬프의 두 가지 방법으로 구현한다.  
낙관적 락은 일반적으로 비관적 락보다 빠르다.  
하지만 동시성 수준이 아주 높으면 성능이 급격하게 나빠진다.  

장점:
- 애플리케이션이 유효하지 않은 데이터를 편집하는 일을 막는다.
- 데이터베이스 자원에 락을 걸 필요가 없다.
- 낙관적 락은 데이터에 대한 경쟁이 치열하지 않은 상황에 적합하다.

단점:
- 데이터에 대한 경쟁이 치열한 상황에서는 성능이 좋지 못하다.

낙관적 락은 호텔 예약 시스템에 적합한 선택지다.  
예약 QPS가 일반적으로는 높지 않기 때문이다.  

> QPS가 높지 않으면 비관적락이 더 확실한게 아닌가?
> 
> 토스ㅣSLASH 22 - 애플 한 주가 고객에게 전달 되기까지
> https://youtu.be/UOWy6zdsD-c?si=d_dkUqiJCG7Aryzq
>
> 벌크성 작업에서 낙관적 락은 100개의 작업 도중에 한 개라도 실패하면 나머지를 롤백해줘야 하는 번거러움이 있음  
> 시간이 걸리더라도 비관적락으로 확실하게 잡고 가는게 좋음  
> 
> 락을 사용할 때는 큐 등을 사용하여 throughput을 제어할 수 있어야 한다고 생각 함  
> 서비스 정책에 따라 다를 수 있겠지만, 결제까지 완료시키고 재고는 비동기로 처리하는 방식  
> 
> 커머스 재고에는 실재고와 가상재고가 존재함  
> 책에서는 실재고를 직접 제어하는 느낌인데, 객실유형에 가상재고 개념을 녹여야하는게 아닐지  

#### 방안 3: 데이터베이스 제약 조건

장점:
- 구현이 쉽다.
- 데이터에 대한 경쟁이 심하지 않을 때 잘 동작한다.  

단점:
- 낙관적 락과 마찬가지로 데이터에 대한 경쟁이 심하면 실패하는 연산 수가 엄청나게 늘어날 수 있다.  
- 데이터베이스 제약 조건은 애플리케이션 코드와 달라서 버전을 통제하기 어렵다.  

### 시스템 규모 확장

일반적으로 호텔 예약 시스템 부하는 높지 않다.  
하지만, 유명 여행 예약 서비스와 연동되면 QPS는 천 배 늘어날 수 있다.  
시스템 부하가 높을 때는 무엇이 병목이 될 수 있을지 이해해야 한다.  
모든 상태 정보가 보관되는 데이터베이스는 단순히 데이터베이스 서버를 늘리는 것만으로는 성능 문제를 해결할 수 없다.  

#### 데이터베이스 샤딩

이 시스템의 대부분 질의는 hotel_id를 필터링 조건으로 사용하므로 hotel_id를 샤딩 조건으로 쓰면 좋다.  
QPS가 30,000이면 샤딩 후에는 30,000 / 16(샤드 수) = 1875 QPS를 처리하게 되는데, 한 대 MySQL 서버로 감당할 수 있는 부하다.  

#### 캐시

호텔 잔여 객실 데이터는 오직 현재 그리고 미래의 데이터만이 중요하다.  
낡은 데이터는 자동적으로 소멸되도록 TTL을 설정할 수 있다면 바람직하다.  
레디스는 이런 상황에 적합한데 TTL과 LRU 캐시 교체 정책을 사용하여 메모리를 최적으로 활용할 수 있기 때문이다.  

데이터 로딩 속도와 데이터베이스 확장성이 문제가 되기 시작하면 데이터베이스 앞에 캐시 계층을 두고 잔여 객실 확인 및 객실 예약 로직이 해당 계층에서 실행되도록 할 수 있다.  
그러나 레디스 캐시 데이터는 잔여 객실이 충분해 보여도 데이터베이스를 다시 한 번 확인할 필요는 있다는 점에 유의하자.  

##### 캐시가 주는 새로운 과제

캐시 계층을 추가하면 시스템의 확장성과 처리량은 대폭 증가하지만 데이터베이스와 캐시 사이의 데이터 일관성 유지에 관한 새로운 도전에 직면하게 된다.  

변경 데이터 감지 (CDC)라는 메커니즘을 사용하는 방법도 있다.  
CDC는 데이터베이스에서 발생한 변화를 감지하여 해당 변경 내역을 다른 시스템에 적용할 수 있도록 하는 메커니즘이다.  

> DB Bin Log를 활성화하고, Bin Log를 파싱하여 원하는 작업 수행  

잔여 객실 데이터에 대한 변화를 데이터베이스에 먼저 반영하므로 캐시에는 최신 데이터가 없을 가능성이 있다.  

장점
- 읽기 질의를 캐시가 처리하므로 데이터베이스의 부하가 크게 줄어든다.  
- 읽기 질의를 메모리에서 실행하므로 높은 성능을 보장할 수 있다.  

단점
- 데이터베이스와 캐시 사이의 데이터 일관성을 유지하는 것은 어려운 문제다.  

##### 서비스 간 데이터 일관성

- 2단계 커밋: 2PC는 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜이다.  
- 사가: 각 노드에 국지적으로 발생하는 트랜잭션을 하나로 엮은 것이라 보면 된다.  

> 사가 패턴의 종류  
> Choreography: 메세지 큐를 활용하여 실패 이벤트를 발행하고, 각 서비스에서 롤백  
> Orchestration: 매니저 서버가 분산 트래잭션을 담당  
> 
> Apache Camel  
> https://camel.apache.org/docs/


## 4단계: 마무리



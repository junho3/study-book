# CHAPTER 5 진화하는 아키텍처 토폴로지

진화적 아키텍처는 커플링의 적정 수준에 주목한다.  
커플링을 맺을 아키텍처를 식별하고 최소한의 오버헤드와 비용을 들여 최대한의 이득을 볼 수 있어야 한다.  


## 5.1 진화 가능한 아키텍처 구조


### 5.1.1 동조성

한 컴포넌트를 변경했을 때 시스템의 전반적인 정확성을 유지하기 위해 다른 컴포넌트를 수정해야 한다면 두 컴포넌트는 동조적이다.  

본질적으로 동조성은 커플링을 세련되게 묘사한 언어일 뿐이지만 기술 리더와 개발자에게 커플링의 개념을 설명하기에는 더 좋은 언어다.  


#### 정적 동조성

정적 동조성은 소스 코드 수준에서 발생  
정적 동조성은 구조 설계에 정의된 구심 및 원심 커플링을 세분화한 개념이다.  
아키텍트는 구심 또는 원심 커플링의 결합 정도에 따라 다음과 같이 정적 동조성을 구분한다.  

- 명칭 동조성: 복수의 컴포넌트가 특정 엔티티명에 동의한다.  
- 타입 동조성: 복수의 컴포넌트가 특정 엔티티 타입에 동의한다.  
- 의미 동조성, 관례 동조성: 복수의 컴포넌트가 특정 값의 의미에 동의한다. int TRUE = 1, FALSE = 0
- 위치 동조성: 복수의 컴포넌트가 특정 값의 순서에 동의한다. 메소드나 함수를 호출하는 파라미터 값과 관련이 있다.  
- 알고리즘 동조성: 복수의 컴포넌트가 특정 알고리즘에 동의한다. 서버와 클라이언트 양쪽에 정의하는 해싱 알고리즘이다.


#### 동적 동조성

동적 동조성은 런타임 시점에 호출을 분석해서 확인한다.  

- 실행 동조성: 실행 순서가 복수의 컴포넌트에 영향을 미친다.
- 시점 동조성: 실행 시점이 복수의 컴포넌트에 영향을 미친다. 동시에 실행되는 두 개의 스레드가 유발하는 경합 조건이다.  
- 값 동조성: 서로 관련된 여러 값이 함께 변경되어야 하는 경우 발생하는 동조성이다. DB가 분리된 상황에서 모든 DB에 값을 동일하게 유지해야한다.  
- 식별 동조성: 복수의 컴포넌트가 동일한 엔티티를 참조한다. 분산 대기열처럼 공용으로 쓰이는 데이터 구조를 변경하면 대기열을 공유하는 컴포넌트가 모두 영향을 받는다.


#### 동조성 속성

동조성은 아키텍트와 개발자에게 유용한 분석 도구이며 동조성의 일부 속성은 개발자의 현명한 조언자 역할을 한다.  


##### 강도

아키텍트와 개발자는 더 나은 동조성 유형을 향해 리팩터링을 반복하며 코드베이스의 커플링 특성을 개선해야 한다.  
개발자는 소스 코드를 분석해 간단히 정적 동조성을 검사할 수 있으며 최신 개발 도구로 손쉽게 개선할 수 있기 때문이다.  
개발자는 소스 코드에서 의미만 있고 이름이 없는 마법의 값을 찾아 명명된 상수 타입으로 고칠 수 있다.  
의미 동조성을 명칭 동조성으로 리팩터링하는 사례다.  


##### 지역성

동조성의 지역성은 코드베이스 내부 모듈의 인접도를 나타낸다.  
하나의 모듈 안에서 서로 인접한 코드는 별도 모듈 또는 코드베이스로 떨어져 있는 코드보다 더 높은 동조성을 형성한다.  
동조성의 강도가 같다 해도 하나의 모듈에서 형성되는 것이 서로 다른 모듈에 나뉘어 있는 것보다 낫다.  

> 지난 카뱅 면접에서 AOP를 주제로 얘기했었음  
> 도메인 이벤트를 서비스 클래스에서 직접 발행할 것인가?  
> AOP를 사용해서 서비스 클래스에서 숨길 것인가?  
> 
> 서비스 클래스와 도메인 이벤트는 강한 커플링을 갖고 있음  
> 서비스 클래스에서 도메인 이벤트를 발행하게 되면 도메인 로직에 집중하기 어려울 것이고, AOP로 풀어야한다는 관점이 있음 https://supawer0728.github.io/2018/03/24/spring-event/  
> AOP로 풀게되면 서비스 클래스에 들어나지 않기 때문에 알 수가 없음  
> 
> 커플링에 대해 어떤 입장을 취할 것인가?  
> 책에서 소개한 지역성을 고려하면 서비스 클래스에서 직접 발행하는게 맞는 듯  


##### 정도

동조성의 정도는 파급력과 관련이 있다.  
동조성의 정도가 낮을수록 동조성이 코드베이스에 가하는 손상의 정도도 낮다.  
코드베이스는 점점 덩치가 커지곤 한다.  
처음에는 사소했던 문제도 그에 따라 심각해지기 마련이다.  

페이지 존스의 3가지 지침  
- 시스템을 세부 요소로 쪼개고 각각을 캡슐화시켜 전체적인 동조성을 최소화한다.
- 캡슐화의 경계를 벗어나는 나머지 모든 동조성을 최소화한다.
- 캡슐화 경계 내부에서 동조성을 최대화한다.

짐 웨이리치의 2가지 조언
- 정도의 원칙: 강도 높은 동조성을 약한 동조성으로 변환하라
- 지역성의 원칙: 소프트웨어 요소 사이의 거리가 멀수록 약한 동조성을 사용하라


### 5.1.2 경계 콘텍스트와 동조성 교차

DDD에서 정의하는 경계 콘텍스트는 도메인 내부의 모든 요소에 투명하게 열려 있지만 다른 경계 콘텍스트에는 불투명하게 닫혀 있는 존대다.  
따라서 Customer 클래스를 공용으로 생성하고 전체 조직에서 동시에 사용하는 방식은 DDD에 맞지 않는다.  

DDD를 기반으로 시스템을 설계하는 아키텍트는 시스템의 세부 구현 정보가 경계 콘텍스트 외부로 유출되지 않도록 차단해야 한다.  

연약한 아키텍처는 한 지점의 사소한 변화가 국지적인 경계를 넘어 예측할 수 없는 파손을 일으킨다.  

이 정보를 다른 애플리케이션에 노출한다는 것은 단일 애플리케이션의 데이터베이스 변경 사항이 의도치 않게 다른 애플리케이션을 중단시킬지도 모른다는 의미다.  

> 도메인 객체와 DB 테이블 구조와 다른 개념, 각자 클래스로 관리하는 것에 동의  
> 테이블의 변경이 애플리케이션 코드에 영향이 크게 미치는 경험을 했었음  
> 하지만 도메인 객체와 DB 테이블 구조는 거의 동일하게 따라가는 듯  


## 5.2 아키텍처 퀀텀 및 세분성

시스템의 각 부분을 의미적으로 결합해 기능적 응집도로 형성하는 비즈니스 개념도 많다.  

> 개별 함수지만 의미적으로 결합하기 위해 코틀린의 .also를 사용하는 편  
>
> approve() // 결제 승인  
> publishEvent() // 결제 승인 이벤트 발행  
> ---
> // 결제 승인 처리 후 이벤트를 발행하도록 묶어줌  
> approve()  
>   .also { publishEvent() }  

아키텍처 퀌텀이란 높은 기능 응집도를 갖추었으며 독립적으로 배포 가능한 컴포넌트를 가리킨다.  
시스템이 제대로 작동하기 위해 필요한 모든 구조적 요소가 아키텍처 퀀텀에 속한다.  

#### 정적 커플링

OS, 프레임워크 라이브러리, DB


#### 동적 커플링

API, Kafka를 통해 통신을 주고 받는 방식  

정적 커플링은 서비스가 서로 엮이는 방식을 묘사하며, 동적 커플링은 서비스가 런타임에 서로를 호출하는 방식을 묘사한다.  


#### 아키텍처 퀀텀

독립적으로 배포 가능한 아티팩트이며 고기능적 응집도, 강한 정적 크플링, 동적 커플링 동기화 등의 특성을 지닌다.  
워크플로 내부에 잘 배치된 마이크로서비스는 그 자체로 아키텍처 퀀텀이라 할 수 있다.  


### 5.2.1 독립 배포

퀀텀은 특정 아키텍처 내부의 독립 배포 단위이다.  
모놀리틱 아키텍처: 단일 아키텍처 퀀텀
분산 아키텍처(마이크로서비스): 커플링의 종류에 따라 차이는 있지만, 아키텍처 퀀텀이다.  

배포 자산 각각을 아키텍처 퀀텀으로 표현하면 몇 가지 유용한 효과가 생긴다.
1. 각 주체가 취급하는 문제들이 공통 언어로 표현되므로 아키텍트는 커플링 특성을, 개발자는 작동의 영역을, 운영은 배포 특성을 이해할 수 있다.  
2. 분산 아키텍처에서 서비스의 세분성을 결정할 때 아키텍트가 고려해야 할 힘이 드러난다.  
3. 독립 배포 가능성을 갖추려면 데이터베이스처럼 공통적인 커플링 지점이 아키텍처 퀀텀 내부에 포함되어야 한다.  

> 멀티모듈로 구성된 단일(모놀리틱) API 애플리케이션인 경우, 아키텍트와 개발자는 개별 모듈이 아닌 배포 단위(API 애플리케이션)으로 소통해야한다는 것으로 이해함  
> 반대로, 단일 모듈이지만 API 애플리케이션과 컨슈머 애플리케이션이 존재하는 경우, 모듈명보다 API, 컨슈머 애플리케이션으로 각각 소통해야한다는 것으로 이해함  


### 5.2.2 고기능 응집도

고기능 응집도는 클래스, 컴포넌트, 서비스 등의 구조적 근접도를 나타낸다.  

거의 대부분의 모놀리식 아키텍처는 단순히 전체 시스템의 기능을 포함하고 있을 뿐 기능의 응집도가 높지는 않다.  

이상적인 마이크로서비스 아키텍처에서 각 서비스는 단일 도메인 또는 워크플로를 모델링하므로 기능 응집도가 높다.  

> 모놀리식 아키텍처에서는 모든 작업자가 모든 데이터(DB, 테이블)에 접근할 수 있고, 작업자 별로 책임이 불분명하여 기능의 응집도가 낮은 것 같음  
> 내가 개발한 내용을 다른 분이 동일하게 작업하는 경우가 있었음  
> 
> 그러나 Gray Zone은 언제나 존재할 수 있으므로 마이크로서비스에서도 아름답게 분류되진 않고, 응집도를 떨어트리는 요소는 존재하는 듯    


### 5.2.3 강한 정적 커플링

강한 정적 커플링은 아키텍처 퀀텀의 내부 요소가 서로 긴밀하게 엮여 있음을 의미한다.  
서비스 간 계약(IP 주소, URL 등)은 강한 정적 커플링을 생성한다.  

단일 단위로 배포하고 단일 데이터베이스를 사용하는 모든 아키텍처는 항상 단일 퀀텀을 갖게 된다.  

> 애플리케이션 특성(API, 컨슈머)에 따라 항상 단일 퀀텀일 수는 없다고 생각 함  
> ex) 단일 정산 DB에 정산 API와 정산 컨슈머 애플리케이션이 각각 존재하는 경우, 단일 DB이지만 배포 단위(퀀텀)는 2개 이상일 수 있음  

중재자 이벤트 기반 아키텍처 스타일은 단일 아키텍처 퀀텀으로 평가 된다.  

> 5.2.1 절에는 퀀텀은 특정 아키텍처 내부의 독립 배포 단위라고 했는데? 반대되는 얘기가 아닌지?  
> 그림 5-3의 각 서비스들은 독립 배포 단위가 아닌건지?  

이벤트 기반 아키텍처의 서비스가 데이터베이스를 쓰지 않는다 해도 그 서비스가 데이터베이스를 쓰는 다른 서비스에 의존한다면, 이들은 모두 아키텍처 퀀텀을 이루는 정적 커플링의 일부가 된다.  

마이크로서비스 아키텍처를 설계할 때는 가능한 한 높은 수준으로 서비스를 분리하고 가급적 커플링 지점을 만들지 않도록 주의해야 한다.  

사용자 인터페이스와 밀접하게 결합된 마이크로서비스 아키텍처는 단일 아키텍처 퀀텀을 형성하기도 한다.  
사용자 인터페이스는 프론트엔드와 백엔드 사이에 커플링 지점을 만든다.  

아키텍트는 프런트엔드와 백엔드 사이의 커플링을 생성하지 않는 비동기 방식으로 사용자 인터페이스를 설계한다.  
마이크로프런트엔드 프레임워크를 적용하는 것이 최근 추세다.  

> 과거에는 페이지별 API가 있었고 해당 API가 죽으면 페이지 로딩에 실패함  
> 최근에는 페이지 섹션별로 API를 호출하고, 특정 API가 죽어도 전체 페이지 로딩에는 실패하지 않는 방식으로 이해함  

아키텍처의 모든 커플링 지점은 퀀텀적 관점에서 정적 커플링 지점이 될 가능성이 있다.  

> 특정 요소의 변경에 직접적인 영향을 받으면 정적 퀀텀으로 봐야 하는건지?  


### 5.2.4 동적 퀀텀 커플링

서비스가 서로를 호출하는 방식이 다양할수록 트레이드오프를 판단하는 어려움이 가중된다.  

#### 통신

동기 통신: Http, gRPC  
비동기 통신: Kafka, MQ  

통신 방식은 동기화, 에러 처리, 트랜잭션, 확장성, 성능 등에 영향을 미친다.  


#### 일관성

통신 호출을 주고받으며 준수해야 할 트랜잭션 무결성의 엄격함을 의미한다.  
원자 트랜잭션(all or nothing)과 최종 일관성이 있다.  

> Saga 패턴  
> Spring-boot apache camel https://camel.apache.org/camel-spring-boot/4.0.x/spring-boot.html  
> 보상 트랜잭션을 카프카, MQ로 발행  
 

#### 조정

조정은 통신을 따라 모델링된 워크플로에 얼마나 많은 조정이 필요한지를 나타낸다.  

##### 오케스트레이션
오케스트레이터 역할의 애플리케이션이 여러 서비스를 호출하면서 트랜잭션을 관리  
트랜잭션성을 달성하기 쉬움  

##### 코레오그래피
각 서비스끼리 이벤트로 통신하여 트랜잭션을 관리  
확장성이 높음  

> https://devyonghee.github.io/theory/2022/09/24/orchestration-vs-choreography/


## 5.3 계약



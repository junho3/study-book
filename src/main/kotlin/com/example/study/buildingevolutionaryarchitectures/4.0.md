# CHAPTER 4 아키텍처 거버넌스 자동화

아키텍트의 임무는 소프트웨어 시스템의 구조를 설계하고 수많은 개발 원칙과 엔지니어링 관행을 정의하는 것이다.  
아키텍트는 소프트웨어 구축 과정을 관리하며 설계 원칙과 모범 사례를 따르고 알려진 시행착오를 방지해야 한다.  


## 4.1 피트니스 함수와 아키텍처 거버넌스

진화적 아키텍처의 메커니즘은 아키텍처 거버넌스, 특히 소프트웨어 엔지니어링 관행의 진화를 상징하는 거버넌스 자동화와 겹치는 부분이 많다는 사실이 밝혀졌다.  

테스트 커버리지가 높은 프로젝트일수록 코드의 품질이 높다는 공동의 경험은 테스트 주도 개발로 이어졌다.  

XP 개발자들은 그간의 프로젝트 경험을 통해 더 자주 통합할수록 문제도 줄어든다는 상관관계에 주목했으며, 이러한 인식을 지속적 통합이라는 개념으로 발전시켰다.  
지속적 통합 프로세스에서 모든 개발자는 적어도 하루에 한 번, 기본 코드베이스에 자신의 작업을 커밋한다.  

> 작게 자주 배포할수록 장애가 줄어드는 점에 동의함  
> 
> 하루에 1000번 배포하는 조직 되기  
> https://blog.banksalad.com/tech/become-an-organization-that-deploys-1000-times-a-day/

자동화는 통합의 핵심 조건일 뿐만 아니라 엔지니어링을 최적화하는 동력이기도 하다.  
2000년대 초에 일어난 데브옵스 혁명은 자동화의 이점을 다시 한번 절감하는 계기를 마련했다.  

지속적 통합은 점진적 변화를 이끌어낸다.  
이러한 점진적 변화가 피트니스 함수와 결합하면 다양한 방면에서 엔지니어링 관행의 진화가 일어난다.  

피트니스 함수는 저수준 코드 기반 분석에서 엔터프라이즈 아키텍처에 이르기까지 모든 아키텍처 측면에 존재한다.  


## 4.2 코드 기반 피트니스 함수

### 4.2.1 구심 및 원심 커플링

구심 커플링은 코드 아티팩트(컴포넌트, 클래스, 함수 등)로 들어오는 수신 연결 수를 측정하며 원심 커플링은 다른 코드 아티팩트로 나가는 발신 연결 수를 측정한다.  

이클립스 JDepend, InteliJ, 소나큐브와 같은 도구들로 컴포넌트의 관계를 분석하고 조회할 수 있다.  


### 4.2.2 추상도, 불안정도, 메인 시퀀스와의 거리

추상도는 구상 아티팩트(구현 클래스)에 대한 추상 아티팩트(추상 클래스, 인터페이스 등)의 비율이다.  
추상(abstract) vs 구현(implement)의 척도를 나타낸다.  
추상 요소는 개발자가 코드베이스의 전체 구조를 더 잘 이해하도록 돕는 특성이다.  
10,000줄짜리 main() 메소드 하나로 구성된 코드 베이스는 이 메트릭 수치가 거의 0에 가깝다.  

> 레거시 코드를 개선할 때 가장 먼저 하는게 의미가 있는 코드들을 private 메소드로 분리하여 main 메소드의 코드량을 덜어내는 것  
>
> 2023.08 인프콘 행사 '점진적 추상화'  
> https://www.inflearn.com/conf/infcon-2023/session-detail?id=767  
> 섣부른 추상화는 코드 복잡도를 올린다는 내용

불안정도 메트릭은 코드베이스의 변동성을 결정한다.  
높은 불안정도를 보이는 코드베이스는 커플링을 이루는 정도가 높으므로 변경 사항이 전체 구조를 깨뜨리기 쉽다.  

분석 결과를 구석으로 향하게 만든 덩치 큰 메서드를 찾아 부분적으로 추출하기 시작해 점진적으로 추상도를 높인다.  
추출된 코드 사이에서 능숙하게 중복 지점을 발견 및 제거하고 불안정도를 개선할 수 있을 것이다.  

아키텍트는 이러한 메트릭을 피트니스 함수로 활용해 코드베이스가 이 정도로 저하되지 않도록 처음부터 대비할 수 있다.  


### 4.2.3 임포트 방향성

컴포넌트 순환을 방지하려면 임포트 방향성을 관리해야 한다.  
JDepend는 자바 생태계에서 패키지의 커플링 특성을 분석하는 메트릭 도구다.  
만일 개발자가 persistence에서 util 패키지를 임포트하는 실수를 범하면 이 단위 테스트가 실패하므로 코드가 커밋되기 전에 발견할 수 있다.  

> 토스ㅣSLASH 22 - 지속 성장 가능한 코드를 만들어가는 방법  
> https://youtu.be/RVO02Z1dLF8?si=6Njd2uFgnbwAaxQo  


### 4.2.4 순환 복잡도와 '군집' 거버넌스

하나의 피트니스 함수에 엄격한 임곗값을 설정하는 방법도 있지만, 점점 더 나은 값을 향해 팀의 역량을 집중하는 방법도 있다.  
피트니스 함수를 연쇄적으로 구성하고 단계마다 상한성을 정해 경고를 발생시키는 방법도 있다.  

이러한 기법을 메트릭 기반 피트니스 함수 전반에 적용해 원하는 값에 근접하며 점진적으로 범위를 좁힐 수 있다.  
팀은 기술 부채를 해결한 이후에도 피트니스 함수를 그대로 유지할 것이며 향후 발생할 성능 저하까지 방지할 수 있다.  
이것이 바로 거버넌스를 통해 비트 부패를 방지하는 핵심이다.  


## 4.3 턴키 도구

아키텍처가 놓인 생태계의 보편성이 높을수록 아키텍처와 잘 맞는 일반화되 도구를 찾을 가능성도 높아진다.  


### 4.3.1 오픈 소스 라이브러리의 적법성

### 4.3.2 접근성 및 기타 아키텍처 특성

### 4.3.3 ArchUnit

일반적인 코드 구조가 아닌 아키텍처 기능을 테스트하도록 설계되었다.  

#### 패키지 종속성

#### 클래스 의존성 검사

#### 상속 검사

인터페이스 구헌체의 네이밍 검사 가능

#### 어노테이션 검사

#### 계층 검사

역방향 계층 접근과 계층 우회 검사 가능

> 그 동안 패키지 접근 권한을 제한하기 위해 멀티모듈과 Gradle 설정만으로 했음  
> 그로 인해 간혹 테스트 코드 작성에 어려움이 존재했음  
> ArchUnit으로 피트니스함수를 구현한다면, 굳이 멀티모듈로 하지 않아도 될 듯  


### 4.3.4 코드 거버넌스와 린터

대부분의 프로그래밍 언어는 코드의 안티패턴이나 결함을 찾는 스캔 도구인 린터를 포함하고 있다.  

> 코틀린 Ktlint 사용 중  


### 4.3.5 가용성 피트니스 함수

피트니스 함수는 어림짐작이 아닌 정확한 측정을 통해 소프트웨어 개발을 어엿한 엔지니어링 기술의 반열에 올린다.  


### 4.3.6 카나리아 릴리스와 부하 테스트


### 4.3.7 이식 원칙

> Google Analytics로 고객 행동 패턴 분석


### 4.3.8 이미 사용 중인 피트니스 함수

피트니스 함수 개념이 주는 통찰은 다양한 도구를 하나의 관점으로 통합하는 사고 방식을 이끈다.  
따라서 이러한 사고 방식이 없다면 이미 다양한 피트니스 함수를 사용하고 있다 해도 그것을 피트니스 함수라 부리지 않고 있을 가능성이 높다.  

> 하나의 관점으로 통합하는 사고 방식을 이끄는 것이 무엇을 의미하는건지?  
> 도구를 사용해서 데이터를 측정하고 의미를 부여해야한다는 것인지?  

단순히 트래픽을 모니터링하고 관찰한다 해서 측정이 곧바로 피트니스 함수가 되는 것은 아니다.  
객관적인 척도에 경고와 알림을 접목해야만 측정값이 피트니스 함수로 변환된다.  


## 4.4 통합 아키텍처

피트니스 함수는 개별 애플리케이션에 적용하는 경우가 많지만, 사실상 아키텍처 생태계에서 거버넌스가 필요한 모든 부분에 적용할 수 있다.  


### 4.4.1 마이크로서비스의 통신 거버넌스

마이크로서비스를 다루려면 하나의 도구만으로는 역부족이다.  
각 서비스는 서로 다른 기술 스택, 리포지터리, 통신 프로토콜, 기타 여러 변수 속에서 제작된다.  
따라서 마이크로서비스에 피트니스 함수를 적용할 턴키 도구를 찾기란 거의 불가능하다.  

> 마이크로서비스에서 순환참조라는 개념이 존재하는가?  
> 예를 들어 커머스의 최종단이라고 할 수 있는 정산 서비스에서 상품 서비스를 호출하면 안되는가?  
> 정산 서비스에서 특정 상품 정보가 필요한 경우, 주문 서비스에서부터 필요한 상품 정보를 받아서 결제, 정산 서비스에 넘겨야하는가?

실시간 모니터링을 바탕으로 통신을 검사할 수도 있다.  

> Zipkin에서 트래픽 흐름을 보는 편  

사후에 검증하는 반응적 기법은 아키텍처의 러타임 특성에 오버헤드를 주지 않는다.  
반면 모니터링을 동반한 능동적 기법은 오버헤드를 일으키는 대신 하루를 기다릴 필요 없이 위반 사항을 즉시 포착할 수 있다.  

서비스 간 무단 통신이 즉각적인 문제 (보안 등)를 야기한다면 아키텍트는 이를 능동형 피트니스 함수로 구현해야 한다.  
그러나 거버넌스의 목적이 아키텍처 구조 유지에 있다면 로그 기반 반응형 피트니스 함수를 만드는 것이 낫다.  


### 4.4.2 피트니스 함수 구현 방법 선택

> Spring-cloud-sleuth와 Spring-cloud-stream-kafka 사용 중  
> traceId로 서비스간 API 호출과 발행/컨슈밍한 카프카 메세지를 추적하고 있음  
> 하지만, 책에서 소개한 것처럼 피트니스함수화 하여 검증하진 않음  
>
> Inbox, Outbox 패턴으로 카프카 메세지 누락을 보완할 수 있을 듯  


## 4.5 데브옵스

피트니스 함수는 소프트웨어 아키텍처와 운영의 교차 지점에 있다.  
피트니스 함수는 객관적인 거버넌스 점건 결과를 드러낸다.  

카오스 엔지니어링의 기본 원칙은 많은 이의 공감을 얻는다.  
시스템은 반드시 장애를 일으킨다.  
문제는 그것이 언제인가다.  
예측할 수 있는 최종 상황을 설계하고 관리함으로써 아키텍트와 운영자는 한층 견고한 시스템을 발판 삼아 협업할 수 있다.  

- 카오스 엔지니어링
- 카오스 멍키
- 카오스 고릴라
- 카오스 콩
- 닥터 멍키
- 레이턴시 멍키
- 문지기 멍키
- 적합성 멍키
- 보안 멍키


## 4.6 엔터프라이즈 아키텍처

애플리케이션이 세부적인 정보를 이용해 서비스에 접근하면 취약점을 노출 시킬 위험이 높아진다.  
엔터프라이즈의 각 부분이 상호작용하는 방식과 구현 세부 정보가 애플리케이션으로 유출되기 때문이다.  

> MSA 환경에서 코어 어플리케이션을 직접 호출하지 말라는 의미인지?  
> 어플리케이션별로 앞단에 게이트웨이를 두라는 의미인지?  

새로운 아키텍처는 플랫폼 수준에서 구현 세부 사항을 캡슐화함으로써 구현 커플링의 확산을 늦출 수 있으며 결과적으로 아키텍처의 취약성을 낮추는 효과를 낸다.  

얼어붙은 원시인 안티패턴은 과거의 예상치 못한 사고에 계속 집착하는 것  

> 4.6장은 잘 이해가 안됨  
> 엔터프라이즈 아키텍처 관점에서 구현 사항을 캡슐화하라는 것이 무엇인지?  
> 엔터프라이즈 아키텍트는 기술적인 선택에서 벗어날 수 있다는 이점이 무엇인지?  


### 4.6.1 일간 60회 배포와 아키텍처 재구성

깃허브는 하루 평균 60회 배포라는 공격적인 엔지니어링 관행으로 잘 알려져 있다.  

Scientist는 A/B 테스트를 지원하므로 성능 모니터링 기능을 내장하고 있다.  

이 책의 관점에서 Scientist는 피트니스 함수다.  
이번 사례에서 개발자는 중요 인프라를 리팩토링하기 위해 전체적이고 지속적인 피트니스 함수를 전략적으로 사용했다.  
피트니스 함수 덕분에 확신을 가지고 리팩터링을 진행한 탁월한 사례라 할 수 있다.  


### 4.6.2 정확성 피트니스 함수

Scientist 도구는 정확성 피트니스 함수라는 검증 유형을 구현한다.  
이 기능은 시스템을 교체하는 동안 양 시스템의 정확성을 보존하는 수단이다.  

정확성 피트니스 함수를 이용하면 구형과 신형 시스템을 나란히 비교할 수 있다.  

> 카나리 배포?


## 4.7 피트니스 함수는 무기가 아닌 체크리스트다

피트니스 함수는 아키텍처 원칙을 시행할 방법을 제시해야 한다.  

그러나 실행되지 않는 원칙은 일정의 압박과 여러 제약 조건 속에서 유명무실해진다.  
아키텍처 설계 원칙과 거버넌스 규칙을 피트니스 함수로 변환하면 설령 외부의 힘이 작용한다 해도 생략되거나 건너뛰지 않도록 절차를 보장할 수 있다.  

개발자는 피트니스 함수의 기능을 이해하고 파손될 경우 이를 고칠 수 있어야 한다.  


## 4.8 피트니스 함수 문서화

테스트는 좋은 문서와 같다.  

아키텍처 결정을 문서화할 때는 아키텍처 결정 레코드(ADR)을 참고하면 좋다.  

> https://adr.github.io/  

Cucumber와 같은 행위 주도 개발(BDD) 프레임워크를 사용하는 것도 한 가지 방법이다.  

> Kotlin은 Ktlint DCI 패턴을 주로 사용 중  

```
describe("findById 메소드는") {
    context("주문 데이터가 존재하면") {
        ...

        it("Order 객체를 리턴한다.") {
            ...
        }
    }

    context("주문 데이터가 존재하지 않으면") {
        it("IllegalArgumentException을 던진다.") {
            ...
        }
    }
}
```

> Java는 JUnit @Nested 어노테이션으로 DCI 패턴을 사용 중

```
@Nested
@DisplayName("create 메소드는")
class Describe_create {
    @Nested
    @DisplayName("CreateMemberParam이 주어지면")
    class Context {
        
        ...
        
        @Test
        @DisplayName("Member를 생성한다.")
        void it() {
            ...
        }
    }
}
```


리터레이트의 목표는 최종적으로 더욱 깨끗한 문서를 만드는 것이다.  

개발자가 피트니스 함수의 존재 이유를 납득하지 못하면 피트니스 함수를 수정하는 일도 성가신 골치거리로 여기게 되기 때문이다.  
조직 내 기존 문서 프레임워크에 피트니스 함수 정의를 통합할 것을 권장한다.  


## 요약

단위 테스트가 도메인의 변화에 대응하듯 피트니스 함수는 아키텍처 거버넌스에 대응한다.  
테스트 프레임워크를 전부 새로 만들어야 한다는 의미는 아니다.  
피트니스 함수는 시간이 지나도 부패하지 않고 진화하는 시스템을 위해 아키텍트가 만든 아키텍처 특성 가드레일이다.  


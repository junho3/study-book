# 7.5 데이터에 대해 진실의 원천을 하나만 가져야 한다

- 기본 데이터: 코드에 제공해야 할 데이터. 코드에 이 데이터를 알려주지 않고는 코드가 처리할 방법이 없다.
- 파생 데이터: 주어진 기본 데이터에 기반해서 코드가 계산할 수 있는 데이터

> 파생 데이터는 커스텀 프로퍼티로 선언하는 편  
> 커스텀 프로퍼티로 null인 값을 not null을 보장하는 백킹프로퍼티 선언  
```
data class Order(
    val orderAmount: Int,
    val couponAmount: Int,
    val point: Int,
    val orderAt: LocalDateTime,
    val _phoneNumber: String?,
) {
    val transactionAmount: Int
        get() = orderAmount.minus(couponAmount).minus(point)
        
    val orderDate: LocalDate,
        get() = orderAt.toLocalDate
        
    // 백킹 프로필드
    val phoneNumber: String
        get() = requireNotNull(_phoneNumber) { "전화번호가 NULL일 수 없습니다." }
}
```

## 7.5.1 또 다른 진실의 원천은 유효하지 않은 상태를 초래할 수 있다

기본 데이터와 파생 데이터를 모두 처리하는 코드를 작성할 때, 이와 같이 논리적으로 잘못된 상태가 발생할 수 있다.  

> 하나의 결제건에 여러개의 부분취소가 발생한 경우, 잔액 계산을 어떻게 할 것인가?  
> 결제금액: 10,000원  
>  ㄴ 첫번째 부분취소 금액: 1,000원  
>  ㄴ 두번째 부분취소 금액: 2,000원  
>  ㄴ 세번째 부분취소 금액: 500원  
> 잔액: 6,500원
> 
> 1. 두번째 부분취소 잔액 7,000원에서 세번째 부분취소 금액 500원을 차감하도록 할 것인가?  
> 2. 결제금액 10,000원에서 첫번째 ~ 세번째까지 모두 차감하도록 할 것인가?  
> 
> 금액은 정합성이 보장되야 하므로 2번 방식 선호  
> 1번 방식은 혹시라도 중간에 값이 틀어지면 이후 값이 모두 틀어짐  

## 7.5.2 해결책: 기본 데이터를 유일한 진실의 원천으로 사용하라

파생된 값을 계산하는 데 많은 비용이 든다면, 그 값을 지연 계산한 후 결과를 캐싱하는 것 좋다.  
기본 데이터가 불변일 경우에만 가능, 기본 데이터가 가변인 경우 오류를 일으키기 쉬움  

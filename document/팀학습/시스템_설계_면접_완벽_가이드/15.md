# 15 에어비앤비 설계

- 영화 티켓
- 항공권
- 주차장
- 택시나 차량 공유 서비스


## 15.1 요구사항

결제 솔루션은 국가, 주, 도시와 기타 정부 수준에 따라 다르고 다양한 제품과 서비스에 따라 다른 수많은 통화와 규정(세금 포함)을 고려해야한다.  

- 요구사항
  - 방은 중복 예약될 수 없다.  

비판적 사고와 세부 사항에 대한 관심을 보여주기 위해 다음과 같은 기능적 요구사항을 언급하는 것이 좋다.  

- 비기능적 요구사항
  - 10억 개의 방이나 1억 건의 일일 예약으로 확장 가능
  - 예약, 더 정확히는 목록 가용성에 강한 일관성을 적용. 따라서 일반적으로 이중 예약이나 이용 불가능한 날짜의 예약이 없을 것이다.
  - 높은 성능은 불필요하다. P99 몇 초면 허용 가능하다.
  - 일반적인 보안과 프라이버시 요구사항은 인증이 필요하다.


## 15.2 설계 결정

- 방 목록의 정보를 여러 데이터 센터에 복제해야 하는가?
- **데이터 모델은 방의 가용성을 어떻게 표현해야 하는가?**

### 15.2.1 복제

검색은 한 번에 한 도시에서만 가능하다.  
이를 활용해 많은 목록이 있는 도시나 목록이 적은 여러 도시에 데이터 센토 호스트를 핟랑할 수 있다.  
쓰기 성능이 중요하지 않으므로 단일 리더 복제를 사용할 수 있다.  

읽기 지연을 최소화하기 위해 보조 리더와 팔로워를 지리적으로 데이터 센터에 분산시킬 수 있다.  
메타데이터 서비스를 사용하여 도시와 리더 및 팔로워 호스트 IP 주소의 매핑을 포함하면 우리 서비스가 지리적으로 가장 가까운 팔로워 호스트를 조회하여 특정 도시의 방을 가져오거나 해당 도시에 해당하는 리더 호스트에게 글을 쓸 수 있다.  

방이 매우 인기 있다면 곧 예약돼 더 이상 검색에 표시되지 않을 것이다.  
캐시의 최신성을 유지하기가 어렵고 캐시된 데이터가 빠르게 낡는다는 것이다.  

항상 그렇듯이 이러한 결정은 논쟁의 여지가 있으며, 그 트레이드오프를 설명할 수 있어야 한다.  


### 15.2.2 방 가용성 데이터 모델

데이터 모델에서 방 가용성을 표현하는 다양한 방법을 빠르게 브레인스토밍하고 그 트레이드오프를 설명해야 한다.  

- (room_id, date, guest_id) 테이블
  - 이는 개념적으로 단순하지만 날짜만 다른 여러 행을 포함해야 한다는 트레이드오프가 있다.
  - 예를 들어 방 1이 한 달동안 게스트에 의해 예약되면 31개의 행이 있을 것이다.
- (room_id, guest_id, check_in, check_out) 테이블
  - 게스트가 체크인과 체크아웃 날짜로 검색을 제출할 때 날짜가 겹치는지 확인하는 알고리즘이 필요하다.
  - 이 알고리즘을 데이터베이스 쿼리에 코딩해야할 까, 아니면 백엔드에 코딩해야 할까?
  - 백엔드 호스트가 데이터베이스에서 대상이 되는 방의 가용성 데이터를 가져와야 한다면 I/O 비용이 발생할 것이다.


### 15.2.3 겹치는 예약 처리

여러 사용자가 같은 방을 겹치는 날짜로 예약하려고 시도하면 첫 번째 사용자의 예약이 허용돼야 하며, 다른 사용자에게 이용할 수 없을 알려야 한다.  


### 15.2.4 검색 결과 무작위화

### 15.2.5 예약 과정 중 방 잠금

사용자가 예약 요청을 제출하려고 할 때 몇 분 동안 그 방에 대해 해당 날짜를 잠글 수 있다.  

이는 일부 예약을 잃게 된다는 것을 의미한다.  
이중 예약을 방지하는 것이 예약 손실의 트레이드오프를 감수할 만한 가치가 있다고 판단할 수 있다.  

이는 에어비앤비와 호텔의 차이점이다.  
호텔은 몇 건의 취소가 발생할 것으로 예상할 수 있으므로 저렴한 객실의 초과 예약을 허용할 수 있다.  

> 호텔은 방이 많기 때문에 에어비앤비와 DB 설계를 다르게 접근해야할 것 같음  
> 오버부킹을 허용해야함  
> 어떻게하면 특정 방을 기간동안 할당할 수 있을까?  


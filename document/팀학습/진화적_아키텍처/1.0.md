# CHAPTER 1 진화적 소프트웨어 아키텍처

## 1.1 진화적 소프트웨어의 과제

비트 부패는 시간이 지남에 따라 소프트웨어 품질이 서서히 저하되거나 응답성이 감소해 결국 소프트웨어 결함을 일으키는 변화를 말한다.  

소프트웨어의 품질을 유지하기 어려운 이유
- 복잡한 소프트웨어의 다양한 작동부를 전체적으로 관리하기 쉽지 않음
- 개발 생태계는 항상 역동적으로 변화하기 때문

마치 생물학적 생태계와 비슷하게, 소프트웨어 생태계는 개발자가 이해하고 만들 수 있는 것들로 이뤄진 일종의 균형을 형성한다.  
그러나 이러한 균형은 동적이다.  
끊임없이 새로운 요소가 등장해 기존의 균형을 무너뜨리고 새로운 균형을 이룬다.  

> 달리고 있는 자동차의 바퀴를 갈아끼우는 일
> 
> 최근 3Q 회고 때 보험에서 오신 분들이 빠른 기능 개발과 시스템 개편이 좋았다는 의견을 주셨음  
> 보수적인 보험 개발팀에서는 신규 개발이 거의 6개월이 걸린다고 함  
> 소프트웨어 / 시스템 진화는 조직이나 회사 분위기 영향도 많이 받는다고 생각함  

컨테이너화가 부상하는 과정은 일련의 소소하고 점진적인 사건을 통해 추적해볼 수 있다.  
과거에는 라이센스 취득에 막대한 비용이 지불되어 리소스를 효율적으로 공유하는 데 중점을 두었다.  
리눅스와 데브옵스의 발전으로 운영 비용이 사라지고, 오픈 소스 사용이 증가함  
오픈 소스를 잘 다루기 위해 도커가 탄생 함  

오픈 소스 운영체제가 대중화되고 지속적 전달 주도 엔지니어링 관행과 결합하면서, 일부 선구자적 아키텍트들은 더욱 높은 확장성을 지닌 시스템 구축 기법을 발견해냈다.  
마이크로서비스란 결국 이러한 방법론을 가리키기 위해 붙여진 이름이다.  

구조 설계를 시작할 때는 아래 7가지 요소를 도메인(요구사항)과 아키텍처 특성이라는 두 영역으로 나누어 생각해야 한다.  
- 감사성
- 성능
- 보안
- 요구 사항
- 데이터
- 적법성
- 확장성

이 책에서 아키텍트의 역할을 언급할 때는 조직 내 직책과 관계없이 아키텍처 관련 결정을 내리는 모든 이가 그 대상이다.  

애자일의 목표는 쓸모없는 오버헤드를 제거하는 것이지 설계처럼 꼭 필요한 단계를 생략하는 것이 아니다.  


## 1.2 진화적 아키텍처

진화적 소프트웨어 아키텍처는 여러 차원에 걸쳐 유도된 변화와 점진적 변화를 지원한다.  

### 1.2.1 유도된 변화

아키텍처의 핵심 특성을 선정하고 나면 해당 특성을 보호하는 방향으로 아키텍처가 변화하도록 유도해야 한다.  
이를 위해 피트니스 함수라는 진화적 컴퓨팅 개념을 차용할 것이다.  
피트니스 함수란 예상 설계 솔루션의 설정 목표 달성도를 간단하게 확인할 수 있는 목적 함수다.  

> 테스트 코드로 레이어드 아키텍처 강제하기  
> https://bugoverdose.github.io/development/fitness-function-for-layered-architecture/  
> 특정 아키텍처 특성이 제대로 지켜지고 있는지 평가하는 다양한 수단이 바로 아키텍처 피트니스 함수이며, 아키텍트는 자동화 피트니스 함수를 만들어 개발자들에게 제공함으로써 아키텍처 결정의 컴플라이언스를 보장할 수 있습니다.  

### 1.2.2 점진적 변화

점진적 변화는 소프트웨어 아키텍처의 두 측면, 소프트웨어의 점진적 빌드와 배포방법을 나타낸다.  

소규모의 점진적 변화를 허용하는 아키텍처가 진화에 유리하다.  
배포 관점에서 보는 점진적 변화는 비즈니스 기능의 모듈화 및 분리 수준과 아키텍처 매핑 방식에 관련된 사안이다.  

> 코드 레벨에서 적용 가능한 이야기  

### 1.2.3 다중 아키텍처 차원

분리된 시스템은 없다. 세상은 연속체다. 시스템의 경계를 어떻게 그릴 것인지는 논의의 목적에 달려있다.  

진화 가능한 아키텍처를 설계하려는 아키텍트는 변화의 영향이 미치는 시스템 요소의 모든 상호 연결 관계를 고려해야 한다.  

DB의 엔티티 관계도와 보안 등 시스템이 진화하는 과정에서 발생할 수 있는 사안들은 아키텍처를 이루는 차원의 일종이다.  
성능, 보안, 확장성 등의 차원은 아키텍처의 관심사에 속하지만, 차원의 범주는 이보다 넓고 아키텍처 기술 이외의 영역까지 포괄한다.  
아키텍트 담당자는 진화의 관점에서 이를 반드시 고려해야 한다.  

> 구체적인 사례가 소개되지 않아 내용이 와닿지 않음  
> 단순한 기능 개발도 포함해서 생각해야 한다는건지?  

#### 기술
아키텍처의 구현부, 프레임워크, 의존 라이브러리, 구현 언어 등  

#### 데이터
데이터베이스 스키마, 테이블 레이아웃, 최적화 등  

#### 보안
보안 정책과 지침 정의, 결함 조사 도구 선정  

#### 운영/시스템
기존의 물리/가상 인프라와 아키텍처를 매핑하는 방식 결정  


시스템의 확장성, 보안, 분산, 트랜잭션 등 경쟁 관계에 있는 다양한 관심사가 서로 얽히기 시작하면 아키텍트는 프로젝트에 담긴 차원을 확장해야 한다.  
아키텍트는 모든 차원에 걸쳐 시스템이 전체적으로 진화할 수 있는 방법을 최우선으로 고려해야 한다.  

최근 들어, 팀 구조의 결합이 아키텍처에 미치는 놀라운 영향력을 체감한 소프트웨어 회사가 증가하고 있다.  

> 콘웨이의 법칙  


## 1.3 상시 변화하는 환경의 장기 계획 수립 가능성

전통적인 개발 환경에서 장기 계획을 수립했던 관행의 이면에는 소프트웨어 변경 비용이 매우 높다고 여겼던 재정적인 동기가 있다.  
그러나 현대의 엔지니어링 관행은 프로세스 자동화와 데브옵스 기술의 발전을 통해 소프트웨어 변경 비용을 낮춤으로써 기존의 전제를 무효로 만든다.  

손쉬운 변경이 아키텍처의 기본 원칙이 된다면 벼경은 더 이상 어려운 문제가 아니다.  


## 1.4 시간에 따른 아키텍처의 성능 저하 방지

간혹 이러한 구조를 무시하고 중간 계층 없이 프레젠테이션에서 퍼시스턴스 계층으로 직접 접근할 권한을 요청하는 개발자가 종종 등장한다.  
대부분은 성능이라는 명분을 내세운다.  
그러나 아키텍트가 계층을 분리한 이유는 벼경사항을 격리하기 위해서다.  

> 이러한 현상 때문에 멀티모듈과 Gradle로 강제한 구조를 선호하긴 함  
> 1.2.1에서 소개한 피트니스 함수를 활용하면 단일모듈에서도 강제할 수 있을 듯  

아키텍트가 확장성에 중점을 두고 아키텍처를 설계했다면 시스템이 진화하더라도 확장성이 저하되는 것을 원치 않을 것이다.  
이렇듯 진화성은 다른 모든 아키텍처 특성을 보호하는 메타적 성격을 띤 아키텍처 래퍼다.  


## 1.5 왜 진화인가?

이 책에서 설명하는 진화적 아키텍처의 정의는 점진적 아키텍처, 유도된 아키텍처라는 두 가지 핵심 특성을 동시에 포함한다.  

시스템 설계 원칙의 트레이드오프를 저울질할 때는, 단숨함과 복잡함을 가르기보다 복잡한 시스템을 다양한 방식으로 구분하는 경우가 많다.  
즉 성공적인 시스템을 판가름하는 기준은 시스템마다 고유하게 존재한다.  

매우 단순한 시스템을 구축할 때는 아키텍처의 고려 사안들에 크게 신경을 쓸 필요가 없다.  
그러나 정교한 시스템은 목적에 부합하는 설계와 함께 정확한 출발점이 필요하다.  

